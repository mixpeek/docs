{
  "openapi": "3.1.0",
  "info": {
    "title": "Mixpeek API",
    "description": "This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.",
    "termsOfService": "https://mixpeek.com/terms",
    "contact": {
      "name": "Mixpeek Support",
      "url": "https://mixpeek.com/contact",
      "email": "info@mixpeek.com"
    },
    "version": "0.81"
  },
  "servers": [
    {
      "url": "https://api.mixpeek.com",
      "description": "Production"
    },
    {
      "url": "https://staging-api.mixpeek.com",
      "description": "Staging"
    }
  ],
  "paths": {
    "/v1/private/organizations": {
      "post": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Create Organization Private",
        "description": "Create a new private organization.\n\nThis automatically creates a 'default' namespace with all available feature extractors\nfor the organization, so users can start using the API immediately without manual setup.\n\nThe default namespace includes:\n- All registered feature extractors from the registry\n- Auto-generated vector indexes for each extractor\n- Auto-generated payload indexes for each extractor",
        "operationId": "create_organization_private_v1_private_organizations_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrganizationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "x-mcp-hidden": true
    },
    "/v1/private/organizations/{organization_identifier}": {
      "get": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Get Organization Private",
        "description": "Get a private organization by ID or name.",
        "operationId": "get_organization_private_v1_private_organizations__organization_identifier__get",
        "parameters": [
          {
            "name": "organization_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Organization Identifier"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Update Organization Private",
        "description": "Admin-only: update organization tier and/or rate limits.",
        "operationId": "update_organization_private_v1_private_organizations__organization_identifier__patch",
        "parameters": [
          {
            "name": "organization_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Organization Identifier"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OrganizationAdminUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Delete Organization Private",
        "description": "Delete a private organization.",
        "operationId": "delete_organization_private_v1_private_organizations__organization_identifier__delete",
        "parameters": [
          {
            "name": "organization_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Organization Identifier"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "x-mcp-hidden": true
    },
    "/v1/private/organizations/add-user": {
      "post": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Add User To Organization Private",
        "description": "Add a user to a private organization.",
        "operationId": "add_user_to_organization_private_v1_private_organizations_add_user_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddUserToOrganizationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "x-mcp-hidden": true
    },
    "/v1/private/organizations/{organization_id}/users/{user_email}/bootstrap-key": {
      "post": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Create Bootstrap Api Key",
        "description": "Create the organization's primary API key (requires MIXPEEK_PRIVATE_KEY).\n\n\ud83d\udd11 IMPORTANT - Two Different Keys (DO NOT CONFUSE):\n\n1. MIXPEEK_PRIVATE_KEY (what you use to call THIS endpoint):\n   - Static, hardcoded token shared between studio proxy and backend\n   - Used ONLY for server-to-server /v1/private/* endpoint calls\n   - Never changes, never stored in database\n   - Never used by frontend UI\n   - Example: xnefritAiaKQiddNL3ZHWEN4cHWLsCkwEycUDLU2wLekQEuf\n\n2. Organization API Key (what THIS endpoint creates and returns):\n   - Created ONCE per organization with ADMIN permissions\n   - Used by frontend UI for ALL /v1/* API calls\n   - Named \"admin-key\" and stored in database (hashed)\n   - Plaintext returned ONCE on creation\n   - \ud83d\udd12 PROTECTED: Users CANNOT delete, rotate, or change permissions on this key\n   - Example: sk_kbHvXHAySDUrzrPo2ajwmqBAXJ...\n\nThis endpoint creates an Organization API key (type #2) that the frontend will use.\nIt does NOT create, modify, or touch the MIXPEEK_PRIVATE_KEY (type #1).\n\n\u26a0\ufe0f The plaintext key is only returned ONCE on creation - store it in localStorage!\n\u26a0\ufe0f If called when key exists: Returns 409 error (key already created, use localStorage)",
        "operationId": "create_bootstrap_api_key_v1_private_organizations__organization_id__users__user_email__bootstrap_key_post",
        "parameters": [
          {
            "name": "organization_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Organization Id"
            }
          },
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Create Bootstrap Api Key V1 Private Organizations  Organization Id  Users  User Email  Bootstrap Key Post"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/private/configurations/storage/cors": {
      "get": {
        "tags": [
          "System Configurations - Admin Only"
        ],
        "summary": "Get Current CORS Configuration",
        "description": "Retrieve the current CORS configuration for the object storage bucket.\n\n    **Use this to:**\n    - Verify CORS is properly configured\n    - Check which origins are currently allowed\n    - Troubleshoot CORS-related issues\n    - Audit current security settings",
        "operationId": "get_storage_cors_v1_private_configurations_storage_cors_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CORSConfigurationInfo"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "System Configurations - Admin Only"
        ],
        "summary": "Configure CORS for Object Storage",
        "description": "Configure CORS (Cross-Origin Resource Sharing) on the object storage bucket.\n\n    **Why is this needed?**\n    When using presigned URLs for browser-based uploads, browsers enforce CORS policies.\n    Without proper CORS configuration, uploads from the frontend will fail with CORS errors.\n\n    **When to use this:**\n    - During initial setup of the Mixpeek platform\n    - When adding new frontend domains (development, staging, production)\n    - When troubleshooting browser upload failures\n\n    **Important notes:**\n    - This is an admin-only operation (requires admin API key)\n    - CORS is configured on the entire object storage bucket (not per-namespace)\n    - Changes take effect immediately but may be cached by browsers\n    - This works for any object storage provider (S3, LocalStack, GCS)\n\n    **Common use cases:**\n    1. Local development: Configure localhost origins\n    2. Production: Configure production domain origins\n    3. Multi-environment: Configure multiple origins for dev/staging/prod",
        "operationId": "configure_storage_cors_v1_private_configurations_storage_cors_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfigureCORSRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CORSConfigurationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/health": {
      "get": {
        "tags": [
          "Health"
        ],
        "summary": "Healthcheck",
        "description": "Health check endpoint.",
        "operationId": "healthcheck_v1_health_get",
        "parameters": [
          {
            "name": "deep",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Deep"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthCheckResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/features/extractors": {
      "get": {
        "tags": [
          "Feature Extractors"
        ],
        "summary": "List Feature Extractors",
        "description": "List all available feature extractors grouped by category",
        "operationId": "list_feature_extractors_v1_collections_features_extractors_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/FeatureExtractorResponseModel"
                  },
                  "type": "array",
                  "title": "Response List Feature Extractors V1 Collections Features Extractors Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/features/extractors/{feature_extractor_id}": {
      "get": {
        "tags": [
          "Feature Extractors"
        ],
        "summary": "Get Feature Extractor by Name",
        "description": "Get detailed information about a specific feature extractor by its name",
        "operationId": "get_feature_extractor_by_id_v1_collections_features_extractors__feature_extractor_id__get",
        "parameters": [
          {
            "name": "feature_extractor_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Feature Extractor Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeatureExtractorResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections": {
      "post": {
        "tags": [
          "Collections"
        ],
        "summary": "Create Collection",
        "description": "This endpoint allows you to create a new collection.",
        "operationId": "create_collection_v1_collections_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCollectionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}": {
      "get": {
        "tags": [
          "Collections"
        ],
        "summary": "Get Collection",
        "description": "This endpoint allows you to retrieve a collection by ID or name.",
        "operationId": "get_collection_v1_collections__collection_identifier__get",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the collection to retrieve",
              "title": "Collection Identifier"
            },
            "description": "The ID or name of the collection to retrieve"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Collections"
        ],
        "summary": "Update Collection",
        "description": "Update mutable collection fields (e.g., taxonomy_applications)",
        "operationId": "update_collection_v1_collections__collection_identifier__patch",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the collection to update",
              "title": "Collection Identifier"
            },
            "description": "The ID or name of the collection to update"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": true,
                "title": "Updates"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Collections"
        ],
        "summary": "Delete Collection",
        "description": "This endpoint allows you to delete a collection by ID or name.",
        "operationId": "delete_collection_v1_collections__collection_identifier__delete",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the collection to delete",
              "title": "Collection Identifier"
            },
            "description": "The ID or name of the collection to delete"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/features": {
      "get": {
        "tags": [
          "Collections"
        ],
        "summary": "Describe collection features",
        "description": "List feature addresses and metadata available in this collection",
        "operationId": "describe_collection_features_route_v1_collections__collection_identifier__features_get",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the collection to describe",
              "title": "Collection Identifier"
            },
            "description": "The ID or name of the collection to describe"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeCollectionFeaturesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/list": {
      "post": {
        "tags": [
          "Collections"
        ],
        "summary": "List Collections",
        "description": "This endpoint allows you to list collections.",
        "operationId": "list_collections_v1_collections_list_post",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Offset"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListCollectionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCollectionsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/documents/{document_id}": {
      "get": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Get a document by ID.",
        "description": "Get a document by ID.",
        "operationId": "get_document_v1_collections__collection_identifier__documents__document_id__get",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection."
          },
          {
            "name": "document_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the document to retrieve.",
              "title": "Document Id"
            },
            "description": "The ID of the document to retrieve."
          },
          {
            "name": "return_url",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": false,
              "title": "Return Url"
            }
          },
          {
            "name": "return_vectors",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": false,
              "title": "Return Vectors"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Update Document",
        "description": "Update a document by ID.",
        "operationId": "update_document_v1_collections__collection_identifier__documents__document_id__put",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection."
          },
          {
            "name": "document_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the document to update.",
              "title": "Document Id"
            },
            "description": "The ID of the document to update."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Patch Document",
        "description": "Partially update a document by ID (PATCH operation).",
        "operationId": "patch_document_v1_collections__collection_identifier__documents__document_id__patch",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection."
          },
          {
            "name": "document_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the document to patch.",
              "title": "Document Id"
            },
            "description": "The ID of the document to patch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchDocumentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Delete a document by ID.",
        "description": "Delete a document by ID.",
        "operationId": "delete_document_v1_collections__collection_identifier__documents__document_id__delete",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection."
          },
          {
            "name": "document_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the document to delete.",
              "title": "Document Id"
            },
            "description": "The ID of the document to delete."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/documents/list": {
      "post": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "List documents.",
        "description": "List documents.",
        "operationId": "list_documents_v1_collections__collection_identifier__documents_list_post",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection to list documents from.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection to list documents from."
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Offset"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListDocumentsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDocumentsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/documents/bulk": {
      "patch": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Bulk Update Documents",
        "description": "Bulk update documents matching filter conditions.\n\nPartially updates all documents in the collection that match the provided filters.\nIf no filters are provided, updates all documents in the collection.\n\nThis endpoint applies the SAME update_data to ALL documents matching the filters.\nFor per-document updates with different values, use POST /batch endpoint instead.",
        "operationId": "bulk_update_documents_v1_collections__collection_identifier__documents_bulk_patch",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection to update documents in.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection to update documents in."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BulkUpdateDocumentsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BulkUpdateDocumentsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/documents/batch": {
      "post": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Batch Update Documents",
        "description": "Batch update multiple documents by explicit IDs or filters.\n\nSupports TWO modes:\n1. Explicit IDs mode: Provide 'updates' array with document_id + update_data for each document\n   - Each document can have DIFFERENT update_data\n   - Returns detailed per-document results\n   \n2. Filter mode: Provide 'filters' + 'update_data' to update all matching documents\n   - All documents receive the SAME update_data\n   - Returns total count only\n\nKey Features:\n- Update any document field except vectors (metadata, internal_metadata, source_blobs, etc.)\n- Maximum 1000 documents per batch in explicit mode\n- Per-document success/failure reporting in explicit mode\n- Validates documents exist in the specified collection\n\nExamples:\n    Explicit IDs mode:\n    ```json\n    {\n        \"updates\": [\n            {\"document_id\": \"doc_123\", \"update_data\": {\"metadata\": {\"status\": \"processed\"}}},\n            {\"document_id\": \"doc_456\", \"update_data\": {\"metadata\": {\"status\": \"archived\"}}}\n        ]\n    }\n    ```\n    \n    Filter mode:\n    ```json\n    {\n        \"filters\": {\"must\": [{\"key\": \"metadata.status\", \"value\": \"pending\"}]},\n        \"update_data\": {\"metadata\": {\"status\": \"processed\"}}\n    }\n    ```",
        "operationId": "batch_update_documents_v1_collections__collection_identifier__documents_batch_post",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection to update documents in.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection to update documents in."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchUpdateDocumentsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchUpdateDocumentsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Batch Delete Documents",
        "description": "Batch delete multiple documents by explicit IDs or filters.\n\nSupports TWO modes:\n1. Explicit IDs mode: Provide 'document_ids' array\n   - Deletes specific documents by ID\n   - Returns detailed per-document results\n   - Maximum 1000 documents per batch\n   \n2. Filter mode: Provide 'filters' to delete all matching documents\n   - Deletes ALL documents matching the filters\n   - Returns total count only\n   - Use with caution - can delete many documents\n\nKey Features:\n- Per-document success/failure reporting in explicit mode\n- Validates documents exist in the specified collection\n- Automatic document count update for the collection\n- Efficient bulk deletion\n\nExamples:\n    Explicit IDs mode:\n    ```json\n    {\n        \"document_ids\": [\"doc_123\", \"doc_456\", \"doc_789\"]\n    }\n    ```\n    \n    Filter mode:\n    ```json\n    {\n        \"filters\": {\"must\": [{\"key\": \"metadata.status\", \"value\": \"archived\"}]}\n    }\n    ```",
        "operationId": "batch_delete_documents_v1_collections__collection_identifier__documents_batch_delete",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection to delete documents from.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection to delete documents from."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchDeleteDocumentsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchDeleteDocumentsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/documents": {
      "post": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Create a document.",
        "description": "Create a document by ID.",
        "operationId": "create_document_v1_collections__collection_identifier__documents_post",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/documents/{collection_id}/aggregate": {
      "post": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Aggregate Documents",
        "description": "This endpoint performs aggregation operations on documents in a collection.\n\n    **Aggregation Framework**: Provides MongoDB-style aggregation operations:\n    - GROUP BY: Group documents by one or more fields\n    - Aggregations: COUNT, SUM, AVG, MIN, MAX, COUNT_DISTINCT, etc.\n    - Date Operations: Truncate or extract date parts for time-series analysis\n    - Filtering: Pre-aggregation filters (WHERE) and post-aggregation filters (HAVING)\n    - Sorting & Limiting: Control result ordering and size\n\n    **Use Cases**:\n    - Count documents by feature type or collection\n    - Calculate daily/monthly processing statistics\n    - Analyze feature distributions and confidence scores\n    - Generate reports with multiple metrics\n\n    **Note**: This endpoint works with both MongoDB and Qdrant using the same interface.\n    The system automatically selects the appropriate aggregation provider based on\n    the underlying metadata store.",
        "operationId": "aggregate_documents_v1_collections__collection_identifier__documents__collection_id__aggregate_post",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the collection.",
              "title": "Collection Id"
            },
            "description": "The unique identifier of the collection."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentAggregationRequest",
                "description": "Aggregation configuration specifying grouping, metrics, and filters."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentAggregationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_id}/documents/{document_id}/lineage": {
      "get": {
        "tags": [
          "Document Lineage"
        ],
        "summary": "Get document lineage",
        "description": "Get the complete processing lineage for a document. Shows the full chain of transformations from the root bucket object through all collection processing stages.",
        "operationId": "get_document_lineage_v1_collections__collection_id__documents__document_id__lineage_get",
        "parameters": [
          {
            "name": "collection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ID of the collection containing the document",
              "title": "Collection Id"
            },
            "description": "ID of the collection containing the document"
          },
          {
            "name": "document_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "ID of the document to trace",
              "title": "Document Id"
            },
            "description": "ID of the document to trace"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Document lineage information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Document Lineage V1 Collections  Collection Id  Documents  Document Id  Lineage Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/objects/{object_id}/documents": {
      "get": {
        "tags": [
          "Document Lineage"
        ],
        "summary": "Get all documents derived from an object",
        "description": "Get all documents created from a specific root object. Useful for finding all processing outputs across multiple collections.",
        "operationId": "get_documents_by_object_v1_objects__object_id__documents_get",
        "parameters": [
          {
            "name": "object_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Root object ID to find all derived documents",
              "title": "Object Id"
            },
            "description": "Root object ID to find all derived documents"
          },
          {
            "name": "collection_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional: Filter to specific collections",
              "title": "Collection Ids"
            },
            "description": "Optional: Filter to specific collections"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Documents By Object V1 Objects  Object Id  Documents Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/objects/{object_id}/decomposition-tree": {
      "get": {
        "tags": [
          "Document Lineage"
        ],
        "summary": "Get decomposition tree visualization",
        "description": "Get a hierarchical tree structure showing all collections and documents derived from a root object. Shows the complete multi-stage processing pipeline.",
        "operationId": "get_decomposition_tree_v1_objects__object_id__decomposition_tree_get",
        "parameters": [
          {
            "name": "object_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Root object ID to build decomposition tree for",
              "title": "Object Id"
            },
            "description": "Root object ID to build decomposition tree for"
          },
          {
            "name": "include_document_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include full list of document IDs (can be large)",
              "default": false,
              "title": "Include Document Ids"
            },
            "description": "Include full list of document IDs (can be large)"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Decomposition Tree V1 Objects  Object Id  Decomposition Tree Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/stages": {
      "get": {
        "tags": [
          "Retriever Stages"
        ],
        "summary": "List available retriever stages",
        "description": "List available retriever stages.",
        "operationId": "list_stages_v1_retrievers_stages_get",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RetrieverStageDefinition"
                  },
                  "title": "Response List Stages V1 Retrievers Stages Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers": {
      "post": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Create Retriever",
        "description": "Create a new retriever.\n\nA retriever executes a series of stages to find and process documents\nfrom one or more collections.",
        "operationId": "create_retriever_v1_retrievers_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateRetrieverRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateRetrieverResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Retrievers"
        ],
        "summary": "List Retrievers",
        "description": "List all retrievers in the namespace.",
        "operationId": "list_retrievers_v1_retrievers_get",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListRetrieversResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/{retriever_id}": {
      "get": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Get Retriever",
        "description": "Get a retriever by ID or name.",
        "operationId": "get_retriever_v1_retrievers__retriever_id__get",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Retriever ID or name.",
              "title": "Retriever Id"
            },
            "description": "Retriever ID or name."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RetrieverModel-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Patch Retriever",
        "description": "Update a retriever's metadata.\n\nOnly metadata fields can be updated:\n- name: Rename the retriever\n- description: Update the description\n- tags: Update tags for organization\n\nCore logic (input_schema, stages, collection_ids) is immutable.\nCreate a new retriever for structural changes.",
        "operationId": "patch_retriever_v1_retrievers__retriever_id__patch",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Retriever ID or name.",
              "title": "Retriever Id"
            },
            "description": "Retriever ID or name."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchRetrieverRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PatchRetrieverResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Delete Retriever",
        "description": "Delete a retriever by ID or name.",
        "operationId": "delete_retriever_v1_retrievers__retriever_id__delete",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Retriever ID or name.",
              "title": "Retriever Id"
            },
            "description": "Retriever ID or name."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/{retriever_id}/execute": {
      "post": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Execute Retriever",
        "description": "Execute a retriever and return matching documents.",
        "operationId": "execute_retriever_v1_retrievers__retriever_id__execute_post",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Retriever ID or name.",
              "title": "Retriever Id"
            },
            "description": "Retriever ID or name."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteRetrieverRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteRetrieverResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/{retriever_id}/executions": {
      "get": {
        "tags": [
          "Retrievers"
        ],
        "summary": "List Executions",
        "description": "List execution history for a retriever.",
        "operationId": "list_executions_v1_retrievers__retriever_id__executions_get",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Retriever ID or name.",
              "title": "Retriever Id"
            },
            "description": "Retriever ID or name."
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Number of executions to return.",
              "default": 20,
              "title": "Limit"
            },
            "description": "Number of executions to return."
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of executions to skip.",
              "default": 0,
              "title": "Offset"
            },
            "description": "Number of executions to skip."
          },
          {
            "name": "status",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional status filter (completed, failed, running).",
              "title": "Status"
            },
            "description": "Optional status filter (completed, failed, running)."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListExecutionsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/{retriever_id}/executions/{execution_id}": {
      "get": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Get Execution",
        "description": "Get execution details and statistics.",
        "operationId": "get_execution_v1_retrievers__retriever_id__executions__execution_id__get",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Retriever ID or name.",
              "title": "Retriever Id"
            },
            "description": "Retriever ID or name."
          },
          {
            "name": "execution_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Execution identifier.",
              "title": "Execution Id"
            },
            "description": "Execution identifier."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecutionDetail"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/{retriever_id}/explain": {
      "post": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Explain Retriever",
        "description": "Get estimated execution plan for a retriever.",
        "operationId": "explain_retriever_v1_retrievers__retriever_id__explain_post",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Retriever ID or name.",
              "title": "Retriever Id"
            },
            "description": "Retriever ID or name."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExplainRetrieverRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExplainRetrieverResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/interactions": {
      "post": {
        "tags": [
          "Retriever Interactions"
        ],
        "summary": "Create Interaction",
        "description": "Record a search interaction (view, click, feedback, etc.).",
        "operationId": "create_interaction_v1_retrievers_interactions_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchInteraction"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InteractionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Retriever Interactions"
        ],
        "summary": "List Interactions",
        "description": "List interactions with optional filters and pagination.",
        "operationId": "list_interactions_v1_retrievers_interactions_get",
        "parameters": [
          {
            "name": "feature_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Feature Id"
            }
          },
          {
            "name": "interaction_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Interaction Type"
            }
          },
          {
            "name": "session_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Session Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListInteractionsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/interactions/{interaction_id}": {
      "get": {
        "tags": [
          "Retriever Interactions"
        ],
        "summary": "Get Interaction",
        "description": "Get a specific interaction.",
        "operationId": "get_interaction_v1_retrievers_interactions__interaction_id__get",
        "parameters": [
          {
            "name": "interaction_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Interaction Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InteractionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Retriever Interactions"
        ],
        "summary": "Delete Interaction",
        "description": "Delete a specific interaction.",
        "operationId": "delete_interaction_v1_retrievers_interactions__interaction_id__delete",
        "parameters": [
          {
            "name": "interaction_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Interaction Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Delete Interaction V1 Retrievers Interactions  Interaction Id  Delete"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/{retriever_id}/evaluations/": {
      "post": {
        "tags": [
          "Retriever Evaluations"
        ],
        "summary": "Start Retriever Evaluation Task",
        "description": "Starts an asynchronous evaluation of a retriever against a ground truth dataset.",
        "operationId": "run_evaluation_v1_retrievers__retriever_id__evaluations__post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EvaluationRequest"
              }
            }
          }
        },
        "responses": {
          "202": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations": {
      "get": {
        "tags": [
          "Organizations"
        ],
        "summary": "Get Organization",
        "description": "Get current organization details.",
        "operationId": "get_organization_v1_organizations_get",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Organizations"
        ],
        "summary": "Update Organization",
        "description": "Update organization settings (requires ADMIN permission).",
        "operationId": "update_organization_v1_organizations_patch",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OrganizationUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/credits": {
      "post": {
        "tags": [
          "Organizations"
        ],
        "summary": "Add Credits",
        "description": "Add credits to the organization.\n\nWhen credits are added to a FREE-tier organization:\n- If new balance >= 100,000: Auto-upgrade to PRO tier\n- If new balance >= 1,000,000: Auto-upgrade to TEAM tier\n\nPRO and TEAM tiers get enhanced rate limits automatically.",
        "operationId": "add_credits_v1_organizations_credits_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddCreditsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddCreditsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/connections": {
      "post": {
        "tags": [
          "Organization Connections"
        ],
        "summary": "Create Storage Connection",
        "description": "Create a new storage provider connection.",
        "operationId": "create_storage_connection_v1_organizations_connections_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StorageConnectionCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageConnectionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Organization Connections"
        ],
        "summary": "List Storage Connections",
        "description": "List storage connections for the authenticated organization.",
        "operationId": "list_storage_connections_v1_organizations_connections_get",
        "parameters": [
          {
            "name": "provider_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/StorageProvider"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Provider Type"
            }
          },
          {
            "name": "status",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/TaskStatusEnum"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Status"
            }
          },
          {
            "name": "is_active",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Is Active"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageConnectionListResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/connections/{connection_id}": {
      "get": {
        "tags": [
          "Organization Connections"
        ],
        "summary": "Get Storage Connection",
        "description": "Retrieve a storage connection.",
        "operationId": "get_storage_connection_v1_organizations_connections__connection_id__get",
        "parameters": [
          {
            "name": "connection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Connection Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageConnectionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Organization Connections"
        ],
        "summary": "Update Storage Connection",
        "description": "Update connection metadata or credentials.",
        "operationId": "update_storage_connection_v1_organizations_connections__connection_id__patch",
        "parameters": [
          {
            "name": "connection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Connection Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StorageConnectionUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageConnectionModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Organization Connections"
        ],
        "summary": "Delete Storage Connection",
        "description": "Soft-delete a connection (mark archived).",
        "operationId": "delete_storage_connection_v1_organizations_connections__connection_id__delete",
        "parameters": [
          {
            "name": "connection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Connection Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Delete Storage Connection V1 Organizations Connections  Connection Id  Delete"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/connections/{connection_id}/test": {
      "post": {
        "tags": [
          "Organization Connections"
        ],
        "summary": "Test Storage Connection",
        "description": "Perform a credential test against the external provider.",
        "operationId": "test_storage_connection_v1_organizations_connections__connection_id__test_post",
        "parameters": [
          {
            "name": "connection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Connection Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StorageConnectionTestResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/connections/{connection_id}/folders": {
      "get": {
        "tags": [
          "Organization Connections"
        ],
        "summary": "List Google Drive Folders",
        "description": "List folders in Google Drive for folder selection in sync configuration.\n\nArgs:\n    connection_id: The storage connection ID (must be Google Drive)\n    path: Parent folder path (default: \"/\" for root)\n\nReturns:\n    List of folders with their IDs and paths\n\nRaises:\n    HTTPException: If connection not found or not a Google Drive connection",
        "operationId": "list_google_drive_folders_v1_organizations_connections__connection_id__folders_get",
        "parameters": [
          {
            "name": "connection_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Connection Id"
            }
          },
          {
            "name": "path",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Parent folder path to list from",
              "default": "/",
              "title": "Path"
            },
            "description": "Parent folder path to list from"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListFoldersResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/users": {
      "post": {
        "tags": [
          "Organization Users"
        ],
        "summary": "Create User",
        "description": "Create a new organization user.",
        "operationId": "create_user_v1_organizations_users_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Organization Users"
        ],
        "summary": "List Users",
        "description": "List organization users with pagination and optional filters.",
        "operationId": "list_users_v1_organizations_users_get",
        "parameters": [
          {
            "name": "skip",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "default": 0,
              "title": "Skip"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "default": 50,
              "title": "Limit"
            }
          },
          {
            "name": "role",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/UserRole"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Role"
            }
          },
          {
            "name": "status",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/UserStatus"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Status"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response List Users V1 Organizations Users Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/users/{user_email}": {
      "get": {
        "tags": [
          "Organization Users"
        ],
        "summary": "Get User",
        "description": "Return a user by email address.",
        "operationId": "get_user_v1_organizations_users__user_email__get",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Organization Users"
        ],
        "summary": "Update User",
        "description": "Apply partial updates to an existing user.",
        "operationId": "update_user_v1_organizations_users__user_email__patch",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Organization Users"
        ],
        "summary": "Delete User",
        "description": "Delete a user and revoke their API keys.",
        "operationId": "delete_user_v1_organizations_users__user_email__delete",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/users/{user_email}/api-keys": {
      "post": {
        "tags": [
          "Organization API Keys"
        ],
        "summary": "Create Api Key",
        "description": "Create a new API key for a user.",
        "operationId": "create_api_key_v1_organizations_users__user_email__api_keys_post",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/APIKeyCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/APIKeyCreateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Organization API Keys"
        ],
        "summary": "List Api Keys",
        "description": "List API keys for a user.",
        "operationId": "list_api_keys_v1_organizations_users__user_email__api_keys_get",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "include_revoked",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Revoked"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response List Api Keys V1 Organizations Users  User Email  Api Keys Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/users/{user_email}/api-keys/{key_name}": {
      "patch": {
        "tags": [
          "Organization API Keys"
        ],
        "summary": "Update Api Key",
        "description": "Update an API key's metadata or permissions.\n\n\ud83d\udd12 The \"admin-key\" is protected and cannot be modified.",
        "operationId": "update_api_key_v1_organizations_users__user_email__api_keys__key_name__patch",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "key_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Key Name"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/APIKeyUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/APIKeyModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Organization API Keys"
        ],
        "summary": "Delete Api Key",
        "description": "Revoke an API key.\n\n\ud83d\udd12 The \"admin-key\" is protected and cannot be deleted.",
        "operationId": "delete_api_key_v1_organizations_users__user_email__api_keys__key_name__delete",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "key_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Key Name"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/users/{user_email}/api-keys/{key_name}/rotate": {
      "post": {
        "tags": [
          "Organization API Keys"
        ],
        "summary": "Rotate Api Key",
        "description": "Rotate an API key and return the new secret.\n\n\ud83d\udd12 The \"admin-key\" is protected and cannot be rotated.",
        "operationId": "rotate_api_key_v1_organizations_users__user_email__api_keys__key_name__rotate_post",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "key_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Key Name"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/APIKeyCreateResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/usage": {
      "get": {
        "tags": [
          "Organization Usage"
        ],
        "summary": "Get Org Usage",
        "description": "Return aggregated usage for the organization.",
        "operationId": "get_org_usage_v1_organizations_usage_get",
        "parameters": [
          {
            "name": "start",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "ISO8601 start timestamp",
              "title": "Start"
            },
            "description": "ISO8601 start timestamp"
          },
          {
            "name": "end",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "ISO8601 end timestamp",
              "title": "End"
            },
            "description": "ISO8601 end timestamp"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Org Usage V1 Organizations Usage Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/api-keys/{key_id}/usage": {
      "get": {
        "tags": [
          "Organization Usage"
        ],
        "summary": "Get Api Key Usage",
        "description": "Return usage metrics for a specific API key.",
        "operationId": "get_api_key_usage_v1_organizations_api_keys__key_id__usage_get",
        "parameters": [
          {
            "name": "key_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Key Id"
            }
          },
          {
            "name": "start",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "ISO8601 start timestamp",
              "title": "Start"
            },
            "description": "ISO8601 start timestamp"
          },
          {
            "name": "end",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "ISO8601 end timestamp",
              "title": "End"
            },
            "description": "ISO8601 end timestamp"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Api Key Usage V1 Organizations Api Keys  Key Id  Usage Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/api-keys/{key_id}/usage/endpoints": {
      "get": {
        "tags": [
          "Organization Usage"
        ],
        "summary": "Get Api Key Endpoint Breakdown",
        "description": "Return endpoint-level usage metrics for a specific API key.",
        "operationId": "get_api_key_endpoint_breakdown_v1_organizations_api_keys__key_id__usage_endpoints_get",
        "parameters": [
          {
            "name": "key_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Key Id"
            }
          },
          {
            "name": "start",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "ISO8601 start timestamp",
              "title": "Start"
            },
            "description": "ISO8601 start timestamp"
          },
          {
            "name": "end",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "ISO8601 end timestamp",
              "title": "End"
            },
            "description": "ISO8601 end timestamp"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": true
                  },
                  "title": "Response Get Api Key Endpoint Breakdown V1 Organizations Api Keys  Key Id  Usage Endpoints Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/namespaces": {
      "post": {
        "tags": [
          "Namespaces"
        ],
        "summary": "Create Namespace",
        "description": "Creates a new namespace with specified feature extractors and payload indexes.",
        "operationId": "create_namespace_v1_namespaces_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateNamespaceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NamespaceModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/namespaces/{namespace_identifier}": {
      "delete": {
        "tags": [
          "Namespaces"
        ],
        "summary": "Delete Namespace",
        "description": "Deletes an existing namespace using either its name or ID",
        "operationId": "delete_namespace_v1_namespaces__namespace_identifier__delete",
        "parameters": [
          {
            "name": "namespace_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Either the namespace name or namespace ID",
              "examples": [
                "my_namespace",
                "ns_1234567890"
              ],
              "title": "Namespace Identifier"
            },
            "description": "Either the namespace name or namespace ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Namespaces"
        ],
        "summary": "Update Namespace",
        "description": "Fully updates an existing namespace (all fields required)",
        "operationId": "update_namespace_v1_namespaces__namespace_identifier__put",
        "parameters": [
          {
            "name": "namespace_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Either the namespace name or namespace ID",
              "examples": [
                "my_namespace",
                "ns_1234567890"
              ],
              "title": "Namespace Identifier"
            },
            "description": "Either the namespace name or namespace ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateNamespaceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NamespaceModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Namespaces"
        ],
        "summary": "Partially Update Namespace",
        "description": "Partially updates an existing namespace (PATCH operation)",
        "operationId": "patch_namespace_v1_namespaces__namespace_identifier__patch",
        "parameters": [
          {
            "name": "namespace_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Either the namespace name or namespace ID",
              "examples": [
                "my_namespace",
                "ns_1234567890"
              ],
              "title": "Namespace Identifier"
            },
            "description": "Either the namespace name or namespace ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchNamespaceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NamespaceModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Namespaces"
        ],
        "summary": "Get Namespace",
        "description": "Retrieve details of a specific namespace using either its name or ID",
        "operationId": "get_namespace_v1_namespaces__namespace_identifier__get",
        "parameters": [
          {
            "name": "namespace_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Either the namespace name or namespace ID",
              "examples": [
                "my_namespace",
                "ns_1234567890"
              ],
              "title": "Namespace Identifier"
            },
            "description": "Either the namespace name or namespace ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NamespaceModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/namespaces/list": {
      "post": {
        "tags": [
          "Namespaces"
        ],
        "summary": "List Namespaces",
        "description": "List all namespaces for a user",
        "operationId": "list_namespaces_v1_namespaces_list_post",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Offset"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListNamespacesRequest",
                "default": {
                  "case_sensitive": false
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListNamespacesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets": {
      "post": {
        "tags": [
          "Buckets"
        ],
        "summary": "Create Bucket",
        "description": "This endpoint allows you to create a new bucket with a defined schema.\n    A bucket is a collection of objects that conform to the schema.\n    The schema defines the structure and validation rules for objects in the bucket.",
        "operationId": "create_bucket_v1_buckets_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BucketCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BucketResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}": {
      "get": {
        "tags": [
          "Buckets"
        ],
        "summary": "Get Bucket",
        "description": "This endpoint retrieves a bucket by its ID.",
        "operationId": "get_bucket_v1_buckets__bucket_identifier__get",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BucketResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Buckets"
        ],
        "summary": "Update Bucket",
        "description": "This endpoint allows you to update an existing bucket.\n    You can update the bucket's name, description, and metadata.",
        "operationId": "update_bucket_v1_buckets__bucket_identifier__put",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BucketUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BucketResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Buckets"
        ],
        "summary": "Partially Update Bucket",
        "description": "This endpoint allows you to partially update an existing bucket (PATCH operation).\n    Only provided fields will be updated. At minimum, metadata can always be updated.\n    Immutable fields like bucket_id and timestamps cannot be modified.",
        "operationId": "patch_bucket_v1_buckets__bucket_identifier__patch",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BucketPatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BucketResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Buckets"
        ],
        "summary": "Delete Bucket",
        "description": "This endpoint deletes a bucket and all its objects.",
        "operationId": "delete_bucket_v1_buckets__bucket_identifier__delete",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/list": {
      "post": {
        "tags": [
          "Buckets"
        ],
        "summary": "List Buckets",
        "description": "This endpoint lists buckets with pagination, sorting, and filtering options.",
        "operationId": "list_buckets_v1_buckets_list_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBucketsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBucketsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_id}/syncs": {
      "post": {
        "tags": [
          "Bucket Syncs"
        ],
        "summary": "Create Sync Configuration",
        "description": "Create a sync configuration for a bucket.",
        "operationId": "create_sync_configuration_v1_buckets__bucket_id__syncs_post",
        "parameters": [
          {
            "name": "bucket_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyncCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyncConfigurationModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Bucket Syncs"
        ],
        "summary": "List Sync Configurations",
        "description": "List all sync configurations for a bucket.",
        "operationId": "list_sync_configurations_v1_buckets__bucket_id__syncs_get",
        "parameters": [
          {
            "name": "bucket_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyncListResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_id}/syncs/{sync_config_id}": {
      "get": {
        "tags": [
          "Bucket Syncs"
        ],
        "summary": "Get Sync Configuration",
        "description": "Fetch a sync configuration.",
        "operationId": "get_sync_configuration_v1_buckets__bucket_id__syncs__sync_config_id__get",
        "parameters": [
          {
            "name": "bucket_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Id"
            }
          },
          {
            "name": "sync_config_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Sync Config Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyncConfigurationModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Bucket Syncs"
        ],
        "summary": "Update Sync Configuration",
        "description": "Update a sync configuration.",
        "operationId": "update_sync_configuration_v1_buckets__bucket_id__syncs__sync_config_id__patch",
        "parameters": [
          {
            "name": "bucket_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Id"
            }
          },
          {
            "name": "sync_config_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Sync Config Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyncUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyncConfigurationModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Bucket Syncs"
        ],
        "summary": "Delete Sync Configuration",
        "operationId": "delete_sync_configuration_v1_buckets__bucket_id__syncs__sync_config_id__delete",
        "parameters": [
          {
            "name": "bucket_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Id"
            }
          },
          {
            "name": "sync_config_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Sync Config Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_id}/syncs/{sync_config_id}/pause": {
      "post": {
        "tags": [
          "Bucket Syncs"
        ],
        "summary": "Pause Sync Configuration",
        "operationId": "pause_sync_configuration_v1_buckets__bucket_id__syncs__sync_config_id__pause_post",
        "parameters": [
          {
            "name": "bucket_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Id"
            }
          },
          {
            "name": "sync_config_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Sync Config Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyncConfigurationModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_id}/syncs/{sync_config_id}/resume": {
      "post": {
        "tags": [
          "Bucket Syncs"
        ],
        "summary": "Resume Sync Configuration",
        "operationId": "resume_sync_configuration_v1_buckets__bucket_id__syncs__sync_config_id__resume_post",
        "parameters": [
          {
            "name": "bucket_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Id"
            }
          },
          {
            "name": "sync_config_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Sync Config Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyncConfigurationModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/objects": {
      "post": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Create Object",
        "description": "This endpoint creates a new object in the specified bucket.\n    The object must conform to the bucket's schema. It does not trigger processing.",
        "operationId": "create_object_v1_buckets__bucket_identifier__objects_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateObjectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/objects/batch": {
      "post": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Create Objects in Batch",
        "description": "This endpoint creates multiple new objects in the specified bucket as a batch.\n    Each object must conform to the bucket's schema. It does not trigger processing.",
        "operationId": "create_objects_batch_v1_buckets__bucket_identifier__objects_batch_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateObjectsBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ObjectResponse"
                  },
                  "title": "Response Create Objects Batch V1 Buckets  Bucket Identifier  Objects Batch Post"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/objects/{object_identifier}": {
      "get": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Get Object",
        "description": "This endpoint retrieves an object by its ID from the specified bucket.",
        "operationId": "get_object_v1_buckets__bucket_identifier__objects__object_identifier__get",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "object_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the object.",
              "title": "Object Identifier"
            },
            "description": "The unique identifier of the object."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Update Object",
        "description": "This endpoint updates an existing object in the specified bucket.\n    The updated object must conform to the bucket's schema. It does not trigger processing.",
        "operationId": "update_object_v1_buckets__bucket_identifier__objects__object_identifier__put",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "object_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the object.",
              "title": "Object Identifier"
            },
            "description": "The unique identifier of the object."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateObjectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Partially Update Object",
        "description": "This endpoint partially updates an existing object in the specified bucket (PATCH operation).\n    Only provided fields will be updated. At minimum, metadata can always be updated.\n    Immutable fields like object_id and timestamps cannot be modified.\n    It does not trigger processing.",
        "operationId": "patch_object_v1_buckets__bucket_identifier__objects__object_identifier__patch",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "object_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the object.",
              "title": "Object Identifier"
            },
            "description": "The unique identifier of the object."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchObjectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Delete Object",
        "description": "This endpoint deletes an object from the specified bucket.",
        "operationId": "delete_object_v1_buckets__bucket_identifier__objects__object_identifier__delete",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "object_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the object.",
              "title": "Object Identifier"
            },
            "description": "The unique identifier of the object."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/objects/list": {
      "post": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "List Objects",
        "description": "This endpoint lists objects in a bucket with pagination, filtering, and sorting.\n\n    **Filtering**: Use dot notation for metadata fields\n    - Example: ?metadata.type=video&metadata.status=ready\n\n    **Sorting**: Specify field and direction\n    - Example: ?sort_field=metadata.created_at&sort_direction=desc\n    - Direction: asc (ascending) or desc (descending), defaults to asc\n\n    **Pagination**: Use limit and offset\n    - Example: ?limit=20&offset=40",
        "operationId": "list_objects_v1_buckets__bucket_identifier__objects_list_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Offset"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListObjectsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/objects/aggregate": {
      "post": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Aggregate Objects",
        "description": "This endpoint performs aggregation operations on objects in a bucket.\n\n    **Aggregation Framework**: Provides MongoDB-style aggregation operations:\n    - GROUP BY: Group objects by one or more fields\n    - Aggregations: COUNT, SUM, AVG, MIN, MAX, COUNT_DISTINCT, etc.\n    - Date Operations: Truncate or extract date parts for time-series analysis\n    - Filtering: Pre-aggregation filters (WHERE) and post-aggregation filters (HAVING)\n    - Sorting & Limiting: Control result ordering and size\n\n    **Use Cases**:\n    - Count objects by status or category\n    - Calculate daily/monthly upload statistics\n    - Analyze content distribution and trends\n    - Generate reports with multiple metrics\n\n    **Note**: This endpoint works with both MongoDB objects and Qdrant documents\n    using the same interface. The system automatically selects the appropriate\n    aggregation provider.",
        "operationId": "aggregate_objects_v1_buckets__bucket_identifier__objects_aggregate_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ObjectAggregationRequest",
                "description": "Aggregation configuration specifying grouping, metrics, and filters."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectAggregationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Create Batch",
        "description": "Create a new batch for grouping bucket objects.",
        "operationId": "create_batch_v1_buckets__bucket_identifier__batches_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/{batch_id}/objects": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Add Objects to Batch",
        "description": "Add objects to an existing batch. The batch must be in 'draft' status.",
        "operationId": "add_objects_to_batch_v1_buckets__bucket_identifier__batches__batch_id__objects_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddObjectsToBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/{batch_id}/submit": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Submit Batch for Processing",
        "description": "Submit a batch for asynchronous processing. The batch must be in 'pending' status and contain objects.",
        "operationId": "submit_batch_v1_buckets__bucket_identifier__batches__batch_id__submit_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubmitBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/list": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "List Batches",
        "description": "List batches with pagination and filtering options.",
        "operationId": "list_batches_v1_buckets__bucket_identifier__batches_list_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBatchesRequest",
                "default": {
                  "offset": 0,
                  "limit": 100
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBatchesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/{batch_id}": {
      "get": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Get Batch",
        "description": "Retrieve a batch by its ID.",
        "operationId": "get_batch_v1_buckets__bucket_identifier__batches__batch_id__get",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Delete Batch",
        "description": "Delete a batch by its ID.",
        "operationId": "delete_batch_v1_buckets__bucket_identifier__batches__batch_id__delete",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Partially Update Batch",
        "description": "This endpoint partially updates a batch (PATCH operation).\n    Only provided fields will be updated. At minimum, metadata can always be updated.\n    Immutable fields like batch_id and timestamps cannot be modified.",
        "operationId": "patch_batch_v1_buckets__bucket_identifier__batches__batch_id__patch",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/{batch_id}/cancel": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Cancel Batch",
        "description": "Cancel a submitted/processing batch: cancels Ray job via engine and marks task/batch as CANCELLED.",
        "operationId": "cancel_batch_v1_buckets__bucket_identifier__batches__batch_id__cancel_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/uploads": {
      "post": {
        "tags": [
          "Bucket Uploads"
        ],
        "summary": "Create Upload",
        "description": "Generate a presigned URL for direct S3 upload.\n\n    This endpoint validates all requirements BEFORE generating the presigned URL,\n    ensuring immediate feedback if something is wrong (bucket inactive, quota exceeded, etc.).\n\n    **Duplicate Detection (Enabled by Default)**:\n    - If `file_hash` provided and `skip_duplicates=true`: Checks for existing upload\n    - If duplicate found: Returns existing upload (200 OK) with `is_duplicate=true`\n    - If new file: Returns presigned URL (201 Created) with `is_duplicate=false`\n\n    **Two-Step Flow**:\n    1. Call this endpoint \u2192 Get presigned URL\n    2. PUT file to presigned URL \u2192 Upload directly to S3\n    3. Call confirm endpoint \u2192 Verify upload and create object",
        "operationId": "create_upload_v1_buckets__bucket_identifier__uploads_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateUploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/uploads/{upload_id}": {
      "get": {
        "tags": [
          "Bucket Uploads"
        ],
        "summary": "Get Upload",
        "description": "Retrieve an upload by its ID.\n\n    Use this to check upload status, get S3 key, or retrieve created object_id after confirmation.",
        "operationId": "get_upload_v1_buckets__bucket_identifier__uploads__upload_id__get",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket"
          },
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the upload",
              "title": "Upload Id"
            },
            "description": "The unique identifier of the upload"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Bucket Uploads"
        ],
        "summary": "Delete Upload",
        "description": "Cancel an upload and optionally delete the S3 object.\n\n    Cannot cancel uploads with status COMPLETED.\n    Can cancel uploads with status: PENDING, IN_PROGRESS, FAILED.",
        "operationId": "delete_upload_v1_buckets__bucket_identifier__uploads__upload_id__delete",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket"
          },
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the upload",
              "title": "Upload Id"
            },
            "description": "The unique identifier of the upload"
          },
          {
            "name": "delete_s3_object",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Whether to delete the S3 object",
              "default": true,
              "title": "Delete S3 Object"
            },
            "description": "Whether to delete the S3 object"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/uploads/list": {
      "post": {
        "tags": [
          "Bucket Uploads"
        ],
        "summary": "List Uploads",
        "description": "List uploads in a bucket with filtering, sorting, search, and pagination.\n\n    **Filtering**: Use LogicalOperator with shorthand syntax\n    - Simple: `{\"status\": \"PENDING\", \"metadata.campaign\": \"summer_2024\"}`\n    - Complex: `{\"AND\": [{\"field\": \"file_size_bytes\", \"operator\": \"gte\", \"value\": 1000000}]}`\n\n    **Sorting**: Specify field and direction\n    - Example: `{\"field\": \"created_at\", \"direction\": \"desc\"}`\n\n    **Search**: Full-text search across filename and metadata\n    - Example: `\"search\": \"video\"`\n\n    **Pagination**: Use limit and offset\n    - Example: `\"limit\": 50, \"offset\": 100`",
        "operationId": "list_uploads_v1_buckets__bucket_identifier__uploads_list_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Offset"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListUploadsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListUploadsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/uploads/{upload_id}/confirm": {
      "post": {
        "tags": [
          "Bucket Uploads"
        ],
        "summary": "Confirm Upload",
        "description": "Verify S3 upload completion and optionally create bucket object.\n\n    After uploading to S3 using the presigned URL, call this endpoint to:\n    1. Verify the file exists in S3\n    2. Validate ETag and file size (if provided)\n    3. Create bucket object (if create_object_on_confirm was true)\n    4. Update upload status to COMPLETED\n\n    **Sync vs Async**:\n    - Files < 100MB: Processed synchronously (~100ms)\n    - Files >= 100MB or async=true: Processed asynchronously (returns task_id)\n\n    **Duplicate Detection**:\n    - If file hash matches existing upload, marks as duplicate\n    - References original object_id if available",
        "operationId": "confirm_upload_v1_buckets__bucket_identifier__uploads__upload_id__confirm_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket"
          },
          {
            "name": "upload_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the upload",
              "title": "Upload Id"
            },
            "description": "The unique identifier of the upload"
          },
          {
            "name": "async",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Process confirmation asynchronously (recommended for files >= 100MB)",
              "default": false,
              "title": "Async"
            },
            "description": "Process confirmation asynchronously (recommended for files >= 100MB)"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfirmUploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfirmUploadResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/uploads/batch": {
      "post": {
        "tags": [
          "Bucket Uploads"
        ],
        "summary": "Batch Create Uploads",
        "description": "Generate multiple presigned URLs in a single request.\n\n    All uploads belong to the same bucket (from path parameter).\n    Maximum 100 uploads per batch.\n\n    Shared metadata is merged with individual upload metadata (individual takes precedence).",
        "operationId": "create_uploads_batch_v1_buckets__bucket_identifier__uploads_batch_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchUploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchUploadResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/uploads/confirm/batch": {
      "post": {
        "tags": [
          "Bucket Uploads"
        ],
        "summary": "Batch Confirm Uploads",
        "description": "Confirm multiple uploads in a single request (processed asynchronously).\n\n    Maximum 100 confirmations per batch.\n    All uploads must belong to the same bucket.\n\n    Returns a task_id to track progress via GET /v1/tasks/{task_id}.",
        "operationId": "confirm_uploads_batch_v1_buckets__bucket_identifier__uploads_confirm_batch_post",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BatchConfirmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchConfirmResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/tasks/{task_id}": {
      "delete": {
        "tags": [
          "Tasks"
        ],
        "summary": "Kill Task",
        "description": "Kill a task.",
        "operationId": "kill_task_v1_tasks__task_id__delete",
        "parameters": [
          {
            "name": "task_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Task Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "Get Task Information",
        "description": "Retrieve a task by its ID.\n\n    A task may have an expiration time, after which it will still be returned but marked as expired.\n    This allows tracking of historical tasks while indicating their current validity state.",
        "operationId": "get_task_v1_tasks__task_id__get",
        "parameters": [
          {
            "name": "task_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Task Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            },
            "headers": {
              "X-RateLimit-Limit": {
                "$ref": "#/components/headers/X-RateLimit-Limit"
              },
              "X-RateLimit-Remaining": {
                "$ref": "#/components/headers/X-RateLimit-Remaining"
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/tasks/": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "List Active Tasks",
        "description": "Retrieve all tasks that are not in a complete state (IN_PROGRESS, FAILED, CANCELED, or UNKNOWN)",
        "operationId": "list_active_tasks_v1_tasks__get",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 1,
              "title": "Page"
            }
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 10,
              "title": "Page Size"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTasksResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/webhooks/": {
      "post": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Create Webhook",
        "description": "Create a new webhook for the user's organization.",
        "operationId": "create_webhook_v1_organizations_webhooks__post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Webhook-Input"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Webhooks"
        ],
        "summary": "List Webhooks",
        "description": "List all webhooks for the user's organization.",
        "operationId": "list_webhooks_v1_organizations_webhooks__get",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Webhook-Output"
                  },
                  "title": "Response List Webhooks V1 Organizations Webhooks  Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/webhooks/{identifier}": {
      "get": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Get Webhook",
        "description": "Get a single webhook by its ID.",
        "operationId": "get_webhook_v1_organizations_webhooks__identifier__get",
        "parameters": [
          {
            "name": "identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Update Webhook",
        "description": "Update an existing webhook.",
        "operationId": "update_webhook_v1_organizations_webhooks__identifier__put",
        "parameters": [
          {
            "name": "identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Webhook-Input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Delete Webhook",
        "description": "Delete a webhook.",
        "operationId": "delete_webhook_v1_organizations_webhooks__identifier__delete",
        "parameters": [
          {
            "name": "identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies": {
      "post": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Create Taxonomy",
        "description": "Create a taxonomy and return the created resource.",
        "operationId": "create_taxonomy_v1_taxonomies_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTaxonomyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaxonomyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies/{taxonomy_identifier}": {
      "get": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Get Taxonomy",
        "description": "Get a taxonomy by ID or name.",
        "operationId": "get_taxonomy_v1_taxonomies__taxonomy_identifier__get",
        "parameters": [
          {
            "name": "taxonomy_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID or name",
              "title": "Taxonomy Identifier"
            },
            "description": "Taxonomy ID or name"
          },
          {
            "name": "version",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional taxonomy version to fetch",
              "title": "Version"
            },
            "description": "Optional taxonomy version to fetch"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaxonomyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Delete Taxonomy",
        "description": "Delete a taxonomy by ID or name.",
        "operationId": "delete_taxonomy_v1_taxonomies__taxonomy_identifier__delete",
        "parameters": [
          {
            "name": "taxonomy_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID or name",
              "title": "Taxonomy Identifier"
            },
            "description": "Taxonomy ID or name"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Partially Update Taxonomy",
        "description": "This endpoint partially updates a taxonomy (PATCH operation).\n    Only provided fields will be updated. At minimum, metadata can always be updated.\n    Immutable fields like taxonomy_id, version, and config cannot be modified.",
        "operationId": "patch_taxonomy_v1_taxonomies__taxonomy_identifier__patch",
        "parameters": [
          {
            "name": "taxonomy_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID or name",
              "title": "Taxonomy Identifier"
            },
            "description": "Taxonomy ID or name"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchTaxonomyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaxonomyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies/{taxonomy_id}/versions": {
      "post": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Create Taxonomy Version",
        "description": "Create a new version for a taxonomy with a new config snapshot.",
        "operationId": "create_taxonomy_version_v1_taxonomies__taxonomy_id__versions_post",
        "parameters": [
          {
            "name": "taxonomy_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID (tax_...)",
              "title": "Taxonomy Id"
            },
            "description": "Taxonomy ID (tax_...)"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": true,
                "title": "Body"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaxonomyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "List Taxonomy Versions",
        "description": "List all versions for a taxonomy (head included as latest).",
        "operationId": "list_taxonomy_versions_v1_taxonomies__taxonomy_id__versions_get",
        "parameters": [
          {
            "name": "taxonomy_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID (tax_...)",
              "title": "Taxonomy Id"
            },
            "description": "Taxonomy ID (tax_...)"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTaxonomiesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies/list": {
      "post": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "List Taxonomies",
        "description": "List taxonomies with optional filters and pagination.",
        "operationId": "list_taxonomies_v1_taxonomies_list_post",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Offset"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListTaxonomiesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTaxonomiesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies/execute/{taxonomy_identifier}": {
      "post": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Test taxonomy configuration (validation only)",
        "description": "\u26a0\ufe0f VALIDATION ENDPOINT ONLY - Not for production enrichment!\n\nThis endpoint validates taxonomy configuration with 1-5 sample documents.\nResults are returned immediately and NOT persisted to any collection.\n\n\u274c DO NOT USE FOR:\n- Enriching entire collections (use taxonomy_applications instead)\n- Batch processing documents (automatic during ingestion)\n- Persisting enriched documents (use retriever pipelines instead)\n\n\u2705 USE THIS FOR:\n- Testing taxonomy configuration is correct\n- Validating retriever finds matching taxonomy nodes\n- Checking enrichment fields are properly applied\n- Development/debugging taxonomy setup\n\n\ud83d\udcda FOR PRODUCTION ENRICHMENT:\n\nAutomatic (during ingestion):\n  1. Create taxonomy: POST /taxonomies\n  2. Attach to collection: PUT /collections/{id} with taxonomy_applications field\n  3. Ingest documents: Documents are automatically enriched by engine\n\nOn-the-fly (during retrieval):\n  1. Add taxonomy_join stage to retriever pipeline\n  2. Execute retriever: GET /retrievers/{id}/execute\n  3. Results include enriched documents (not persisted)\n\nSee API documentation for Collections and Retrievers for details.",
        "operationId": "execute_taxonomy_v1_taxonomies_execute__taxonomy_identifier__post",
        "parameters": [
          {
            "name": "taxonomy_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID or name to validate",
              "title": "Taxonomy Identifier"
            },
            "description": "Taxonomy ID or name to validate",
            "example": "tax_abc123"
          },
          {
            "name": "version",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional taxonomy version (defaults to latest)",
              "title": "Version"
            },
            "description": "Optional taxonomy version (defaults to latest)",
            "example": 1
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/ExecuteTaxonomyRequest"
                  },
                  {
                    "type": "object",
                    "additionalProperties": true
                  }
                ],
                "title": "Payload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JoinResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Create Cluster",
        "description": "This endpoint allows you to create a new cluster configuration.",
        "operationId": "create_cluster_v1_clusters_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateClusterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/execute": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Execute Clustering",
        "description": "Execute clustering on a collection using the specified algorithm and parameters.\n    This endpoint triggers real-time clustering computation on the engine.",
        "operationId": "execute_clustering_v1_clusters_execute_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteClusterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteClusterResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_identifier}": {
      "get": {
        "tags": [
          "Clusters"
        ],
        "summary": "Get Cluster",
        "description": "This endpoint allows you to retrieve a cluster by ID or name.",
        "operationId": "get_cluster_v1_clusters__cluster_identifier__get",
        "parameters": [
          {
            "name": "cluster_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID or name",
              "title": "Cluster Identifier"
            },
            "description": "Cluster ID or name"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Clusters"
        ],
        "summary": "Partially Update Cluster",
        "description": "This endpoint partially updates a cluster (PATCH operation).\n    Only provided fields will be updated. At minimum, metadata can always be updated.\n    Immutable fields like cluster_id, status, and computed fields cannot be modified.",
        "operationId": "patch_cluster_v1_clusters__cluster_identifier__patch",
        "parameters": [
          {
            "name": "cluster_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID or name",
              "title": "Cluster Identifier"
            },
            "description": "Cluster ID or name"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchClusterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}": {
      "delete": {
        "tags": [
          "Clusters"
        ],
        "summary": "Delete Cluster",
        "description": "This endpoint allows you to delete a cluster by ID.",
        "operationId": "delete_cluster_v1_clusters__cluster_id__delete",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/list": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "List Clusters",
        "description": "This endpoint allows you to list clusters.",
        "operationId": "list_clusters_v1_clusters_list_post",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Offset"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListClustersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListClustersResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}/data": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Stream Cluster Data",
        "description": "Stream cluster data from S3 parquet files.",
        "operationId": "stream_cluster_data_v1_clusters__cluster_id__data_post",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClusterDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterDataResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/enrich": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Apply Cluster Enrichment",
        "description": "Apply clustering enrichments to a collection via engine.",
        "operationId": "apply_cluster_enrichment_v1_clusters_enrich_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ApplyClusterEnrichmentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusteringEnrichmentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}/artifacts": {
      "get": {
        "tags": [
          "Clusters"
        ],
        "summary": "Get Cluster Artifacts",
        "description": "Get cluster artifacts with dimensionality-reduced coordinates for visualization.\n\nReturns centroids and member points with 2D or 3D coordinates suitable for\nscatter plot visualization in the UI.",
        "operationId": "get_cluster_artifacts_v1_clusters__cluster_id__artifacts_get",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "include_centroids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include centroid data",
              "default": true,
              "title": "Include Centroids"
            },
            "description": "Include centroid data"
          },
          {
            "name": "include_members",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include member point data",
              "default": false,
              "title": "Include Members"
            },
            "description": "Include member point data"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Limit number of points returned",
              "title": "Limit"
            },
            "description": "Limit number of points returned"
          },
          {
            "name": "projection_method",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Projection method: '2d' or '3d'",
              "default": "2d",
              "title": "Projection Method"
            },
            "description": "Projection method: '2d' or '3d'"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/jobs/submit": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Submit Clustering Job",
        "description": "Submit an asynchronous clustering job processed by the engine poller.",
        "operationId": "submit_clustering_job_v1_clusters_jobs_submit_post",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional cluster_id to link job to cluster doc",
              "title": "Cluster Id"
            },
            "description": "Optional cluster_id to link job to cluster doc"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteClusterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          },
          "202": {
            "description": "Accepted \u2013 job enqueued. Poll Location for status.",
            "headers": {
              "Location": {
                "schema": {
                  "type": "string",
                  "format": "uri"
                },
                "description": "Task status URL (/v1/tasks/{id})."
              },
              "Retry-After": {
                "$ref": "#/components/headers/Retry-After"
              },
              "X-RateLimit-Limit": {
                "$ref": "#/components/headers/X-RateLimit-Limit"
              },
              "X-RateLimit-Remaining": {
                "$ref": "#/components/headers/X-RateLimit-Remaining"
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Create Cluster Trigger",
        "description": "Create a new trigger for automated cluster execution.\n\n    Supports multiple trigger types:\n    - **cron**: Execute at specific times using cron expressions\n    - **interval**: Execute at fixed intervals\n    - **event**: Execute when specific events occur (e.g., documents added)\n    - **conditional**: Execute when conditions are met (e.g., drift threshold)",
        "operationId": "create_trigger_v1_clusters_triggers_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTriggerRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/list": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "List Cluster Triggers",
        "description": "List cluster triggers with filters and pagination.",
        "operationId": "list_triggers_v1_clusters_triggers_list_post",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListTriggersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTriggersResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/{trigger_id}": {
      "get": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Get Cluster Trigger",
        "description": "Get a cluster trigger by ID.",
        "operationId": "get_trigger_v1_clusters_triggers__trigger_id__get",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Update Cluster Trigger",
        "description": "Update a cluster trigger.\n\n    Allowed updates:\n    - schedule_config: Modify trigger schedule\n    - description: Update description\n    - status: Change status (use pause/resume endpoints instead)\n\n    Not allowed:\n    - trigger_type: Must delete and recreate\n    - cluster_id: Immutable\n    - execution_config: Immutable",
        "operationId": "update_trigger_v1_clusters_triggers__trigger_id__patch",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTriggerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Delete Cluster Trigger",
        "description": "Delete a cluster trigger (soft delete).",
        "operationId": "delete_trigger_v1_clusters_triggers__trigger_id__delete",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/{trigger_id}/pause": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Pause Cluster Trigger",
        "description": "Pause trigger execution. Paused triggers retain configuration but do not execute.",
        "operationId": "pause_trigger_v1_clusters_triggers__trigger_id__pause_post",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/{trigger_id}/resume": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Resume Cluster Trigger",
        "description": "Resume paused trigger. Next execution time is recalculated from current time.",
        "operationId": "resume_trigger_v1_clusters_triggers__trigger_id__resume_post",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/{trigger_id}/history": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Get Trigger Execution History",
        "description": "Get execution history for a trigger with pagination.",
        "operationId": "get_trigger_history_v1_clusters_triggers__trigger_id__history_post",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TriggerHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerHistoryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}/executions": {
      "get": {
        "tags": [
          "Cluster Executions"
        ],
        "summary": "Get Latest Cluster Execution",
        "description": "Get the most recent execution results for a cluster.\n\n    Returns execution metadata including:\n    - Execution status (pending, processing, completed, failed)\n    - Clustering metrics (silhouette score, Davies-Bouldin index, etc.)\n    - Number of clusters found and documents processed\n    - Centroid information with labels and summaries\n    - Execution timestamps\n\n    Useful for:\n    - Displaying cluster statistics in dashboards\n    - Showing cluster quality metrics to users\n    - Rendering cluster labels and summaries in the UI\n    - Tracking execution status and errors",
        "operationId": "get_cluster_execution_v1_clusters__cluster_id__executions_get",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterExecutionResult"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}/executions/{run_id}": {
      "get": {
        "tags": [
          "Cluster Executions"
        ],
        "summary": "Get Specific Cluster Execution",
        "description": "Get a specific execution by run ID.\n\n    Returns detailed execution information for a particular clustering run,\n    allowing you to review historical executions and compare results over time.",
        "operationId": "get_cluster_execution_by_run_v1_clusters__cluster_id__executions__run_id__get",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "run_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Run ID",
              "title": "Run Id"
            },
            "description": "Run ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterExecutionResult"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}/executions/list": {
      "post": {
        "tags": [
          "Cluster Executions"
        ],
        "summary": "List Cluster Execution History",
        "description": "List execution history for a cluster with pagination, filtering, sorting, and search.\n\n    Returns all historical executions for the specified cluster, including:\n    - Execution status (pending, processing, completed, failed)\n    - Clustering metrics (silhouette score, Davies-Bouldin index, etc.)\n    - Number of clusters found and documents processed\n    - Execution timestamps and duration\n    - Centroid information\n\n    Supports:\n    - **Filtering**: Filter by status, date range, metrics, etc.\n    - **Sorting**: Sort by created_at, execution time, metrics\n    - **Search**: Full-text search across execution metadata\n    - **Pagination**: Limit and offset for large result sets\n\n    Use cases:\n    - View all past executions for a cluster\n    - Compare metrics across runs\n    - Track execution history over time\n    - Debug failed executions\n    - Analyze clustering performance trends",
        "operationId": "list_cluster_executions_v1_clusters__cluster_id__executions_list_post",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Offset"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListClusterExecutionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListClusterExecutionsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}/executions/{run_id}/artifacts": {
      "get": {
        "tags": [
          "Cluster Executions"
        ],
        "summary": "Get Execution Artifacts",
        "description": "Get visualization artifacts for a specific execution by run ID.\n\n    Returns centroids and member points with 2D or 3D coordinates from\n    a specific clustering execution. Useful for:\n    - Viewing historical clustering visualizations\n    - Comparing different execution results\n    - Analyzing how clustering evolved over time\n\n    Supports the same visualization options as the latest execution endpoint.",
        "operationId": "get_execution_artifacts_v1_clusters__cluster_id__executions__run_id__artifacts_get",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "run_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Run ID",
              "title": "Run Id"
            },
            "description": "Run ID"
          },
          {
            "name": "include_centroids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include centroid data",
              "default": true,
              "title": "Include Centroids"
            },
            "description": "Include centroid data"
          },
          {
            "name": "include_members",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include member point data",
              "default": false,
              "title": "Include Members"
            },
            "description": "Include member point data"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Limit number of points returned",
              "title": "Limit"
            },
            "description": "Limit number of points returned"
          },
          {
            "name": "projection_method",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Projection method: '2d' or '3d'",
              "default": "2d",
              "title": "Projection Method"
            },
            "description": "Projection method: '2d' or '3d'"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}/executions/{run_id}/data": {
      "post": {
        "tags": [
          "Cluster Executions"
        ],
        "summary": "Stream Execution Data",
        "description": "Stream raw cluster data from parquet files for a specific execution.\n\n    Returns centroids and/or members from the S3-stored parquet files\n    for a specific clustering execution. Useful for:\n    - Downloading complete execution data\n    - Analyzing historical clustering results\n    - Exporting execution data for external processing\n\n    Supports pagination via offset/limit for large datasets.",
        "operationId": "stream_execution_data_v1_clusters__cluster_id__executions__run_id__data_post",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "run_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Run ID",
              "title": "Run Id"
            },
            "description": "Run ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_stream_execution_data_v1_clusters__cluster_id__executions__run_id__data_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/retrievers/{retriever_id}/performance": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Retrievers"
        ],
        "summary": "Get Retriever Performance",
        "description": "Get retriever performance metrics for tuning.\n\nRetrieves time-series performance data including:\n- Query latency (P50, P95, P99)\n- Query counts\n- Result counts\n- Latency trends\n\n**Use Cases:**\n- Monitor retriever performance over time\n- Identify performance degradations\n- Compare performance across time periods\n- Establish performance baselines\n\n**Example:**\n```bash\ncurl -X GET \"https://api.mixpeek.com/v1/analytics/retrievers/ret_abc123/performance?hours=24&group_by=hour\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"X-Namespace: your-namespace\"\n```",
        "operationId": "get_retriever_performance_v1_analytics_retrievers__retriever_id__performance_get",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Retriever Id"
            }
          },
          {
            "name": "start_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Start date (UTC)",
              "title": "Start Date"
            },
            "description": "Start date (UTC)"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string",
                  "format": "date-time"
                },
                {
                  "type": "null"
                }
              ],
              "description": "End date (UTC)",
              "title": "End Date"
            },
            "description": "End date (UTC)"
          },
          {
            "name": "group_by",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Time grouping: hour, day, week",
              "default": "hour",
              "title": "Group By"
            },
            "description": "Time grouping: hour, day, week"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RetrieverPerformanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/retrievers/{retriever_id}/stages": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Retrievers"
        ],
        "summary": "Get Stage Breakdown",
        "description": "Get stage-level performance breakdown.\n\nAnalyzes individual stage performance to identify bottlenecks:\n- Stage execution times\n- Document flow (in/out)\n- Stage-level latency distribution\n\n**Use Cases:**\n- Identify slow stages in retrieval pipeline\n- Optimize stage ordering\n- Debug pipeline bottlenecks\n- Understand document reduction rates\n\n**Example:**\n```bash\ncurl -X GET \"https://api.mixpeek.com/v1/analytics/retrievers/ret_abc123/stages?hours=24\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"X-Namespace: your-namespace\"\n```",
        "operationId": "get_stage_breakdown_v1_analytics_retrievers__retriever_id__stages_get",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Retriever Id"
            }
          },
          {
            "name": "hours",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 720,
              "minimum": 1,
              "description": "Hours of history",
              "default": 24,
              "title": "Hours"
            },
            "description": "Hours of history"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StageBreakdownResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/retrievers/{retriever_id}/signals": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Retrievers"
        ],
        "summary": "Get Retriever Signals",
        "description": "Get retriever signals for interaction tuning.\n\nRetrieves fine-grained signals about retriever behavior:\n- Cache hits/misses\n- Reranking scores\n- Filter effectiveness\n- Query expansion results\n\n**Signal Types:**\n- `cache_hit`: Successful cache lookups\n- `cache_miss`: Cache misses requiring full search\n- `rerank_scores`: Reranking effectiveness metrics\n- `filter_reduction`: Pre-filter document reduction\n- `expansion_results`: Query expansion impact\n\n**Use Cases:**\n- Fine-tune retrieval parameters\n- Analyze query patterns\n- Optimize cache strategies\n- Validate optimization improvements\n\n**Example:**\n```bash\ncurl -X GET \"https://api.mixpeek.com/v1/analytics/retrievers/ret_abc123/signals?signal_type=rerank_scores&limit=50\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"X-Namespace: your-namespace\"\n```",
        "operationId": "get_retriever_signals_v1_analytics_retrievers__retriever_id__signals_get",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Retriever Id"
            }
          },
          {
            "name": "signal_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by signal type (cache_hit, rerank_scores, etc.)",
              "title": "Signal Type"
            },
            "description": "Filter by signal type (cache_hit, rerank_scores, etc.)"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "description": "Maximum results",
              "default": 100,
              "title": "Limit"
            },
            "description": "Maximum results"
          },
          {
            "name": "hours",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 720,
              "minimum": 1,
              "description": "Hours of history",
              "default": 24,
              "title": "Hours"
            },
            "description": "Hours of history"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RetrieverSignal"
                  },
                  "title": "Response Get Retriever Signals V1 Analytics Retrievers  Retriever Id  Signals Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/retrievers/{retriever_id}/cache-performance": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Retrievers"
        ],
        "summary": "Get Cache Performance",
        "description": "Get cache performance metrics.\n\nAnalyzes cache effectiveness including:\n- Hit/miss rates\n- Latency comparison (cache vs full search)\n- Hourly cache performance trends\n\n**Use Cases:**\n- Evaluate cache effectiveness\n- Optimize cache TTL settings\n- Monitor cache performance\n- Identify cache warming opportunities\n\n**Example:**\n```bash\ncurl -X GET \"https://api.mixpeek.com/v1/analytics/retrievers/ret_abc123/cache-performance?hours=168\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"X-Namespace: your-namespace\"\n```",
        "operationId": "get_cache_performance_v1_analytics_retrievers__retriever_id__cache_performance_get",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Retriever Id"
            }
          },
          {
            "name": "hours",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 720,
              "minimum": 1,
              "description": "Hours of history",
              "default": 24,
              "title": "Hours"
            },
            "description": "Hours of history"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CachePerformanceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/retrievers/{retriever_id}/analyze-tuning": {
      "post": {
        "tags": [
          "Analytics",
          "Analytics - Retrievers"
        ],
        "summary": "Analyze For Tuning",
        "description": "Analyze retriever and generate tuning recommendations.\n\nPerforms comprehensive analysis and generates actionable recommendations:\n- Parameter tuning suggestions\n- Cache optimization opportunities\n- Performance improvement estimates\n\n**Recommendations Include:**\n- Increase/decrease k value\n- Adjust reranking thresholds\n- Enable/optimize caching\n- Stage reordering suggestions\n\n**Use Cases:**\n- Initial retriever configuration\n- Periodic performance optimization\n- A/B testing parameter changes\n- Cost optimization\n\n**Example:**\n```bash\ncurl -X POST \"https://api.mixpeek.com/v1/analytics/retrievers/ret_abc123/analyze-tuning?days=7\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"X-Namespace: your-namespace\"\n```",
        "operationId": "analyze_for_tuning_v1_analytics_retrievers__retriever_id__analyze_tuning_post",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Retriever Id"
            }
          },
          {
            "name": "days",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 90,
              "minimum": 1,
              "description": "Days of history to analyze",
              "default": 7,
              "title": "Days"
            },
            "description": "Days of history to analyze"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InteractionTuningResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/retrievers/{retriever_id}/slow-queries": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Retrievers"
        ],
        "summary": "Get Slowest Queries",
        "description": "Get slowest queries for troubleshooting.\n\nIdentifies slowest-performing queries for optimization:\n- Query text\n- Execution time\n- Result counts\n- Stage breakdown\n\n**Use Cases:**\n- Identify problematic queries\n- Debug performance issues\n- Optimize query patterns\n- User experience improvements\n\n**Example:**\n```bash\ncurl -X GET \"https://api.mixpeek.com/v1/analytics/retrievers/ret_abc123/slow-queries?limit=10&hours=24\" \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"X-Namespace: your-namespace\"\n```",
        "operationId": "get_slowest_queries_v1_analytics_retrievers__retriever_id__slow_queries_get",
        "parameters": [
          {
            "name": "retriever_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Retriever Id"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "description": "Number of queries to return",
              "default": 10,
              "title": "Limit"
            },
            "description": "Number of queries to return"
          },
          {
            "name": "hours",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 720,
              "minimum": 1,
              "description": "Hours of history",
              "default": 24,
              "title": "Hours"
            },
            "description": "Hours of history"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": true
                  },
                  "title": "Response Get Slowest Queries V1 Analytics Retrievers  Retriever Id  Slow Queries Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/performance/api": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Performance"
        ],
        "summary": "Get Api Performance",
        "description": "Get API performance metrics.\n\nTODO: Implement API performance query logic.",
        "operationId": "get_api_performance_v1_analytics_performance_api_get",
        "parameters": [
          {
            "name": "hours",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 720,
              "minimum": 1,
              "description": "Hours of history",
              "default": 24,
              "title": "Hours"
            },
            "description": "Hours of history"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": true
                  },
                  "title": "Response Get Api Performance V1 Analytics Performance Api Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/performance/engine": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Performance"
        ],
        "summary": "Get Engine Performance",
        "description": "Get Engine performance metrics.\n\nTODO: Implement Engine performance query logic.",
        "operationId": "get_engine_performance_v1_analytics_performance_engine_get",
        "parameters": [
          {
            "name": "hours",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 720,
              "minimum": 1,
              "description": "Hours of history",
              "default": 24,
              "title": "Hours"
            },
            "description": "Hours of history"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": true
                  },
                  "title": "Response Get Engine Performance V1 Analytics Performance Engine Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/usage/summary": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Usage"
        ],
        "summary": "Get Usage Summary",
        "description": "Get usage summary for billing.\n\nTODO: Implement usage summary query logic.",
        "operationId": "get_usage_summary_v1_analytics_usage_summary_get",
        "parameters": [
          {
            "name": "start_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date-time",
              "description": "Start date",
              "title": "Start Date"
            },
            "description": "Start date"
          },
          {
            "name": "end_date",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "format": "date-time",
              "description": "End date",
              "title": "End Date"
            },
            "description": "End date"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Usage Summary V1 Analytics Usage Summary Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/extractors/performance": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Extractors"
        ],
        "summary": "Get Extractor Performance",
        "description": "Get feature extraction performance metrics.\n\nTODO: Implement extractor performance query logic.",
        "operationId": "get_extractor_performance_v1_analytics_extractors_performance_get",
        "parameters": [
          {
            "name": "extractor_name",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by extractor",
              "title": "Extractor Name"
            },
            "description": "Filter by extractor"
          },
          {
            "name": "hours",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 720,
              "minimum": 1,
              "description": "Hours of history",
              "default": 24,
              "title": "Hours"
            },
            "description": "Hours of history"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": true
                  },
                  "title": "Response Get Extractor Performance V1 Analytics Extractors Performance Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/analytics/inference/performance": {
      "get": {
        "tags": [
          "Analytics",
          "Analytics - Inference"
        ],
        "summary": "Get Inference Performance",
        "description": "Get inference performance metrics.\n\nTODO: Implement inference performance query logic.",
        "operationId": "get_inference_performance_v1_analytics_inference_performance_get",
        "parameters": [
          {
            "name": "model_name",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by model",
              "title": "Model Name"
            },
            "description": "Filter by model"
          },
          {
            "name": "hours",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 720,
              "minimum": 1,
              "description": "Hours of history",
              "default": 24,
              "title": "Hours"
            },
            "description": "Hours of history"
          },
          {
            "name": "func",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Function reference (internal use only)",
              "title": "Func"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings.",
              "examples": [
                "Bearer sk_live_abc123def456",
                "Bearer sk_test_xyz789"
              ],
              "title": "Authorization"
            },
            "description": "REQUIRED: Bearer token authentication using your API key. Format: 'Bearer sk_xxxxxxxxxxxxx'. You can create API keys in the Mixpeek dashboard under Organization Settings."
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'",
              "examples": [
                "ns_abc123def456",
                "production",
                "my-namespace"
              ],
              "title": "X-Namespace"
            },
            "description": "REQUIRED: Namespace identifier for scoping this request. All resources (collections, buckets, taxonomies, etc.) are scoped to a namespace. You can provide either the namespace name or namespace ID. Format: ns_xxxxxxxxxxxxx (ID) or a custom name like 'my-namespace'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": true
                  },
                  "title": "Response Get Inference Performance V1 Analytics Inference Performance Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "APIKeyCreateRequest": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "description": "Human-friendly key label shown in dashboards."
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 500
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Optional description explaining the key's purpose."
          },
          "permissions": {
            "items": {
              "$ref": "#/components/schemas/Permission"
            },
            "type": "array",
            "title": "Permissions",
            "description": "Set of permissions granted to the API key (least privilege)."
          },
          "scopes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/ResourceScope"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Scopes",
            "description": "Optional resource scope restrictions applied to the key."
          },
          "rate_limit_override": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Rate Limit Override",
            "description": "Per-key requests-per-minute override (defaults to plan limit when absent)."
          },
          "expires_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expires At",
            "description": "Optional UTC timestamp when the key automatically expires."
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "APIKeyCreateRequest",
        "description": "Payload for creating a new API key.",
        "examples": [
          {
            "description": "Service account for ingestion pipeline",
            "name": "backend-service",
            "permissions": [
              "read",
              "write"
            ],
            "rate_limit_override": 120
          },
          {
            "name": "analytics-read",
            "permissions": [
              "read"
            ],
            "scopes": [
              {
                "operations": [
                  "read_data"
                ],
                "resource_id": "ns_reporting",
                "resource_type": "namespace"
              }
            ]
          }
        ]
      },
      "APIKeyCreateResponse": {
        "properties": {
          "key_id": {
            "type": "string",
            "title": "Key Id",
            "description": "Public identifier for the API key."
          },
          "key_hash": {
            "type": "string",
            "title": "Key Hash",
            "description": "SHA-256 hash of the plaintext key."
          },
          "internal_id": {
            "type": "string",
            "title": "Internal Id",
            "description": "Organization internal identifier."
          },
          "organization_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Organization Id",
            "description": "Organization public identifier (denormalized)."
          },
          "user_id": {
            "type": "string",
            "title": "User Id",
            "description": "Identifier of the user who owns the key."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Human-friendly key label."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description explaining the key usage.",
            "default": ""
          },
          "permissions": {
            "items": {
              "$ref": "#/components/schemas/Permission"
            },
            "type": "array",
            "title": "Permissions",
            "description": "Permissions granted to the key (least privilege recommended)."
          },
          "scopes": {
            "items": {
              "$ref": "#/components/schemas/ResourceScope"
            },
            "type": "array",
            "title": "Scopes",
            "description": "Resource-level scopes restricting the key."
          },
          "rate_limit_override": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Rate Limit Override",
            "description": "Optional per-key rate limit override in requests per minute."
          },
          "status": {
            "$ref": "#/components/schemas/KeyStatus",
            "description": "Lifecycle status of the key (active, revoked, expired).",
            "default": "active"
          },
          "expires_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expires At",
            "description": "UTC timestamp when the key automatically expires."
          },
          "last_used_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Used At",
            "description": "UTC timestamp of the last successful request using the key."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "UTC timestamp when the key was created."
          },
          "created_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created By",
            "description": "User identifier that created the key."
          },
          "revoked_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Revoked At",
            "description": "UTC timestamp when the key was revoked (if applicable)."
          },
          "revoked_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Revoked By",
            "description": "User identifier that revoked the key (if applicable)."
          },
          "key": {
            "type": "string",
            "title": "Key"
          }
        },
        "type": "object",
        "required": [
          "key_hash",
          "internal_id",
          "user_id",
          "name",
          "key"
        ],
        "title": "APIKeyCreateResponse",
        "description": "API key response including the plaintext secret.",
        "examples": [
          {
            "created_at": "2025-01-01T00:00:00Z",
            "created_by": "usr_admin",
            "description": "Service account for ingestion",
            "internal_id": "int_x1y2z3",
            "key_hash": "2c26b46b68ffc68ff99b453c1d304134",
            "key_id": "key_a1b2c3d4e5f6g7h",
            "name": "backend-service",
            "organization_id": "org_demo123",
            "permissions": [
              "read",
              "write"
            ],
            "scopes": [],
            "status": "active",
            "user_id": "usr_a1b2c3d4e5f6g7h"
          }
        ]
      },
      "APIKeyModel": {
        "properties": {
          "key_id": {
            "type": "string",
            "title": "Key Id",
            "description": "Public identifier for the API key."
          },
          "key_hash": {
            "type": "string",
            "title": "Key Hash",
            "description": "SHA-256 hash of the plaintext key."
          },
          "internal_id": {
            "type": "string",
            "title": "Internal Id",
            "description": "Organization internal identifier."
          },
          "organization_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Organization Id",
            "description": "Organization public identifier (denormalized)."
          },
          "user_id": {
            "type": "string",
            "title": "User Id",
            "description": "Identifier of the user who owns the key."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Human-friendly key label."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description explaining the key usage.",
            "default": ""
          },
          "permissions": {
            "items": {
              "$ref": "#/components/schemas/Permission"
            },
            "type": "array",
            "title": "Permissions",
            "description": "Permissions granted to the key (least privilege recommended)."
          },
          "scopes": {
            "items": {
              "$ref": "#/components/schemas/ResourceScope"
            },
            "type": "array",
            "title": "Scopes",
            "description": "Resource-level scopes restricting the key."
          },
          "rate_limit_override": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Rate Limit Override",
            "description": "Optional per-key rate limit override in requests per minute."
          },
          "status": {
            "$ref": "#/components/schemas/KeyStatus",
            "description": "Lifecycle status of the key (active, revoked, expired).",
            "default": "active"
          },
          "expires_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expires At",
            "description": "UTC timestamp when the key automatically expires."
          },
          "last_used_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Used At",
            "description": "UTC timestamp of the last successful request using the key."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "UTC timestamp when the key was created."
          },
          "created_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created By",
            "description": "User identifier that created the key."
          },
          "revoked_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Revoked At",
            "description": "UTC timestamp when the key was revoked (if applicable)."
          },
          "revoked_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Revoked By",
            "description": "User identifier that revoked the key (if applicable)."
          }
        },
        "type": "object",
        "required": [
          "key_hash",
          "internal_id",
          "user_id",
          "name"
        ],
        "title": "APIKeyModel",
        "description": "API key document stored in MongoDB.",
        "examples": [
          {
            "created_at": "2025-01-01T00:00:00Z",
            "created_by": "usr_admin",
            "description": "Service account for ingestion",
            "internal_id": "int_x1y2z3",
            "key_hash": "2c26b46b68ffc68ff99b453c1d304134",
            "key_id": "key_a1b2c3d4e5f6g7h",
            "name": "backend-service",
            "organization_id": "org_demo123",
            "permissions": [
              "read",
              "write"
            ],
            "scopes": [],
            "status": "active",
            "user_id": "usr_a1b2c3d4e5f6g7h"
          }
        ]
      },
      "APIKeyUpdateRequest": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 100,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "New key label."
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 500
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Updated description for the key."
          },
          "permissions": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/Permission"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Permissions",
            "description": "Replace existing permissions with the provided list."
          },
          "scopes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/ResourceScope"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Scopes",
            "description": "Replace existing scopes. Use empty list for global access."
          },
          "rate_limit_override": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Rate Limit Override",
            "description": "Updated per-key rate limit override."
          },
          "expires_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expires At",
            "description": "New expiration timestamp. Use null to remove expiration."
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/KeyStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Manually set key status (e.g. revoke)."
          }
        },
        "type": "object",
        "title": "APIKeyUpdateRequest",
        "description": "Partial update payload for an API key."
      },
      "AccountTier": {
        "type": "string",
        "enum": [
          "free",
          "pro",
          "team",
          "enterprise"
        ],
        "title": "AccountTier",
        "description": "Account tier with monthly credit allocations.\n\nTiers:\n    FREE: 1,000 credits/month - Limited modalities, shared compute\n    PRO: 100,000 credits/month - All modalities, dedicated namespace\n    TEAM: 1,000,000 credits/month - Shared buckets, retrieval DAGs\n    ENTERPRISE: Custom credits - Dedicated Ray cluster, SLA"
      },
      "AddCreditsRequest": {
        "properties": {
          "credits": {
            "type": "integer",
            "exclusiveMinimum": 0.0,
            "title": "Credits",
            "description": "Number of credits to add. Must be positive.",
            "examples": [
              1000,
              10000,
              100000
            ]
          }
        },
        "type": "object",
        "required": [
          "credits"
        ],
        "title": "AddCreditsRequest",
        "description": "Request to add credits to an organization."
      },
      "AddCreditsResponse": {
        "properties": {
          "previous_balance": {
            "type": "integer",
            "title": "Previous Balance",
            "description": "Credit balance before addition"
          },
          "credits_added": {
            "type": "integer",
            "title": "Credits Added",
            "description": "Number of credits added"
          },
          "new_balance": {
            "type": "integer",
            "title": "New Balance",
            "description": "Credit balance after addition"
          },
          "previous_tier": {
            "$ref": "#/components/schemas/AccountTier",
            "description": "Account tier before addition"
          },
          "new_tier": {
            "$ref": "#/components/schemas/AccountTier",
            "description": "Account tier after addition (may auto-upgrade)"
          },
          "tier_upgraded": {
            "type": "boolean",
            "title": "Tier Upgraded",
            "description": "Whether tier was automatically upgraded"
          }
        },
        "type": "object",
        "required": [
          "previous_balance",
          "credits_added",
          "new_balance",
          "previous_tier",
          "new_tier",
          "tier_upgraded"
        ],
        "title": "AddCreditsResponse",
        "description": "Response after adding credits."
      },
      "AddObjectsToBatchRequest": {
        "properties": {
          "object_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Object Ids",
            "description": "A list of object IDs to add to the batch.",
            "examples": [
              [
                "object_789",
                "object_101"
              ]
            ]
          }
        },
        "type": "object",
        "required": [
          "object_ids"
        ],
        "title": "AddObjectsToBatchRequest",
        "description": "The request model for adding objects to an existing batch."
      },
      "AddUserToOrganizationRequest": {
        "properties": {
          "organization_identifier": {
            "type": "string",
            "title": "Organization Identifier",
            "description": "Organization ID or name to add users to."
          },
          "users": {
            "items": {
              "$ref": "#/components/schemas/UserCreateRequest"
            },
            "type": "array",
            "minItems": 1,
            "title": "Users",
            "description": "List of users to add to the organization."
          }
        },
        "type": "object",
        "required": [
          "organization_identifier",
          "users"
        ],
        "title": "AddUserToOrganizationRequest",
        "description": "Payload for adding users to an organization (private/admin endpoint).",
        "examples": [
          {
            "organization_identifier": "org_demo123",
            "users": [
              {
                "email": "newuser@example.com",
                "role": "member",
                "user_name": "New User"
              }
            ]
          }
        ]
      },
      "AgglomerativeParams": {
        "properties": {
          "n_clusters": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 2.0
              },
              {
                "type": "null"
              }
            ],
            "title": "N Clusters",
            "description": "Number of clusters to find. Can be None if distance_threshold is not None",
            "default": 2
          },
          "affinity": {
            "type": "string",
            "title": "Affinity",
            "description": "Metric used to compute linkage. Can be 'euclidean', 'l1', 'l2', 'manhattan', 'cosine', or 'precomputed'",
            "default": "euclidean"
          },
          "memory": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Memory",
            "description": "Path to the caching directory"
          },
          "connectivity": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "title": "Connectivity",
            "description": "Connectivity matrix. Defines which samples are neighbors"
          },
          "compute_full_tree": {
            "type": "string",
            "title": "Compute Full Tree",
            "description": "Whether to compute the full tree ('auto', True, or False)",
            "default": "auto"
          },
          "linkage": {
            "type": "string",
            "title": "Linkage",
            "description": "Linkage criterion ('ward', 'complete', 'average', 'single')",
            "default": "ward"
          },
          "distance_threshold": {
            "anyOf": [
              {
                "type": "number",
                "exclusiveMinimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Distance Threshold",
            "description": "The linkage distance threshold above which clusters will not be merged"
          },
          "compute_distances": {
            "type": "boolean",
            "title": "Compute Distances",
            "description": "Whether to compute distances between clusters",
            "default": false
          }
        },
        "type": "object",
        "title": "AgglomerativeParams",
        "description": "Parameters for Agglomerative clustering algorithm."
      },
      "AggregationFunction": {
        "type": "string",
        "enum": [
          "count",
          "count_distinct",
          "sum",
          "avg",
          "min",
          "max",
          "first",
          "last",
          "push",
          "add_to_set"
        ],
        "title": "AggregationFunction",
        "description": "Supported aggregation functions.\n\nThese functions can be applied to fields during aggregation operations.\n\nValues:\n    COUNT: Count total number of items in each group\n    COUNT_DISTINCT: Count unique values in a field\n    SUM: Sum numeric values\n    AVG: Calculate average of numeric values\n    MIN: Find minimum value\n    MAX: Find maximum value\n    FIRST: Get first value in group\n    LAST: Get last value in group\n    PUSH: Collect all values into an array\n    ADD_TO_SET: Collect unique values into an array\n\nExamples:\n    - Use COUNT for total items per category\n    - Use COUNT_DISTINCT for unique users per day\n    - Use SUM for total revenue\n    - Use AVG for average video duration"
      },
      "AggregationOperation": {
        "properties": {
          "function": {
            "$ref": "#/components/schemas/AggregationFunction",
            "description": "The aggregation function to apply. Different functions require different field types: COUNT: no field required. SUM/AVG: numeric fields only. MIN/MAX: numeric or date fields. COUNT_DISTINCT: any field type."
          },
          "field": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Field",
            "description": "The field to aggregate. REQUIRED for all functions except COUNT. NOT REQUIRED for COUNT (counts documents). Supports dot notation for nested fields. Field type must be compatible with function.",
            "examples": [
              "metadata.views",
              "metadata.duration",
              "blobs.size",
              "created_at"
            ]
          },
          "alias": {
            "type": "string",
            "title": "Alias",
            "description": "Name for the aggregation result in output. REQUIRED for all operations. Should be descriptive of the calculation. Used to reference results in post-filtering.",
            "examples": [
              "total_count",
              "total_views",
              "avg_duration",
              "max_size"
            ]
          },
          "distinct_field": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Distinct Field",
            "description": "Field to count distinct values from. REQUIRED when function is COUNT_DISTINCT. NOT REQUIRED for other functions. Supports dot notation for nested fields.",
            "examples": [
              "metadata.user_id",
              "metadata.ip_address",
              "object_id"
            ]
          }
        },
        "type": "object",
        "required": [
          "function",
          "alias"
        ],
        "title": "AggregationOperation",
        "description": "Configuration for an aggregation operation.\n\nDefines a calculation to perform on grouped data.\n\nRequirements:\n    - function: REQUIRED, the aggregation function to apply\n    - field: REQUIRED for most functions (except COUNT), field to aggregate\n    - alias: REQUIRED, name for the result in output\n\nExamples:\n    - Count: AggregationOperation(function=\"count\", alias=\"total_count\")\n    - Sum: AggregationOperation(function=\"sum\", field=\"metadata.views\", alias=\"total_views\")\n    - Average: AggregationOperation(function=\"avg\", field=\"metadata.duration\", alias=\"avg_duration\")",
        "examples": [
          {
            "alias": "total_count",
            "description": "Count total documents",
            "function": "count"
          },
          {
            "alias": "total_views",
            "description": "Sum all views",
            "field": "metadata.views",
            "function": "sum"
          },
          {
            "alias": "avg_duration",
            "description": "Average duration",
            "field": "metadata.duration",
            "function": "avg"
          },
          {
            "alias": "unique_users",
            "description": "Count unique users",
            "distinct_field": "metadata.user_id",
            "function": "count_distinct"
          }
        ]
      },
      "AggregationResult": {
        "properties": {
          "group": {
            "additionalProperties": true,
            "type": "object",
            "title": "Group",
            "description": "Grouped field values that define this result row."
          },
          "metrics": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metrics",
            "description": "Computed aggregation values for this group."
          }
        },
        "type": "object",
        "required": [
          "group",
          "metrics"
        ],
        "title": "AggregationResult",
        "description": "Single aggregation result row.\n\nContains grouped field values and computed aggregations.",
        "examples": [
          {
            "group": {
              "category": "sports"
            },
            "metrics": {
              "avg_duration": 245.3,
              "total_count": 1523
            }
          }
        ]
      },
      "ApplyClusterEnrichmentRequest": {
        "properties": {
          "clustering_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Clustering Ids",
            "description": "Clustering result IDs to apply"
          },
          "source_collection_id": {
            "type": "string",
            "title": "Source Collection Id",
            "description": "Collection to enrich"
          },
          "target_collection_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Target Collection Id",
            "description": "Target collection to write enriched docs to"
          },
          "batch_size": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Batch Size",
            "description": "Batch size for processing",
            "default": 1000
          },
          "parallelism": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Parallelism",
            "description": "Parallel workers",
            "default": 1
          }
        },
        "type": "object",
        "required": [
          "clustering_ids",
          "source_collection_id"
        ],
        "title": "ApplyClusterEnrichmentRequest",
        "description": "Request to apply clustering enrichment to a collection.\n\nSupports applying multiple clustering results in one request via\n`clustering_ids`. For backward compatibility, a single `clustering_id`\nis also accepted and up-converted."
      },
      "AttributeBasedConfig": {
        "properties": {
          "attributes": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Attributes",
            "description": "List of attribute field names to use for clustering. Documents will be grouped by unique combinations of these attribute values. Supports dot-notation for nested fields (e.g., 'metadata.category'). Order matters for hierarchical grouping: first attribute is top-level, subsequent are nested.",
            "examples": [
              [
                "category"
              ],
              [
                "category",
                "brand"
              ],
              [
                "status",
                "priority"
              ],
              [
                "metadata.author",
                "metadata.topic"
              ]
            ]
          },
          "hierarchical_grouping": {
            "type": "boolean",
            "title": "Hierarchical Grouping",
            "description": "Whether to create hierarchical clusters based on attribute order. When True: Creates parent clusters for each unique value of the first attribute, then child clusters for subsequent attributes within each parent. When False: Creates flat clusters for each unique combination of all attributes. Example with ['category', 'brand']:   hierarchical=True \u2192 'Electronics' (parent) \u2192 'Apple', 'Samsung' (children).   hierarchical=False \u2192 'Electronics_Apple', 'Electronics_Samsung' (flat).",
            "default": false
          },
          "aggregation_method": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Aggregation Method",
            "description": "Method for aggregating attribute values when creating cluster centroids. Options: 'most_frequent' (default), 'first', 'last'. Most use cases should use the default.",
            "examples": [
              "most_frequent",
              "first",
              "last"
            ]
          }
        },
        "type": "object",
        "required": [
          "attributes"
        ],
        "title": "AttributeBasedConfig",
        "description": "Configuration for attribute-based clustering.\n\nAttribute-based clustering groups documents by metadata attributes (e.g., category, brand, status)\ninstead of vector similarity. This is useful for organizing content by business logic rather than\nsemantic similarity.\n\nExamples:\n    - Group products by category and brand\n    - Organize orders by status and priority\n    - Cluster content by author and topic",
        "examples": [
          {
            "attributes": [
              "category"
            ],
            "description": "Simple category clustering",
            "hierarchical_grouping": false
          },
          {
            "attributes": [
              "category",
              "brand"
            ],
            "description": "Hierarchical category \u2192 brand clustering",
            "hierarchical_grouping": true
          },
          {
            "aggregation_method": "most_frequent",
            "attributes": [
              "status",
              "priority"
            ],
            "description": "Order status and priority (flat)",
            "hierarchical_grouping": false
          }
        ]
      },
      "BaseFeatureExtractorModel-Input": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Version of the feature extractor"
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version"
        ],
        "title": "BaseFeatureExtractorModel",
        "description": "Minimum feature extractor definition."
      },
      "BaseFeatureExtractorModel-Output": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Version of the feature extractor"
          },
          "feature_extractor_id": {
            "type": "string",
            "title": "Feature Extractor Id",
            "description": "Construct unique identifier for the feature extractor instance (name + version).",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version",
          "feature_extractor_id"
        ],
        "title": "BaseFeatureExtractorModel",
        "description": "Minimum feature extractor definition."
      },
      "BaseRateLimits": {
        "properties": {
          "default": {
            "type": "integer",
            "title": "Default",
            "default": 10
          },
          "search": {
            "type": "integer",
            "title": "Search",
            "default": 10
          },
          "upload": {
            "type": "integer",
            "title": "Upload",
            "default": 10
          },
          "delete": {
            "type": "integer",
            "title": "Delete",
            "default": 10
          }
        },
        "type": "object",
        "title": "BaseRateLimits",
        "description": "Base rate limits."
      },
      "BatchConfirmRequest": {
        "properties": {
          "confirmations": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Confirmations",
            "description": "List of confirmations with upload_id, etag, file_size_bytes"
          }
        },
        "type": "object",
        "required": [
          "confirmations"
        ],
        "title": "BatchConfirmRequest",
        "description": "Request to confirm multiple uploads in batch.",
        "examples": [
          {
            "confirmations": [
              {
                "etag": "d41d8cd98f00b204e9800998ecf8427e",
                "file_size_bytes": 10485760,
                "upload_id": "upl_abc123"
              },
              {
                "etag": "7f9c12ab56f4e12d80cf8d98fe12c4a9",
                "file_size_bytes": 5242880,
                "upload_id": "upl_def456"
              }
            ]
          }
        ]
      },
      "BatchConfirmResponse": {
        "properties": {
          "task_id": {
            "type": "string",
            "title": "Task Id",
            "description": "Task ID for tracking batch confirmation progress"
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Task status"
          },
          "confirmations_count": {
            "type": "integer",
            "title": "Confirmations Count",
            "description": "Number of confirmations being processed"
          },
          "task": {
            "$ref": "#/components/schemas/TaskResponse",
            "description": "Full task details"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Status message",
            "default": "Batch confirmation is being processed in the background."
          }
        },
        "type": "object",
        "required": [
          "task_id",
          "status",
          "confirmations_count",
          "task"
        ],
        "title": "BatchConfirmResponse",
        "description": "Response from batch confirmation."
      },
      "BatchDeleteDocumentsRequest": {
        "properties": {
          "document_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 1000,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Document Ids",
            "description": "OPTIONAL. List of document IDs to delete. Use this mode when you know exact document IDs to delete. Mutually exclusive with filters mode. Maximum 1000 documents per batch request.",
            "examples": [
              [
                "doc_123",
                "doc_456",
                "doc_789"
              ],
              [
                "doc_frame_001",
                "doc_frame_002"
              ]
            ]
          },
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "OPTIONAL. Filter conditions to match documents for deletion. Mutually exclusive with 'document_ids' array. If provided, deletes ALL documents matching the filters. Use with caution - can delete many documents at once.",
            "examples": [
              {
                "must": [
                  {
                    "key": "metadata.status",
                    "value": "archived"
                  }
                ]
              }
            ]
          }
        },
        "type": "object",
        "title": "BatchDeleteDocumentsRequest",
        "description": "Request model for batch deleting multiple documents by explicit IDs or filters.\n\nSupports TWO modes:\n1. Explicit IDs mode: Provide 'document_ids' array\n2. Filter mode: Provide 'filters' to delete all matching documents\n\nUse Cases:\n    - Delete 5 specific documents in one API call\n    - Delete all documents matching criteria\n    - Bulk cleanup operations\n\nRequirements:\n    - EITHER 'document_ids' OR 'filters' must be provided\n    - NOT BOTH modes simultaneously",
        "examples": [
          {
            "description": "Explicit IDs mode: Delete 3 specific documents",
            "document_ids": [
              "doc_123",
              "doc_456",
              "doc_789"
            ]
          },
          {
            "description": "Filter mode: Delete all archived documents",
            "filters": {
              "must": [
                {
                  "key": "metadata.status",
                  "value": "archived"
                }
              ]
            }
          }
        ]
      },
      "BatchDeleteDocumentsResponse": {
        "properties": {
          "deleted_count": {
            "type": "integer",
            "title": "Deleted Count",
            "description": "Total number of documents successfully deleted"
          },
          "failed_count": {
            "type": "integer",
            "title": "Failed Count",
            "description": "Total number of documents that failed to delete",
            "default": 0
          },
          "results": {
            "items": {
              "$ref": "#/components/schemas/BatchDocumentDeleteResult"
            },
            "type": "array",
            "title": "Results",
            "description": "Detailed per-document results. Each entry shows document_id, success status, and error message (if failed). Empty list when using filter mode (only counts returned)."
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Summary message of the operation",
            "default": "Batch delete completed"
          }
        },
        "type": "object",
        "required": [
          "deleted_count"
        ],
        "title": "BatchDeleteDocumentsResponse",
        "description": "Response model for batch document delete operation.\n\nProvides detailed per-document results showing success/failure for each deletion.",
        "examples": [
          {
            "deleted_count": 3,
            "failed_count": 0,
            "message": "Successfully deleted 3 document(s)",
            "results": [
              {
                "document_id": "doc_123",
                "success": true
              },
              {
                "document_id": "doc_456",
                "success": true
              },
              {
                "document_id": "doc_789",
                "success": true
              }
            ]
          }
        ]
      },
      "BatchDocumentDeleteResult": {
        "properties": {
          "document_id": {
            "type": "string",
            "title": "Document Id",
            "description": "Document ID that was deleted"
          },
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether the deletion succeeded"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Error message if deletion failed"
          }
        },
        "type": "object",
        "required": [
          "document_id",
          "success"
        ],
        "title": "BatchDocumentDeleteResult",
        "description": "Result of a single document deletion in a batch operation."
      },
      "BatchDocumentUpdate": {
        "properties": {
          "document_id": {
            "type": "string",
            "title": "Document Id",
            "description": "REQUIRED. Document ID to update. Must exist in the collection. Format: 'doc_' prefix + alphanumeric characters.",
            "examples": [
              "doc_abc123",
              "doc_frame_001"
            ]
          },
          "update_data": {
            "additionalProperties": true,
            "type": "object",
            "title": "Update Data",
            "description": "REQUIRED. Fields to update for this specific document. Can update any document field except vectors. Supported fields: metadata, internal_metadata, source_blobs, document_blobs, lineage fields (root_object_id, source_type, etc.), and any custom fields. Each document in the batch can have different update_data.",
            "examples": [
              {
                "metadata": {
                  "score": 0.95,
                  "status": "processed"
                }
              },
              {
                "internal_metadata": {
                  "reviewed": true
                },
                "metadata": {
                  "reviewer": "John"
                }
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "document_id",
          "update_data"
        ],
        "title": "BatchDocumentUpdate",
        "description": "Single document update specification for batch operations.\n\nRepresents one document's update within a batch request.",
        "examples": [
          {
            "document_id": "doc_abc123",
            "update_data": {
              "metadata": {
                "status": "processed"
              }
            }
          }
        ]
      },
      "BatchDocumentUpdateResult": {
        "properties": {
          "document_id": {
            "type": "string",
            "title": "Document Id",
            "description": "Document ID that was updated"
          },
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether the update succeeded"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Error message if update failed"
          }
        },
        "type": "object",
        "required": [
          "document_id",
          "success"
        ],
        "title": "BatchDocumentUpdateResult",
        "description": "Result of a single document update in a batch operation."
      },
      "BatchModel": {
        "properties": {
          "batch_id": {
            "type": "string",
            "title": "Batch Id",
            "description": "The unique identifier of the batch.",
            "examples": [
              "batch_123"
            ]
          },
          "bucket_id": {
            "type": "string",
            "title": "Bucket Id",
            "description": "The unique identifier of the bucket."
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "The current status of the batch.",
            "default": "DRAFT"
          },
          "object_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Object Ids",
            "description": "A list of object IDs included in the batch.",
            "examples": [
              [
                "object_123",
                "object_456"
              ]
            ]
          },
          "collection_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Collection Ids",
            "description": "A list of collection IDs that this batch is connected to for processing.",
            "examples": [
              [
                "col_123",
                "col_456"
              ]
            ]
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "The error message if the batch failed to process.",
            "examples": [
              "Failed to process batch: Object not found"
            ]
          },
          "type": {
            "$ref": "#/components/schemas/BatchType",
            "description": "The type of the batch.",
            "default": "BUCKET",
            "examples": [
              "BUCKET"
            ]
          },
          "manifest_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Manifest Key",
            "description": "The S3 manifest key for the batch.",
            "examples": [
              "s3://bucket/manifest.json"
            ]
          },
          "task_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Task Id",
            "description": "The task ID of the batch.",
            "examples": [
              "task_123"
            ]
          },
          "loaded_object_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Loaded Object Ids",
            "description": "A list of object IDs that were successfully loaded into the batch."
          },
          "internal_metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Internal Metadata",
            "description": "Internal engine/job metadata (e.g., job_id for provider)."
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional user-defined metadata for the batch."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp when the batch was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Timestamp when the batch was last updated."
          }
        },
        "type": "object",
        "required": [
          "bucket_id"
        ],
        "title": "BatchModel",
        "description": "The base model for a batch."
      },
      "BatchStatistics": {
        "properties": {
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of batches in this bucket",
            "default": 0
          },
          "active": {
            "type": "integer",
            "title": "Active",
            "description": "Number of batches that are not completed (DRAFT, PENDING, IN_PROGRESS, PROCESSING)",
            "default": 0
          },
          "completed": {
            "type": "integer",
            "title": "Completed",
            "description": "Number of completed batches",
            "default": 0
          },
          "failed": {
            "type": "integer",
            "title": "Failed",
            "description": "Number of failed batches",
            "default": 0
          }
        },
        "type": "object",
        "title": "BatchStatistics",
        "description": "Statistics about batches in a bucket."
      },
      "BatchType": {
        "type": "string",
        "enum": [
          "BUCKET",
          "COLLECTION"
        ],
        "title": "BatchType",
        "description": "The type of batch."
      },
      "BatchUpdateDocumentsRequest": {
        "properties": {
          "updates": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/BatchDocumentUpdate"
                },
                "type": "array",
                "maxItems": 1000,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Updates",
            "description": "OPTIONAL. List of document updates with explicit document IDs. Each entry specifies document_id and update_data. Use this mode when you know exact document IDs and want per-document control. Mutually exclusive with filters + update_data mode. Maximum 1000 documents per batch request.",
            "examples": [
              [
                {
                  "document_id": "doc_123",
                  "update_data": {
                    "metadata": {
                      "status": "processed"
                    }
                  }
                },
                {
                  "document_id": "doc_456",
                  "update_data": {
                    "metadata": {
                      "status": "archived"
                    }
                  }
                }
              ]
            ]
          },
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "OPTIONAL. Filter conditions to match documents for update. Must be used with 'update_data' field. Mutually exclusive with 'updates' array. If provided, applies same update_data to all matching documents."
          },
          "update_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Update Data",
            "description": "OPTIONAL. Update data to apply when using filters mode. Must be used with 'filters' field. All matched documents receive the same updates. Can update any document field except vectors."
          }
        },
        "type": "object",
        "title": "BatchUpdateDocumentsRequest",
        "description": "Request model for batch updating multiple documents by explicit IDs or filters.\n\nSupports TWO modes:\n1. Explicit IDs mode: Provide 'updates' array with document_id + update_data for each\n2. Filter mode: Provide 'filters' + 'update_data' to update all matching documents\n\nKey difference from BulkUpdateDocumentsRequest:\n- Batch (this): Can apply DIFFERENT updates to SPECIFIC documents by ID\n- Bulk: Applies SAME update to ALL documents matching filters\n\nUse Cases:\n    - Update 5 specific documents with different metadata values\n    - Update documents by IDs with per-document update control\n    - Combine with filters for targeted batch updates\n\nRequirements:\n    - EITHER 'updates' (explicit mode) OR 'filters' + 'update_data' (filter mode)\n    - NOT BOTH modes simultaneously",
        "examples": [
          {
            "description": "Explicit IDs mode: Update 3 documents with different values",
            "updates": [
              {
                "document_id": "doc_frame_001",
                "update_data": {
                  "metadata": {
                    "quality_score": 0.95,
                    "reviewed": true
                  }
                }
              },
              {
                "document_id": "doc_frame_002",
                "update_data": {
                  "metadata": {
                    "flagged": true,
                    "quality_score": 0.87
                  }
                }
              },
              {
                "document_id": "doc_frame_003",
                "update_data": {
                  "metadata": {
                    "discarded": true,
                    "quality_score": 0.72
                  }
                }
              }
            ]
          },
          {
            "description": "Filter mode: Update all pending documents",
            "filters": {
              "must": [
                {
                  "key": "metadata.status",
                  "value": "pending"
                }
              ]
            },
            "update_data": {
              "metadata": {
                "status": "processed"
              }
            }
          }
        ]
      },
      "BatchUpdateDocumentsResponse": {
        "properties": {
          "updated_count": {
            "type": "integer",
            "title": "Updated Count",
            "description": "Total number of documents successfully updated"
          },
          "failed_count": {
            "type": "integer",
            "title": "Failed Count",
            "description": "Total number of documents that failed to update",
            "default": 0
          },
          "results": {
            "items": {
              "$ref": "#/components/schemas/BatchDocumentUpdateResult"
            },
            "type": "array",
            "title": "Results",
            "description": "Detailed per-document results. Each entry shows document_id, success status, and error message (if failed). Empty list when using filter mode (only counts returned)."
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Summary message of the operation",
            "default": "Batch update completed"
          }
        },
        "type": "object",
        "required": [
          "updated_count"
        ],
        "title": "BatchUpdateDocumentsResponse",
        "description": "Response model for batch document update operation.\n\nProvides detailed per-document results showing success/failure for each update.",
        "examples": [
          {
            "failed_count": 0,
            "message": "Successfully updated 3 document(s)",
            "results": [
              {
                "document_id": "doc_123",
                "success": true
              },
              {
                "document_id": "doc_456",
                "success": true
              },
              {
                "document_id": "doc_789",
                "success": true
              }
            ],
            "updated_count": 3
          }
        ]
      },
      "BatchUploadRequest": {
        "properties": {
          "uploads": {
            "items": {
              "$ref": "#/components/schemas/CreateUploadRequest"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Uploads",
            "description": "List of upload requests (max 100)"
          },
          "shared_metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Shared Metadata",
            "description": "Metadata to apply to all uploads (merged with individual metadata)"
          },
          "shared_object_metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Shared Object Metadata",
            "description": "Object metadata to apply to all uploads (merged with individual)"
          }
        },
        "type": "object",
        "required": [
          "uploads"
        ],
        "title": "BatchUploadRequest",
        "description": "Request to generate multiple presigned URLs in a single request.",
        "examples": [
          {
            "shared_metadata": {
              "campaign": "summer_2024"
            },
            "shared_object_metadata": {
              "category": "marketing"
            },
            "uploads": [
              {
                "blob_property": "video",
                "content_type": "video/mp4",
                "filename": "video1.mp4"
              },
              {
                "blob_property": "thumbnail",
                "content_type": "image/jpeg",
                "filename": "thumbnail1.jpg"
              }
            ]
          }
        ]
      },
      "BatchUploadResponse": {
        "properties": {
          "uploads": {
            "items": {
              "$ref": "#/components/schemas/UploadResponse"
            },
            "type": "array",
            "title": "Uploads",
            "description": "Generated uploads with presigned URLs"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of uploads created"
          }
        },
        "type": "object",
        "required": [
          "uploads",
          "total"
        ],
        "title": "BatchUploadResponse",
        "description": "Response from batch upload request.",
        "examples": [
          {
            "total": 2,
            "uploads": [
              {
                "filename": "video1.mp4",
                "presigned_url": "https://s3.amazonaws.com/...",
                "status": "PENDING",
                "upload_id": "upl_abc123"
              }
            ]
          }
        ]
      },
      "BlobDetails": {
        "properties": {
          "filename": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Filename"
          },
          "size_bytes": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Size Bytes"
          },
          "mime_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mime Type"
          },
          "hash": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Hash"
          },
          "s3_object_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "S3 Object Key"
          }
        },
        "type": "object",
        "title": "BlobDetails",
        "description": "File details for a bucket object, these are automatically generated by the system."
      },
      "BlobModel": {
        "properties": {
          "blob_id": {
            "type": "string",
            "title": "Blob Id",
            "description": "Unique identifier for the blob",
            "examples": [
              "blob_a1b2c3d4e5f6"
            ]
          },
          "property": {
            "type": "string",
            "title": "Property",
            "description": "Property name of the blob",
            "examples": [
              "video",
              "thumbnail",
              "content"
            ]
          },
          "key_prefix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Key Prefix",
            "description": "Storage key/path of the blob, this will be used to retrieve the blob from the storage. It is similar to a file path. If not provided, it will be placed in the root of the bucket.",
            "examples": [
              "/videos/video.mp4",
              "/thumbnails/thumb.jpg"
            ]
          },
          "type": {
            "$ref": "#/components/schemas/BucketSchemaFieldType",
            "description": "The schema field type this blob corresponds to (e.g., IMAGE, PDF, DOCUMENT)",
            "examples": [
              "video",
              "image",
              "pdf",
              "text"
            ]
          },
          "properties": {
            "additionalProperties": true,
            "type": "object",
            "title": "Properties",
            "description": "All blob data and metadata unified (formerly separate 'data' and 'metadata' fields). Contains URLs, dimensions, metadata, and any other blob-specific information.",
            "examples": [
              {
                "author": "John Doe",
                "duration": 120,
                "resolution": "1920x1080",
                "tags": [
                  "product",
                  "demo"
                ],
                "url": "s3://bucket/video.mp4"
              }
            ]
          },
          "details": {
            "$ref": "#/components/schemas/BlobDetails",
            "description": "System-generated file details (filename, size, hash, etc.)"
          }
        },
        "type": "object",
        "required": [
          "property",
          "type"
        ],
        "title": "BlobModel",
        "description": "Model for a blob within a bucket object.\n\nBlobs store file references with a flat properties structure.\nAll blob-specific data (formerly in separate 'data' and 'metadata' fields)\nis now unified in a single 'properties' dictionary.\n\nExample:\n    {\n        \"blob_id\": \"blob_xyz123\",\n        \"property\": \"video\",\n        \"type\": \"video\",\n        \"properties\": {\n            \"url\": \"s3://bucket/video.mp4\",\n            \"duration\": 120,\n            \"resolution\": \"1920x1080\",\n            \"author\": \"John Doe\"  # All data unified here\n        }\n    }"
      },
      "BlobURLRef": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "Stable semantic label for the blob (e.g., 'thumbnail', 'source')."
          },
          "role": {
            "type": "string",
            "enum": [
              "source",
              "thumbnail",
              "artifact",
              "aux"
            ],
            "title": "Role",
            "description": "Semantic role of this blob",
            "default": "source"
          },
          "type": {
            "type": "string",
            "enum": [
              "video",
              "image",
              "audio",
              "text",
              "pdf",
              "other"
            ],
            "title": "Type",
            "description": "Schema/blob type",
            "default": "other"
          },
          "url": {
            "type": "string",
            "title": "Url",
            "description": "Canonical blob URL; s3:// URLs are presignable"
          },
          "object_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Key",
            "description": "S3 object key if available (no bucket prefix)"
          },
          "filename": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Filename",
            "description": "Leaf filename"
          },
          "size_bytes": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Size Bytes",
            "description": "Blob size in bytes"
          },
          "content_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Content Type",
            "description": "MIME content type"
          },
          "checksum": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Checksum",
            "description": "Optional checksum"
          },
          "created_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created At",
            "description": "Blob create time"
          },
          "source_blob_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Blob Id",
            "description": "Cross-reference to source blob in Mongo lineage"
          },
          "presigned_url": {
            "anyOf": [
              {
                "type": "string",
                "minLength": 1,
                "format": "uri"
              },
              {
                "type": "null"
              }
            ],
            "title": "Presigned Url",
            "description": "Response-only presigned https URL"
          }
        },
        "type": "object",
        "required": [
          "field",
          "url"
        ],
        "title": "BlobURLRef",
        "description": "Reference to a document-related blob (thumbnails, sources, artifacts).\n\nDevEx guidelines:\n- field: Use a stable, semantic label such as \"thumbnail\", \"source\", or a domain term.\n  Avoid leaking internal paths like \"metadata.thumbnail[0]\"; indexing (e.g., per-chunk)\n  should be inferred from filenames or stored separately (e.g., ordinal) if needed.\n- role: Determines behavior/UX grouping (thumbnail|source|artifact|aux). Prefer using role for UI.\n- url: Canonical locator. s3:// URLs are presignable via API when return_url=true.\n- presigned_url: Response-only, set by API to a time-limited https link."
      },
      "Body_stream_execution_data_v1_clusters__cluster_id__executions__run_id__data_post": {
        "properties": {
          "include_centroids": {
            "type": "boolean",
            "title": "Include Centroids",
            "description": "Include cluster centroids",
            "default": true
          },
          "include_members": {
            "type": "boolean",
            "title": "Include Members",
            "description": "Include cluster members",
            "default": false
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Offset for pagination",
            "default": 0
          },
          "limit": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Limit",
            "description": "Limit number of records"
          }
        },
        "type": "object",
        "title": "Body_stream_execution_data_v1_clusters__cluster_id__executions__run_id__data_post"
      },
      "BoolIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "bool"
          }
        },
        "type": "object",
        "title": "BoolIndexParams",
        "description": "Configuration for boolean index."
      },
      "BucketCreateRequest": {
        "properties": {
          "bucket_name": {
            "type": "string",
            "title": "Bucket Name",
            "description": "Human-readable name for the bucket"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the bucket"
          },
          "bucket_schema": {
            "$ref": "#/components/schemas/BucketSchema-Input",
            "description": "Schema definition for objects in this bucket (REQUIRED). Defines the custom fields your objects will have (blob properties, metadata structure, etc.)"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional metadata for the bucket"
          }
        },
        "type": "object",
        "required": [
          "bucket_name",
          "bucket_schema"
        ],
        "title": "BucketCreateRequest",
        "description": "Request model for creating a new bucket.\n\nREQUIRED: A bucket_schema must be defined to enable data processing and validation.\n\nThe bucket_schema tells the system what fields your objects will have, enabling:\n- Collections to map your data fields to feature extractors via input_mappings\n- Validation of object structure at upload time\n- Type-safe data pipelines from bucket \u2192 collection \u2192 retrieval\n\nEvery bucket must have a schema that defines the structure of objects it will contain.",
        "examples": [
          {
            "bucket_name": "product_images",
            "bucket_schema": {
              "properties": {
                "image": {
                  "description": "Product image blob",
                  "type": "image"
                },
                "metadata": {
                  "description": "Product information",
                  "properties": {
                    "title": {
                      "type": "string"
                    },
                    "category": {
                      "type": "string"
                    },
                    "price": {
                      "type": "float"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "Product images with metadata for e-commerce",
            "metadata": {
              "department": "Sales",
              "region": "US"
            }
          },
          {
            "bucket_name": "video_content",
            "bucket_schema": {
              "properties": {
                "video": {
                  "description": "Main video file",
                  "type": "video"
                },
                "transcript": {
                  "description": "Video transcript text",
                  "type": "text"
                },
                "thumbnail": {
                  "description": "Video thumbnail",
                  "type": "image"
                },
                "metadata": {
                  "properties": {
                    "duration_seconds": {
                      "type": "integer"
                    },
                    "title": {
                      "type": "string"
                    },
                    "tags": {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "Video files with transcripts and thumbnails",
            "metadata": {
              "content_type": "educational"
            }
          },
          {
            "bucket_name": "text_documents",
            "bucket_schema": {
              "properties": {
                "content": {
                  "description": "Main text content",
                  "type": "text"
                },
                "metadata": {
                  "properties": {
                    "title": {
                      "type": "string"
                    },
                    "author": {
                      "type": "string"
                    },
                    "published_date": {
                      "type": "datetime"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "Text documents for NLP processing"
          }
        ]
      },
      "BucketListStats": {
        "properties": {
          "total_objects": {
            "type": "integer",
            "title": "Total Objects",
            "description": "Total number of objects across all buckets",
            "default": 0
          },
          "total_size_bytes": {
            "type": "integer",
            "title": "Total Size Bytes",
            "description": "Total size in bytes across all buckets",
            "default": 0
          },
          "avg_objects_per_bucket": {
            "type": "number",
            "title": "Avg Objects Per Bucket",
            "description": "Average number of objects per bucket",
            "default": 0.0
          },
          "avg_size_per_bucket": {
            "type": "number",
            "title": "Avg Size Per Bucket",
            "description": "Average size in bytes per bucket",
            "default": 0.0
          }
        },
        "type": "object",
        "title": "BucketListStats",
        "description": "Aggregate statistics for a list of buckets."
      },
      "BucketPatchRequest": {
        "properties": {
          "bucket_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bucket Name",
            "description": "Human-readable name for the bucket"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the bucket"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Additional metadata for the bucket"
          }
        },
        "type": "object",
        "title": "BucketPatchRequest",
        "description": "Request model for partial update of an existing bucket (PATCH operation)."
      },
      "BucketResponse": {
        "properties": {
          "bucket_id": {
            "type": "string",
            "title": "Bucket Id",
            "description": "Unique identifier for the bucket"
          },
          "bucket_name": {
            "type": "string",
            "title": "Bucket Name",
            "description": "Human-readable name for the bucket"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the bucket"
          },
          "bucket_schema": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BucketSchema-Output"
              },
              {
                "type": "null"
              }
            ],
            "description": "Schema definition for objects in this bucket"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional metadata for the bucket"
          },
          "object_count": {
            "type": "integer",
            "title": "Object Count",
            "description": "Number of objects in the bucket"
          },
          "total_size_bytes": {
            "type": "integer",
            "title": "Total Size Bytes",
            "description": "Total size of all objects in the bucket in bytes"
          },
          "created_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created At",
            "description": "When the bucket was created"
          },
          "updated_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Updated At",
            "description": "Last modification time of bucket metadata"
          },
          "last_upload_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Upload At",
            "description": "When the last object was uploaded to this bucket"
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Bucket lifecycle status (ACTIVE, ARCHIVED, SUSPENDED, IN_PROGRESS for deleting)",
            "default": "ACTIVE"
          },
          "is_locked": {
            "type": "boolean",
            "title": "Is Locked",
            "description": "Whether the bucket is locked (read-only)",
            "default": false
          },
          "batch_stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BatchStatistics"
              },
              {
                "type": "null"
              }
            ],
            "description": "Batch statistics for this bucket (calculated asynchronously, stored in DB)"
          },
          "storage_stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StorageStatistics"
              },
              {
                "type": "null"
              }
            ],
            "description": "Storage statistics for this bucket (calculated asynchronously, stored in DB)"
          }
        },
        "type": "object",
        "required": [
          "bucket_name",
          "object_count",
          "total_size_bytes"
        ],
        "title": "BucketResponse",
        "description": "Response model for bucket operations."
      },
      "BucketSchema-Input": {
        "properties": {
          "properties": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Input"
            },
            "type": "object",
            "title": "Properties"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "properties"
        ],
        "title": "BucketSchema",
        "description": "Schema definition for bucket objects.\n\nIMPORTANT: The bucket schema defines what fields your bucket objects will have.\nThis schema is REQUIRED if you want to:\n1. Create collections that use input_mappings to process your bucket data\n2. Validate object structure before ingestion\n3. Enable type-safe data pipelines\n\nThe schema defines the custom fields that will be used in:\n- Blob properties (e.g., \"content\", \"thumbnail\", \"transcript\")\n- Object metadata structure\n- Blob data structures\n\nExample workflow:\n1. Create bucket WITH schema defining your data structure\n2. Upload objects that conform to that schema\n3. Create collections that map schema fields to feature extractors\n\nWithout a bucket_schema, collections cannot use input_mappings."
      },
      "BucketSchema-Output": {
        "properties": {
          "properties": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Output"
            },
            "type": "object",
            "title": "Properties"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "properties"
        ],
        "title": "BucketSchema",
        "description": "Schema definition for bucket objects.\n\nIMPORTANT: The bucket schema defines what fields your bucket objects will have.\nThis schema is REQUIRED if you want to:\n1. Create collections that use input_mappings to process your bucket data\n2. Validate object structure before ingestion\n3. Enable type-safe data pipelines\n\nThe schema defines the custom fields that will be used in:\n- Blob properties (e.g., \"content\", \"thumbnail\", \"transcript\")\n- Object metadata structure\n- Blob data structures\n\nExample workflow:\n1. Create bucket WITH schema defining your data structure\n2. Upload objects that conform to that schema\n3. Create collections that map schema fields to feature extractors\n\nWithout a bucket_schema, collections cannot use input_mappings."
      },
      "BucketSchemaField-Input": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/BucketSchemaFieldType"
          },
          "default": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "title": "Default"
          },
          "items": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BucketSchemaField-Input"
              },
              {
                "type": "null"
              }
            ]
          },
          "properties": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/BucketSchemaField-Input"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Properties"
          },
          "example": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "title": "Example"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "enum": {
            "anyOf": [
              {
                "items": {},
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enum"
          },
          "required": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required",
            "default": false
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "type"
        ],
        "title": "BucketSchemaField",
        "description": "Schema field definition for bucket objects."
      },
      "BucketSchemaField-Output": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/BucketSchemaFieldType"
          },
          "default": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "title": "Default"
          },
          "items": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BucketSchemaField-Output"
              },
              {
                "type": "null"
              }
            ]
          },
          "properties": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/BucketSchemaField-Output"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Properties"
          },
          "example": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "title": "Example"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "enum": {
            "anyOf": [
              {
                "items": {},
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enum"
          },
          "required": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required",
            "default": false
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "type"
        ],
        "title": "BucketSchemaField",
        "description": "Schema field definition for bucket objects."
      },
      "BucketSchemaFieldType": {
        "type": "string",
        "enum": [
          "string",
          "number",
          "integer",
          "float",
          "boolean",
          "object",
          "array",
          "date",
          "datetime",
          "json",
          "file",
          "text",
          "image",
          "audio",
          "video",
          "pdf",
          "document",
          "spreadsheet",
          "presentation",
          "dense_vector",
          "sparse_vector",
          "int8_vector"
        ],
        "title": "BucketSchemaFieldType",
        "description": "Enum for field types in bucket schemas."
      },
      "BucketUpdateRequest": {
        "properties": {
          "bucket_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Bucket Name",
            "description": "Human-readable name for the bucket"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the bucket"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Additional metadata for the bucket"
          }
        },
        "type": "object",
        "title": "BucketUpdateRequest",
        "description": "Request model for updating an existing bucket."
      },
      "BudgetLimits": {
        "properties": {
          "max_credits": {
            "anyOf": [
              {
                "type": "number",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Credits",
            "description": "Maximum credits allowed for a single execution (OPTIONAL)."
          },
          "max_time_ms": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Time Ms",
            "description": "Maximum wall-clock time in milliseconds before forcing halt (OPTIONAL)."
          }
        },
        "type": "object",
        "title": "BudgetLimits",
        "description": "User-defined limits for time and credits during execution.",
        "examples": [
          {
            "max_credits": 100.0,
            "max_time_ms": 60000
          },
          {
            "max_time_ms": 120000
          }
        ]
      },
      "BulkUpdateDocumentsRequest": {
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "OPTIONAL. Filter conditions to match documents for update. If not provided, updates ALL documents in the collection. Supports complex logical operators (AND, OR, NOT). Example: {'must': [{'key': 'metadata.status', 'value': 'pending'}]}",
            "examples": [
              {
                "must": [
                  {
                    "key": "metadata.status",
                    "value": "pending"
                  }
                ]
              },
              {
                "must": [
                  {
                    "gt": "2024-01-01",
                    "key": "metadata.created_at"
                  }
                ]
              }
            ]
          },
          "update_data": {
            "additionalProperties": true,
            "type": "object",
            "title": "Update Data",
            "description": "REQUIRED. Dictionary of field-value pairs to update on ALL matching documents. Can update any document field except vectors (metadata, internal_metadata, source_blobs, etc.). All matched documents receive the SAME updates. Example: {'metadata.status': 'processed', 'metadata.reviewed': true}",
            "examples": [
              {
                "metadata": {
                  "reviewed": true,
                  "status": "processed"
                }
              },
              {
                "internal_metadata.processing_complete": true
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "update_data"
        ],
        "title": "BulkUpdateDocumentsRequest",
        "description": "Request model for bulk updating documents by filters.\n\nUpdates ALL documents matching the provided filters with the SAME update_data.\nFor updating specific documents by ID or different values per document, use BatchUpdateDocumentsRequest.\n\nUse Cases:\n    - Update all pending documents to processed\n    - Update all documents from a specific date range\n    - Apply uniform changes across filtered document sets\n\nRequirements:\n    - update_data: REQUIRED - fields to update on all matching documents\n    - filters: OPTIONAL - if omitted, updates ALL documents in collection",
        "examples": [
          {
            "description": "Update all pending documents to processed",
            "filters": {
              "must": [
                {
                  "key": "metadata.status",
                  "value": "pending"
                }
              ]
            },
            "update_data": {
              "metadata": {
                "status": "processed"
              }
            }
          },
          {
            "description": "Update all documents in collection (no filters)",
            "update_data": {
              "internal_metadata": {
                "version": 2
              }
            }
          }
        ]
      },
      "BulkUpdateDocumentsResponse": {
        "properties": {
          "updated_count": {
            "type": "integer",
            "title": "Updated Count",
            "description": "Number of documents that were updated."
          },
          "message": {
            "type": "string",
            "title": "Message",
            "default": "Documents updated successfully"
          }
        },
        "type": "object",
        "required": [
          "updated_count"
        ],
        "title": "BulkUpdateDocumentsResponse",
        "description": "Response model for bulk document update operation."
      },
      "CORSConfigurationInfo": {
        "properties": {
          "bucket": {
            "type": "string",
            "title": "Bucket",
            "description": "The object storage bucket name"
          },
          "has_cors": {
            "type": "boolean",
            "title": "Has Cors",
            "description": "Whether CORS is currently configured on the bucket"
          },
          "cors_rules": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cors Rules",
            "description": "The current CORS rules (if configured)"
          }
        },
        "type": "object",
        "required": [
          "bucket",
          "has_cors"
        ],
        "title": "CORSConfigurationInfo",
        "description": "Current CORS configuration information."
      },
      "CORSConfigurationResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether the CORS configuration was successful"
          },
          "bucket": {
            "type": "string",
            "title": "Bucket",
            "description": "The object storage bucket name where CORS was configured"
          },
          "applied_configuration": {
            "additionalProperties": true,
            "type": "object",
            "title": "Applied Configuration",
            "description": "The CORS configuration that was applied to the bucket"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable status message"
          }
        },
        "type": "object",
        "required": [
          "success",
          "bucket",
          "applied_configuration",
          "message"
        ],
        "title": "CORSConfigurationResponse",
        "description": "Response model for CORS configuration operations."
      },
      "CacheConfig": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether caching is enabled for this retriever",
            "default": true
          },
          "ttl_seconds": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Ttl Seconds",
            "description": "Time-to-live for cached results in seconds. Default: 1 hour",
            "default": 3600
          },
          "cache_stage_names": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cache Stage Names",
            "description": "List of stage names to cache results after. Stage names must match the stage_name field in the retriever's stages. If not specified, caches the final results after all stages. Examples: ['semantic_search'], ['semantic_search', 'rerank']"
          },
          "exclude_fields": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Exclude Fields",
            "description": "Fields to exclude from caching (e.g., PII fields)"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CacheStatistics"
              },
              {
                "type": "null"
              }
            ],
            "description": "Cache performance statistics"
          }
        },
        "type": "object",
        "title": "CacheConfig",
        "description": "Configuration for retriever result caching.\n\nControls how retriever results are cached to improve performance\nand reduce redundant compute.\n\nCaching can be configured at specific stages in the retriever pipeline.\nIf no stages are specified, the final results are cached by default."
      },
      "CachePerformanceResponse": {
        "properties": {
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "Retriever identifier"
          },
          "time_range": {
            "$ref": "#/components/schemas/TimeRange",
            "description": "Time range"
          },
          "cache_hit_rate": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Cache Hit Rate",
            "description": "Overall cache hit rate"
          },
          "total_cache_hits": {
            "type": "integer",
            "title": "Total Cache Hits",
            "description": "Total cache hits"
          },
          "total_cache_misses": {
            "type": "integer",
            "title": "Total Cache Misses",
            "description": "Total cache misses"
          },
          "avg_cache_hit_latency_ms": {
            "type": "number",
            "title": "Avg Cache Hit Latency Ms",
            "description": "Average latency on cache hit"
          },
          "avg_cache_miss_latency_ms": {
            "type": "number",
            "title": "Avg Cache Miss Latency Ms",
            "description": "Average latency on cache miss"
          },
          "hourly_breakdown": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Hourly Breakdown",
            "description": "Hourly cache performance"
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "time_range",
          "cache_hit_rate",
          "total_cache_hits",
          "total_cache_misses",
          "avg_cache_hit_latency_ms",
          "avg_cache_miss_latency_ms",
          "hourly_breakdown"
        ],
        "title": "CachePerformanceResponse",
        "description": "Cache performance metrics.",
        "examples": [
          {
            "avg_cache_hit_latency_ms": 5.2,
            "avg_cache_miss_latency_ms": 145.8,
            "cache_hit_rate": 0.78,
            "hourly_breakdown": [
              {
                "hit_rate": 0.78,
                "hits": 145,
                "hour": "2025-10-28T10:00:00Z",
                "misses": 42
              }
            ],
            "retriever_id": "ret_abc123",
            "time_range": {
              "end": "2025-10-29T00:00:00Z",
              "start": "2025-10-28T00:00:00Z"
            },
            "total_cache_hits": 3456,
            "total_cache_misses": 978
          }
        ]
      },
      "CacheStatistics": {
        "properties": {
          "hit_count": {
            "type": "integer",
            "title": "Hit Count",
            "description": "Number of cache hits",
            "default": 0
          },
          "miss_count": {
            "type": "integer",
            "title": "Miss Count",
            "description": "Number of cache misses",
            "default": 0
          },
          "hit_rate": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Hit Rate",
            "description": "Cache hit rate (0.0 - 1.0)",
            "default": 0.0
          },
          "size_bytes": {
            "type": "integer",
            "title": "Size Bytes",
            "description": "Total size of cached data in bytes",
            "default": 0
          },
          "entry_count": {
            "type": "integer",
            "title": "Entry Count",
            "description": "Number of entries in cache",
            "default": 0
          },
          "last_invalidated_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Invalidated At",
            "description": "When the cache was last invalidated"
          }
        },
        "type": "object",
        "title": "CacheStatistics",
        "description": "Statistics about cache performance."
      },
      "ClusterCentroid": {
        "properties": {
          "cluster_id": {
            "type": "string",
            "title": "Cluster Id",
            "description": "Unique identifier for the cluster"
          },
          "centroid_vector": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Centroid Vector",
            "description": "Feature vector representing the cluster center"
          },
          "feature_name": {
            "type": "string",
            "title": "Feature Name",
            "description": "Name of the feature this centroid represents"
          },
          "feature_dimensions": {
            "type": "integer",
            "title": "Feature Dimensions",
            "description": "Dimensionality of the feature vector"
          },
          "num_members": {
            "type": "integer",
            "title": "Num Members",
            "description": "Number of points in this cluster",
            "default": 0
          },
          "variance": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Variance",
            "description": "Variance/spread of the cluster"
          },
          "label": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Label",
            "description": "Human-readable label for the cluster"
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Summary",
            "description": "Brief summary of cluster contents"
          },
          "keywords": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Keywords",
            "description": "Keywords describing the cluster"
          },
          "effective_features": {
            "additionalProperties": true,
            "type": "object",
            "title": "Effective Features",
            "description": "Aggregated features from cluster members"
          },
          "feature_statistics": {
            "additionalProperties": {
              "additionalProperties": {
                "type": "number"
              },
              "type": "object"
            },
            "type": "object",
            "title": "Feature Statistics",
            "description": "Statistics for each feature (mean, std, min, max)"
          },
          "parent_cluster_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parent Cluster Id",
            "description": "Parent cluster for hierarchical clustering"
          },
          "child_cluster_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Child Cluster Ids",
            "description": "Child clusters"
          },
          "hierarchy_level": {
            "type": "integer",
            "title": "Hierarchy Level",
            "description": "Level in hierarchy (0 = root)",
            "default": 0
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional cluster metadata"
          }
        },
        "type": "object",
        "required": [
          "cluster_id",
          "centroid_vector",
          "feature_name",
          "feature_dimensions"
        ],
        "title": "ClusterCentroid",
        "description": "Represents a cluster centroid with its feature vector and labels.",
        "examples": [
          {
            "centroid_vector": [
              0.1,
              0.2,
              0.3
            ],
            "cluster_id": "cluster_001",
            "feature_dimensions": 512,
            "num_members": 150,
            "variance": 0.05,
            "vector_name": "face_embedding"
          }
        ]
      },
      "ClusterCentroidData": {
        "properties": {
          "cluster_label": {
            "type": "string",
            "title": "Cluster Label",
            "description": "Cluster identifier/label"
          },
          "centroid_vector": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Centroid Vector",
            "description": "Centroid feature vector"
          },
          "num_members": {
            "type": "integer",
            "title": "Num Members",
            "description": "Number of members in cluster"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional metadata"
          }
        },
        "type": "object",
        "required": [
          "cluster_label",
          "centroid_vector",
          "num_members"
        ],
        "title": "ClusterCentroidData",
        "description": "Data for a single cluster centroid."
      },
      "ClusterDataRequest": {
        "properties": {
          "cluster_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cluster Id",
            "description": "Cluster ID to fetch data for"
          },
          "include_centroids": {
            "type": "boolean",
            "title": "Include Centroids",
            "description": "Include cluster centroids",
            "default": true
          },
          "include_members": {
            "type": "boolean",
            "title": "Include Members",
            "description": "Include cluster members",
            "default": false
          },
          "limit": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Limit",
            "description": "Limit number of records"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Offset for pagination",
            "default": 0
          }
        },
        "type": "object",
        "title": "ClusterDataRequest",
        "description": "Request to stream cluster data from parquet files.",
        "examples": [
          {
            "cluster_id": "cl_123",
            "include_centroids": true,
            "include_members": true,
            "limit": 100,
            "offset": 0
          }
        ]
      },
      "ClusterDataResponse": {
        "properties": {
          "cluster_id": {
            "type": "string",
            "title": "Cluster Id"
          },
          "centroids": {
            "items": {
              "$ref": "#/components/schemas/ClusterCentroidData"
            },
            "type": "array",
            "title": "Centroids"
          },
          "members": {
            "items": {
              "$ref": "#/components/schemas/ClusterMemberData"
            },
            "type": "array",
            "title": "Members"
          },
          "total_clusters": {
            "type": "integer",
            "title": "Total Clusters"
          },
          "total_members": {
            "type": "integer",
            "title": "Total Members"
          }
        },
        "type": "object",
        "required": [
          "cluster_id",
          "total_clusters",
          "total_members"
        ],
        "title": "ClusterDataResponse",
        "description": "Response with cluster data from parquet."
      },
      "ClusterExecutionCentroid": {
        "properties": {
          "cluster_id": {
            "type": "string",
            "title": "Cluster Id",
            "description": "Internal cluster identifier"
          },
          "num_members": {
            "type": "integer",
            "title": "Num Members",
            "description": "Number of points in this cluster"
          },
          "label": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Label",
            "description": "LLM-generated label"
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Summary",
            "description": "LLM-generated summary"
          },
          "keywords": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Keywords",
            "description": "LLM-generated keywords"
          }
        },
        "type": "object",
        "required": [
          "cluster_id",
          "num_members"
        ],
        "title": "ClusterExecutionCentroid",
        "description": "Centroid information from an execution result."
      },
      "ClusterExecutionListStats": {
        "properties": {
          "total_executions": {
            "type": "integer",
            "title": "Total Executions",
            "description": "Total number of executions in the result",
            "default": 0
          },
          "executions_by_status": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Executions By Status",
            "description": "Count of executions grouped by status"
          },
          "avg_execution_time_ms": {
            "type": "number",
            "title": "Avg Execution Time Ms",
            "description": "Average execution time in milliseconds",
            "default": 0.0
          },
          "total_documents_clustered": {
            "type": "integer",
            "title": "Total Documents Clustered",
            "description": "Total documents clustered across all executions",
            "default": 0
          },
          "avg_num_clusters": {
            "type": "number",
            "title": "Avg Num Clusters",
            "description": "Average number of clusters per execution",
            "default": 0.0
          }
        },
        "type": "object",
        "title": "ClusterExecutionListStats",
        "description": "Aggregate statistics for cluster execution history."
      },
      "ClusterExecutionMetrics": {
        "properties": {
          "silhouette_score": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Silhouette Score",
            "description": "Silhouette score (-1 to 1, higher is better)"
          },
          "davies_bouldin_index": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Davies Bouldin Index",
            "description": "Davies-Bouldin index (lower is better)"
          },
          "calinski_harabasz_score": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Calinski Harabasz Score",
            "description": "Calinski-Harabasz score (higher is better)"
          }
        },
        "type": "object",
        "title": "ClusterExecutionMetrics",
        "description": "Quality metrics for a clustering execution."
      },
      "ClusterExecutionResult": {
        "properties": {
          "run_id": {
            "type": "string",
            "title": "Run Id",
            "description": "Unique identifier for this clustering run"
          },
          "cluster_id": {
            "type": "string",
            "title": "Cluster Id",
            "description": "Parent cluster ID"
          },
          "status": {
            "type": "string",
            "enum": [
              "pending",
              "processing",
              "completed",
              "failed"
            ],
            "title": "Status",
            "description": "Execution status"
          },
          "num_clusters": {
            "type": "integer",
            "title": "Num Clusters",
            "description": "Number of clusters found"
          },
          "num_points": {
            "type": "integer",
            "title": "Num Points",
            "description": "Total documents/points clustered"
          },
          "metrics": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ClusterExecutionMetrics"
              },
              {
                "type": "null"
              }
            ],
            "description": "Quality metrics"
          },
          "centroids": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/ClusterExecutionCentroid"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Centroids",
            "description": "Centroid information"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "When execution started"
          },
          "completed_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completed At",
            "description": "When execution completed"
          },
          "error_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error Message",
            "description": "Error message if failed"
          }
        },
        "type": "object",
        "required": [
          "run_id",
          "cluster_id",
          "status",
          "num_clusters",
          "num_points",
          "created_at"
        ],
        "title": "ClusterExecutionResult",
        "description": "Results of the most recent clustering execution for a cluster."
      },
      "ClusterListStats": {
        "properties": {
          "total_clusters": {
            "type": "integer",
            "title": "Total Clusters",
            "description": "Total number of clusters in the result",
            "default": 0
          },
          "total_documents": {
            "type": "integer",
            "title": "Total Documents",
            "description": "Total number of documents across all clusters",
            "default": 0
          },
          "avg_documents_per_cluster": {
            "type": "number",
            "title": "Avg Documents Per Cluster",
            "description": "Average number of documents per cluster",
            "default": 0.0
          },
          "clusters_by_status": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Clusters By Status",
            "description": "Count of clusters grouped by status"
          }
        },
        "type": "object",
        "title": "ClusterListStats",
        "description": "Aggregate statistics for a list of clusters."
      },
      "ClusterMemberData": {
        "properties": {
          "document_id": {
            "type": "string",
            "title": "Document Id",
            "description": "Document ID"
          },
          "cluster_label": {
            "type": "string",
            "title": "Cluster Label",
            "description": "Assigned cluster"
          },
          "distance_to_centroid": {
            "type": "number",
            "title": "Distance To Centroid",
            "description": "Distance to cluster center"
          },
          "coordinates": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Coordinates",
            "description": "Feature vector/coordinates in clustering space"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Document metadata"
          }
        },
        "type": "object",
        "required": [
          "document_id",
          "cluster_label",
          "distance_to_centroid",
          "coordinates"
        ],
        "title": "ClusterMemberData",
        "description": "Data for a cluster member."
      },
      "ClusterModel": {
        "properties": {
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Collection Ids",
            "description": "Collections to cluster together"
          },
          "cluster_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cluster Name",
            "description": "Optional human-friendly name for the clustering job"
          },
          "cluster_type": {
            "$ref": "#/components/schemas/ClusterType",
            "description": "Vector or attribute clustering",
            "default": "vector"
          },
          "vector_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VectorBasedConfig"
              },
              {
                "type": "null"
              }
            ],
            "description": "Required when cluster_type is 'vector'"
          },
          "attribute_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AttributeBasedConfig"
              },
              {
                "type": "null"
              }
            ],
            "description": "Required when cluster_type is 'attribute'"
          },
          "llm_labeling": {
            "$ref": "#/components/schemas/LLMLabeling",
            "description": "Configuration for LLM-based cluster labeling"
          },
          "cluster_id": {
            "type": "string",
            "title": "Cluster Id",
            "description": "Unique cluster identifier"
          },
          "parquet_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parquet Path",
            "description": "S3 path to parquet files with cluster data"
          },
          "members_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Members Key",
            "description": "S3 key to members.parquet (if saved)"
          },
          "num_clusters": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Num Clusters",
            "description": "Number of clusters found"
          },
          "cluster_stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ClusterStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Clustering quality metrics"
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Clustering job status",
            "default": "PENDING"
          },
          "task_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Task Id",
            "description": "Associated task ID for clustering job"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "When the cluster was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "When the cluster was last updated"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional user-defined metadata for the cluster"
          }
        },
        "type": "object",
        "required": [
          "collection_ids"
        ],
        "title": "ClusterModel",
        "description": "Cluster metadata stored in MongoDB.",
        "examples": [
          {
            "cluster_name": "products_clip_hdbscan",
            "cluster_type": "vector",
            "collection_ids": [
              "col_products_v1",
              "col_products_v2"
            ],
            "llm_labeling": {
              "enabled": true,
              "model_name": "gpt-4"
            },
            "vector_config": {
              "clustering_method": "hdbscan",
              "feature_extractor_name": "clip_vit_l_14",
              "hdbscan_parameters": {
                "min_cluster_size": 10,
                "min_samples": 5
              },
              "sample_size": 5000
            }
          },
          {
            "attribute_config": {
              "attributes": [
                "status"
              ],
              "hierarchical_grouping": true
            },
            "cluster_name": "orders_group_by_status",
            "cluster_type": "attribute",
            "collection_ids": [
              "col_orders_v1",
              "col_orders_v2",
              "col_orders_v3"
            ]
          }
        ]
      },
      "ClusterStats": {
        "properties": {
          "num_clusters": {
            "type": "integer",
            "title": "Num Clusters"
          },
          "noise_points": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Noise Points",
            "description": "Number of noise points (for DBSCAN, etc.)"
          },
          "silhouette_score": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Silhouette Score",
            "description": "Silhouette score (-1 to 1, higher is better)"
          },
          "extra": {
            "additionalProperties": true,
            "type": "object",
            "title": "Extra"
          }
        },
        "type": "object",
        "required": [
          "num_clusters"
        ],
        "title": "ClusterStats",
        "description": "Basic clustering quality metrics."
      },
      "ClusterType": {
        "type": "string",
        "enum": [
          "vector",
          "attribute"
        ],
        "title": "ClusterType",
        "description": "Type of clustering to perform.\n\nDetermines the clustering approach:\n- vector: Cluster documents by embedding similarity (semantic clustering)\n- attribute: Cluster documents by metadata attributes (business logic clustering)\n\nUse Cases:\n    vector:\n        - Group semantically similar content\n        - Find content with similar meaning\n        - Organize by topic/theme\n        - Requires vector embeddings\n\n    attribute:\n        - Group by business attributes (category, brand, status, etc.)\n        - Organize by explicit metadata\n        - Create hierarchical groupings\n        - No embeddings required"
      },
      "ClusteringAlgorithm": {
        "type": "string",
        "enum": [
          "kmeans",
          "dbscan",
          "hdbscan",
          "agglomerative",
          "spectral",
          "gaussian_mixture",
          "mean_shift",
          "optics",
          "attribute_based"
        ],
        "title": "ClusteringAlgorithm",
        "description": "Supported clustering algorithms.\n\nTwo types of clustering are available:\n1. Vector-based: Clusters documents by embedding similarity\n2. Attribute-based: Clusters documents by metadata attributes\n\nVector-based algorithms (require feature_vector):\n    - kmeans: Partitions data into K clusters by minimizing within-cluster variance\n    - dbscan: Density-based clustering, finds clusters of arbitrary shape\n    - hdbscan: Hierarchical DBSCAN, auto-determines number of clusters\n    - agglomerative: Hierarchical clustering using linkage criteria\n    - spectral: Uses graph theory to find clusters\n    - gaussian_mixture: Probabilistic model assuming Gaussian distributions\n    - mean_shift: Finds clusters by locating density maxima\n    - optics: Ordering points to identify clustering structure\n\nAttribute-based algorithm (requires attribute_config):\n    - attribute_based: Groups documents by metadata attributes (e.g., category, brand)"
      },
      "ClusteringConfig": {
        "properties": {
          "algorithm": {
            "$ref": "#/components/schemas/ClusteringAlgorithm",
            "description": "Clustering algorithm to use. Vector-based algorithms (kmeans, dbscan, hdbscan, etc.) require feature_vector. Attribute-based algorithm (attribute_based) requires attribute_config.",
            "examples": [
              "kmeans",
              "dbscan",
              "hdbscan",
              "attribute_based"
            ]
          },
          "algorithm_params": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/KMeansParams"
              },
              {
                "$ref": "#/components/schemas/DBSCANParams"
              },
              {
                "$ref": "#/components/schemas/HDBSCANParams"
              },
              {
                "$ref": "#/components/schemas/AgglomerativeParams"
              },
              {
                "$ref": "#/components/schemas/SpectralParams"
              },
              {
                "$ref": "#/components/schemas/GaussianMixtureParams"
              },
              {
                "$ref": "#/components/schemas/MeanShiftParams"
              },
              {
                "$ref": "#/components/schemas/OPTICSParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Algorithm Params",
            "description": "Algorithm-specific parameters for vector-based clustering. Not used for attribute-based clustering. See individual algorithm parameter models for available options."
          },
          "feature_vector": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeatureVectorRef"
              },
              {
                "type": "null"
              }
            ],
            "description": "Reference to the vector embedding to use for vector-based clustering. REQUIRED for vector-based algorithms (kmeans, dbscan, etc.). NOT REQUIRED for attribute-based clustering. Use canonical feature address format: mixpeek://{extractor}@{version}/{output}",
            "examples": [
              {
                "feature_address": "mixpeek://text_extractor@v1/text_extractor_v1_embedding"
              }
            ]
          },
          "attribute_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AttributeBasedConfig"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configuration for attribute-based clustering. REQUIRED when algorithm='attribute_based'. NOT USED for vector-based algorithms. Defines which metadata attributes to group documents by.",
            "examples": [
              {
                "attributes": [
                  "category"
                ],
                "hierarchical_grouping": false
              },
              {
                "attributes": [
                  "category",
                  "brand"
                ],
                "hierarchical_grouping": true
              }
            ]
          },
          "additional_features": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Additional Features",
            "description": "Additional features for multi-modal clustering"
          },
          "normalize_features": {
            "type": "boolean",
            "title": "Normalize Features",
            "description": "Whether to normalize features before clustering",
            "default": true
          },
          "dimensionality_reduction": {
            "anyOf": [
              {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/TSNEParams"
                  },
                  {
                    "$ref": "#/components/schemas/UMAPParams"
                  },
                  {
                    "$ref": "#/components/schemas/NoReduction"
                  }
                ],
                "discriminator": {
                  "propertyName": "method",
                  "mapping": {
                    "none": "#/components/schemas/NoReduction",
                    "tsne": "#/components/schemas/TSNEParams",
                    "umap": "#/components/schemas/UMAPParams"
                  }
                }
              },
              {
                "type": "null"
              }
            ],
            "title": "Dimensionality Reduction",
            "description": "Optional dimensionality reduction prior to clustering"
          },
          "hierarchical": {
            "type": "boolean",
            "title": "Hierarchical",
            "description": "Whether to create hierarchical clusters",
            "default": false
          },
          "max_hierarchy_depth": {
            "type": "integer",
            "title": "Max Hierarchy Depth",
            "description": "Maximum depth for hierarchical clustering",
            "default": 3
          },
          "llm_labeling": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LLMLabeling"
              },
              {
                "type": "null"
              }
            ],
            "description": "Configuration for LLM-based labeling"
          },
          "batch_size": {
            "type": "integer",
            "title": "Batch Size",
            "description": "Batch size for processing",
            "default": 1000
          },
          "parallelism": {
            "type": "integer",
            "title": "Parallelism",
            "description": "Number of parallel workers",
            "default": 4
          },
          "sample_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sample Size",
            "description": "Sample size for large collections"
          }
        },
        "type": "object",
        "required": [
          "algorithm"
        ],
        "title": "ClusteringConfig",
        "description": "Complete configuration for clustering operation.\n\nSupports two types of clustering:\n1. Vector-based: Groups documents by embedding similarity (requires feature_vector)\n2. Attribute-based: Groups documents by metadata attributes (requires attribute_config)\n\nThe algorithm field determines which type:\n- Vector algorithms: kmeans, dbscan, hdbscan, agglomerative, spectral, gaussian_mixture, mean_shift, optics\n- Attribute algorithm: attribute_based",
        "examples": [
          {
            "algorithm": "kmeans",
            "algorithm_params": {
              "max_iter": 300,
              "n_clusters": 5,
              "random_state": 42
            },
            "description": "Vector-based clustering with K-means",
            "feature_vector": {
              "feature_address": "mixpeek://text_extractor@v1/text_extractor_v1_embedding"
            },
            "llm_labeling": {
              "enabled": true,
              "model_name": "gpt-4o-mini",
              "provider": "openai"
            },
            "normalize_features": true
          },
          {
            "algorithm": "hdbscan",
            "algorithm_params": {
              "min_cluster_size": 10,
              "min_samples": 5
            },
            "description": "Vector-based clustering with HDBSCAN",
            "feature_vector": {
              "feature_address": "mixpeek://image_extractor@v1/image_extractor_v1_embedding"
            },
            "normalize_features": false
          },
          {
            "algorithm": "attribute_based",
            "attribute_config": {
              "attributes": [
                "category"
              ],
              "hierarchical_grouping": false
            },
            "description": "Attribute-based clustering (simple category)",
            "llm_labeling": {
              "enabled": true,
              "include_keywords": true,
              "include_summary": true,
              "provider": "openai"
            }
          },
          {
            "algorithm": "attribute_based",
            "attribute_config": {
              "aggregation_method": "most_frequent",
              "attributes": [
                "category",
                "brand"
              ],
              "hierarchical_grouping": true
            },
            "description": "Attribute-based clustering (hierarchical category \u2192 brand)"
          },
          {
            "algorithm": "attribute_based",
            "attribute_config": {
              "attributes": [
                "metadata.status",
                "metadata.priority"
              ],
              "hierarchical_grouping": false
            },
            "description": "Attribute-based clustering (nested attributes)"
          }
        ]
      },
      "ClusteringEnrichmentResponse": {
        "properties": {
          "processed": {
            "type": "integer",
            "title": "Processed",
            "description": "Number of processed points"
          },
          "enriched": {
            "type": "integer",
            "title": "Enriched",
            "description": "Number of enriched points"
          },
          "failed": {
            "type": "integer",
            "title": "Failed",
            "description": "Number of failed points"
          },
          "batches": {
            "type": "integer",
            "title": "Batches",
            "description": "Batches processed"
          }
        },
        "type": "object",
        "required": [
          "processed",
          "enriched",
          "failed",
          "batches"
        ],
        "title": "ClusteringEnrichmentResponse",
        "description": "Response after applying clustering enrichment."
      },
      "CollectionDetail": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "Collection identifier"
          },
          "collection_name": {
            "type": "string",
            "title": "Collection Name",
            "description": "Human-readable collection name"
          },
          "document_count": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Document Count",
            "description": "Number of documents in the collection"
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enabled",
            "description": "Whether the collection is active"
          },
          "last_indexed_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Indexed At",
            "description": "When the collection was last indexed"
          }
        },
        "type": "object",
        "required": [
          "collection_id",
          "collection_name"
        ],
        "title": "CollectionDetail",
        "description": "Detailed information about a collection referenced by a retriever."
      },
      "CollectionFeatureDescriptor": {
        "properties": {
          "feature_address": {
            "type": "string",
            "title": "Feature Address",
            "description": "Fully qualified feature address"
          },
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Extractor name"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Extractor version"
          },
          "vector_index": {
            "$ref": "#/components/schemas/VectorIndex",
            "description": "Vector index configuration (name, dimensions, type, distance, inference_name)"
          },
          "primary": {
            "type": "boolean",
            "title": "Primary",
            "description": "True if this is the primary output (short address allowed)",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "feature_address",
          "feature_extractor_name",
          "version",
          "vector_index"
        ],
        "title": "CollectionFeatureDescriptor",
        "description": "Descriptor for a collection's available feature using existing models/keys."
      },
      "CollectionListStats": {
        "properties": {
          "total_documents": {
            "type": "integer",
            "title": "Total Documents",
            "description": "Total number of documents across all collections",
            "default": 0
          },
          "avg_documents_per_collection": {
            "type": "number",
            "title": "Avg Documents Per Collection",
            "description": "Average number of documents per collection",
            "default": 0.0
          },
          "collections_with_taxonomies": {
            "type": "integer",
            "title": "Collections With Taxonomies",
            "description": "Number of collections with taxonomy applications",
            "default": 0
          },
          "total_feature_extractors": {
            "type": "integer",
            "title": "Total Feature Extractors",
            "description": "Total number of feature extractors across all collections",
            "default": 0
          },
          "total_taxonomies": {
            "type": "integer",
            "title": "Total Taxonomies",
            "description": "Total number of taxonomy connections across all collections",
            "default": 0
          },
          "total_retrievers": {
            "type": "integer",
            "title": "Total Retrievers",
            "description": "Total number of retriever connections across all collections",
            "default": 0
          }
        },
        "type": "object",
        "title": "CollectionListStats",
        "description": "Aggregate statistics for a list of collections."
      },
      "CollectionResponse": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "NOT REQUIRED (auto-generated). Unique identifier for this collection. Used for: API paths, document queries, pipeline references. Format: 'col_' prefix + 10 random alphanumeric characters. Stable after creation - use for all collection references.",
            "examples": [
              "col_a1b2c3d4e5",
              "col_xyz789abc",
              "col_video_frames"
            ]
          },
          "collection_name": {
            "type": "string",
            "maxLength": 100,
            "minLength": 3,
            "title": "Collection Name",
            "description": "REQUIRED. Human-readable name for the collection. Must be unique within the namespace. Used for: Display, lookups (can query by name or ID), organization. Format: Alphanumeric with underscores/hyphens, 3-100 characters. Examples: 'product_embeddings', 'video_frames', 'customer_documents'.",
            "examples": [
              "video_frames",
              "product_embeddings",
              "customer_documents"
            ]
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "NOT REQUIRED. Human-readable description of the collection's purpose. Use for: Documentation, team communication, UI display. Common pattern: Describe what the collection contains and what processing is applied.",
            "examples": [
              "Video frames extracted at 1 FPS with CLIP embeddings",
              "Product catalog with image embeddings and metadata"
            ]
          },
          "input_schema": {
            "$ref": "#/components/schemas/BucketSchema-Output",
            "description": "REQUIRED (auto-computed from source). Input schema defining fields available to the feature extractor. Source: bucket.bucket_schema (if source.type='bucket') OR upstream_collection.output_schema (if source.type='collection'). Determines: Which fields can be used in input_mappings and field_passthrough. This is the 'left side' of the transformation - what data goes IN. Format: BucketSchema with properties dict. Use for: Validating input_mappings, configuring field_passthrough.",
            "examples": [
              {
                "properties": {
                  "title": {
                    "type": "string"
                  },
                  "content": {
                    "type": "text"
                  }
                }
              },
              {
                "properties": {
                  "video": {
                    "type": "video"
                  },
                  "campaign_id": {
                    "type": "string"
                  }
                }
              }
            ]
          },
          "output_schema": {
            "$ref": "#/components/schemas/BucketSchema-Output",
            "description": "REQUIRED (auto-computed at creation). Output schema defining fields in final documents. Computed as: field_passthrough fields + extractor output fields (deterministic). Known IMMEDIATELY when collection is created - no waiting for documents! This is the 'right side' of the transformation - what data comes OUT. Use for: Understanding document structure, building queries, schema validation. Example: {title (passthrough), embedding (extractor output)} = output_schema.",
            "examples": [
              {
                "properties": {
                  "title": {
                    "type": "string"
                  },
                  "text_extractor_v1_embedding": {
                    "type": "array"
                  }
                }
              },
              {
                "properties": {
                  "campaign_id": {
                    "type": "string"
                  },
                  "video_extractor_v1_embedding": {
                    "type": "array"
                  }
                }
              }
            ]
          },
          "feature_extractor": {
            "$ref": "#/components/schemas/FeatureExtractorConfig-Output",
            "description": "REQUIRED. Single feature extractor configuration for this collection. Defines: extractor name/version, input_mappings, field_passthrough, parameters. Task 9 change: ONE extractor per collection (previously supported multiple). For multiple extractors: Create multiple collections and use collection-to-collection pipelines. Use field_passthrough to include additional source fields beyond extractor outputs.",
            "examples": [
              {
                "feature_extractor_name": "text_extractor",
                "field_passthrough": [
                  {
                    "source_path": "title"
                  }
                ],
                "input_mappings": {
                  "text": "content"
                },
                "version": "v1"
              }
            ]
          },
          "source": {
            "$ref": "#/components/schemas/SourceConfig",
            "description": "REQUIRED. Source configuration defining where data comes from. Type 'bucket': Process objects from one or more buckets (tier 1). Type 'collection': Process documents from upstream collection (tier 2+). For multi-bucket sources, all buckets must have compatible schemas. Determines input_schema and enables decomposition trees.",
            "examples": [
              {
                "bucket_ids": [
                  "bkt_articles"
                ],
                "type": "bucket"
              },
              {
                "bucket_ids": [
                  "bkt_us_products",
                  "bkt_eu_products"
                ],
                "type": "bucket"
              },
              {
                "collection_id": "col_video_frames",
                "type": "collection"
              }
            ]
          },
          "source_bucket_schemas": {
            "anyOf": [
              {
                "additionalProperties": {
                  "$ref": "#/components/schemas/BucketSchema-Output"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Bucket Schemas",
            "description": "NOT REQUIRED (auto-computed). Snapshot of bucket schemas at collection creation. Only populated for multi-bucket collections (source.type='bucket' with multiple bucket_ids). Key: bucket_id, Value: BucketSchema at time of collection creation. Used for: Schema compatibility validation, document lineage, debugging. Schema snapshot is immutable - bucket schema changes after collection creation do not affect this. Single-bucket collections may omit this field (schema in input_schema is sufficient).",
            "examples": [
              null,
              {
                "bkt_eu_products": {
                  "properties": {
                    "image": {
                      "type": "image"
                    },
                    "title": {
                      "type": "string"
                    },
                    "price": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "image",
                    "title"
                  ]
                },
                "bkt_us_products": {
                  "properties": {
                    "image": {
                      "type": "image"
                    },
                    "title": {
                      "type": "string"
                    },
                    "price": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "image",
                    "title"
                  ]
                }
              }
            ]
          },
          "source_lineage": {
            "items": {
              "$ref": "#/components/schemas/SingleLineageEntry"
            },
            "type": "array",
            "title": "Source Lineage",
            "description": "NOT REQUIRED (auto-computed). Lineage chain showing complete processing history. Each entry contains: source_config, feature_extractor, output_schema for one tier. Length indicates processing depth (1 = tier 1, 2 = tier 2, etc.). Use for: Understanding multi-tier pipelines, visualizing decomposition trees.",
            "examples": [
              [],
              [
                {
                  "output_schema": {},
                  "source_config": {
                    "bucket_id": "bkt_videos",
                    "type": "bucket"
                  }
                }
              ]
            ]
          },
          "vector_indexes": {
            "items": {},
            "type": "array",
            "title": "Vector Indexes",
            "description": "NOT REQUIRED (auto-computed from extractor). Vector indexes for semantic search. Populated from feature_extractor.required_vector_indexes. Defines: Which embeddings are indexed, dimensions, distance metrics. Use for: Understanding search capabilities, debugging vector queries.",
            "examples": [
              [],
              [
                {
                  "distance": "cosine",
                  "name": "text_extractor_v1_embedding",
                  "size": 1024
                }
              ]
            ]
          },
          "payload_indexes": {
            "items": {},
            "type": "array",
            "title": "Payload Indexes",
            "description": "NOT REQUIRED (auto-computed from extractor + namespace). Payload indexes for filtering. Enables efficient filtering on metadata fields, timestamps, IDs. Populated from: extractor requirements + namespace defaults. Use for: Understanding which fields support fast filtering.",
            "examples": [
              [],
              [
                {
                  "field_name": "collection_id",
                  "type": "keyword"
                }
              ]
            ]
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "NOT REQUIRED (defaults to True). Whether the collection accepts new documents. False: Collection exists but won't process new objects. True: Active and processing. Use for: Temporarily disabling collections without deletion.",
            "default": true,
            "examples": [
              true,
              false
            ]
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "NOT REQUIRED. Additional user-defined metadata for the collection. Arbitrary key-value pairs for custom organization, tracking, configuration. Not used by the platform - purely for user purposes. Common uses: team ownership, project tags, deployment environment.",
            "examples": [
              {
                "environment": "production",
                "project": "Q4_campaign",
                "team": "data-science"
              },
              null
            ]
          },
          "created_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created At",
            "description": "Timestamp when the collection was created. Automatically set by the system when the collection is first saved to the database."
          },
          "updated_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Updated At",
            "description": "Timestamp when the collection was last updated. Automatically updated by the system whenever the collection is modified."
          },
          "document_count": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Document Count",
            "description": "Number of documents in the collection"
          },
          "taxonomy_applications": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/TaxonomyApplicationConfig"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Taxonomy Applications",
            "description": "NOT REQUIRED. List of taxonomies to apply to documents in this collection. Each entry specifies: taxonomy_id, execution_mode (materialize/on_demand), optional filters. Materialized: Enrichments persisted to documents during ingestion. On-demand: Enrichments computed during retrieval (via taxonomy_join stages). Empty/null if no taxonomies attached. Use for: Categorization, hierarchical classification.",
            "examples": [
              null,
              [
                {
                  "execution_mode": "on_demand",
                  "taxonomy_id": "tax_categories"
                },
                {
                  "execution_mode": "materialize",
                  "taxonomy_id": "tax_brands"
                }
              ]
            ]
          },
          "taxonomy_count": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Taxonomy Count",
            "description": "Number of taxonomies connected to this collection"
          },
          "retriever_count": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Retriever Count",
            "description": "Number of retrievers connected to this collection"
          }
        },
        "type": "object",
        "required": [
          "collection_name",
          "input_schema",
          "output_schema",
          "feature_extractor",
          "source"
        ],
        "title": "CollectionResponse",
        "description": "Response model for collection endpoints.",
        "examples": [
          {
            "collection_id": "col_a1b2c3d4e5",
            "collection_name": "article_embeddings",
            "description": "Simple text collection: News articles with text embeddings from bucket source",
            "enabled": true,
            "feature_extractor": {
              "feature_extractor_name": "text_extractor",
              "field_passthrough": [
                {
                  "source_path": "title"
                }
              ],
              "input_mappings": {
                "text": "content"
              },
              "version": "v1"
            },
            "input_schema": {
              "properties": {
                "title": {
                  "type": "string"
                },
                "content": {
                  "type": "text"
                }
              }
            },
            "output_schema": {
              "properties": {
                "title": {
                  "type": "string"
                },
                "text_extractor_v1_embedding": {
                  "type": "array"
                }
              }
            },
            "source": {
              "bucket_id": "bkt_articles",
              "type": "bucket"
            }
          },
          {
            "collection_id": "col_xyz789abc",
            "collection_name": "video_frames",
            "description": "Video frames: Extracted at 1 FPS with CLIP embeddings and campaign_id passthrough",
            "enabled": true,
            "feature_extractor": {
              "feature_extractor_name": "video_extractor",
              "field_passthrough": [
                {
                  "source_path": "campaign_id"
                }
              ],
              "input_mappings": {
                "video": "video"
              },
              "parameters": {
                "fps": 1
              },
              "version": "v1"
            },
            "input_schema": {
              "properties": {
                "video": {
                  "type": "video"
                },
                "campaign_id": {
                  "type": "string"
                }
              }
            },
            "output_schema": {
              "properties": {
                "campaign_id": {
                  "type": "string"
                },
                "video_extractor_v1_embedding": {
                  "type": "array"
                }
              }
            },
            "source": {
              "bucket_id": "bkt_marketing_videos",
              "type": "bucket"
            }
          },
          {
            "collection_id": "col_scenes_def",
            "collection_name": "detected_scenes",
            "description": "Tier 2 decomposition: Scenes detected from frame embeddings (collection source)",
            "enabled": true,
            "feature_extractor": {
              "feature_extractor_name": "scene_extractor",
              "field_passthrough": [
                {
                  "source_path": "campaign_id"
                }
              ],
              "input_mappings": {
                "embedding": "video_extractor_v1_embedding"
              },
              "version": "v1"
            },
            "input_schema": {
              "properties": {
                "campaign_id": {
                  "type": "string"
                },
                "video_extractor_v1_embedding": {
                  "type": "array"
                }
              }
            },
            "output_schema": {
              "properties": {
                "campaign_id": {
                  "type": "string"
                },
                "scene_extractor_v1_embedding": {
                  "type": "array"
                }
              }
            },
            "source": {
              "collection_id": "col_video_frames",
              "type": "collection"
            }
          }
        ]
      },
      "ComputeTier": {
        "type": "string",
        "enum": [
          "shared",
          "dedicated_cpu",
          "dedicated_gpu"
        ],
        "title": "ComputeTier",
        "description": "Available compute tiers for namespace workloads.\n\nCompute tiers determine the infrastructure resources allocated to a namespace\nfor ingestion pipelines, clustering, and other data processing operations.\n\nTiers:\n    SHARED: Multi-tenant infrastructure with dynamic resource allocation.\n        - Best for: Development, testing, low-volume production workloads\n        - Resources: Shared CPU and memory pool\n        - Cost: Lowest cost option, pay-per-use credits\n        - SLA: Best-effort availability\n\n    DEDICATED_CPU: Single-tenant CPU compute nodes.\n        - Best for: Production workloads requiring consistent performance\n        - Resources: Reserved CPU cores and memory\n        - Cost: Fixed monthly cost plus usage credits\n        - SLA: 99.9% uptime guarantee\n\n    DEDICATED_GPU: Single-tenant GPU-accelerated compute nodes.\n        - Best for: Video processing, embedding generation, ML inference\n        - Resources: Reserved GPU(s), CPU cores, and memory\n        - Cost: Premium pricing, fixed monthly cost plus usage credits\n        - SLA: 99.9% uptime guarantee\n\nExamples:\n    - Use SHARED for development and staging environments\n    - Use DEDICATED_CPU for production document processing pipelines\n    - Use DEDICATED_GPU for large-scale video ingestion and analysis"
      },
      "ConfigureCORSRequest": {
        "properties": {
          "allowed_origins": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Allowed Origins",
            "description": "List of allowed origins for CORS. These are the frontend URLs that will be allowed to upload directly to object storage. REQUIRED. Must be valid HTTP/HTTPS URLs. Examples: ['http://localhost:8080', 'https://app.example.com']",
            "examples": [
              [
                "http://localhost:8080",
                "http://localhost:3000"
              ],
              [
                "https://app.example.com",
                "https://staging.example.com"
              ]
            ]
          },
          "allowed_methods": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Allowed Methods",
            "description": "HTTP methods to allow for CORS requests. OPTIONAL - defaults to ['GET', 'PUT', 'POST', 'HEAD', 'DELETE'] if not provided. Common methods: GET (download), PUT (upload), POST (multipart upload), HEAD (metadata check)",
            "examples": [
              [
                "GET",
                "PUT",
                "POST",
                "HEAD"
              ],
              [
                "GET",
                "PUT",
                "POST",
                "HEAD",
                "DELETE"
              ]
            ]
          },
          "allowed_headers": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Allowed Headers",
            "description": "Headers that are allowed in CORS requests. OPTIONAL - defaults to ['*'] (allow all headers) if not provided. Use ['*'] for maximum compatibility or specify specific headers.",
            "examples": [
              [
                "*"
              ],
              [
                "Content-Type",
                "Authorization",
                "X-Requested-With"
              ]
            ]
          },
          "expose_headers": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expose Headers",
            "description": "Headers that browsers are allowed to access in responses. OPTIONAL - defaults to ['ETag', 'x-amz-request-id'] if not provided. 'ETag' is particularly important for upload confirmation.",
            "examples": [
              [
                "ETag"
              ],
              [
                "ETag",
                "x-amz-request-id",
                "Content-Length"
              ]
            ]
          },
          "max_age_seconds": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 86400.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Age Seconds",
            "description": "How long (in seconds) browsers should cache preflight request results. OPTIONAL - defaults to 3000 seconds (50 minutes) if not provided. Higher values reduce preflight requests but may delay policy updates.",
            "examples": [
              3000,
              3600,
              7200
            ]
          }
        },
        "type": "object",
        "required": [
          "allowed_origins"
        ],
        "title": "ConfigureCORSRequest",
        "description": "Request model for configuring CORS on object storage.\n\nThis allows administrators to configure CORS policies on the object storage\nbucket to enable browser-based uploads using presigned URLs.",
        "examples": [
          {
            "allowed_origins": [
              "http://localhost:8080",
              "http://localhost:3000",
              "http://localhost:5173"
            ],
            "description": "Local development setup with multiple ports"
          },
          {
            "allowed_headers": [
              "Content-Type",
              "Authorization"
            ],
            "allowed_methods": [
              "GET",
              "PUT",
              "POST",
              "HEAD"
            ],
            "allowed_origins": [
              "https://app.example.com",
              "https://staging.example.com"
            ],
            "description": "Production setup with specific headers",
            "expose_headers": [
              "ETag",
              "Content-Length"
            ],
            "max_age_seconds": 3600
          },
          {
            "allowed_origins": [
              "https://app.example.com"
            ],
            "description": "Minimal configuration (uses defaults)"
          }
        ]
      },
      "ConfirmUploadRequest": {
        "properties": {
          "etag": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Etag",
            "description": "S3 ETag returned from the upload. OPTIONAL but RECOMMENDED. After uploading to S3, the response includes an ETag header. Providing this ensures the file wasn't corrupted during upload. If provided and doesn't match S3's ETag, confirmation will fail with error. Format: Usually an MD5 hash, may be enclosed in quotes.",
            "examples": [
              "d41d8cd98f00b204e9800998ecf8427e",
              "\"a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6\""
            ]
          },
          "file_size_bytes": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "File Size Bytes",
            "description": "Actual file size uploaded, in bytes. OPTIONAL but RECOMMENDED. If provided, will be validated against the actual S3 object size. Mismatch indicates upload corruption or network issues. If not provided, size validation is skipped.",
            "examples": [
              10485760,
              52428800
            ]
          }
        },
        "type": "object",
        "title": "ConfirmUploadRequest",
        "description": "Request to confirm S3 upload completion and optionally create bucket object.\n\nAfter uploading your file to S3 using the presigned URL, call this endpoint\nto verify the upload succeeded and optionally create a bucket object.\n\nThe system will:\n1. Verify the S3 object exists\n2. Validate ETag matches (if provided) - RECOMMENDED for integrity checking\n3. Validate file size matches (if provided)\n4. Create bucket object (if create_object_on_confirm was true)\n5. Update upload status to COMPLETED\n\nExamples:\n    - Confirm with ETag for integrity verification (recommended)\n    - Confirm without ETag (less safe, but faster)\n    - Async confirmation for large files",
        "examples": [
          {
            "description": "Confirm with ETag for integrity verification (recommended)",
            "etag": "d41d8cd98f00b204e9800998ecf8427e",
            "file_size_bytes": 52428800
          },
          {
            "description": "Confirm with size only",
            "file_size_bytes": 10485760
          },
          {
            "description": "Basic confirmation without validation (not recommended)"
          }
        ]
      },
      "ConfirmUploadResponse": {
        "properties": {
          "upload_id": {
            "type": "string",
            "title": "Upload Id",
            "description": "Upload ID that was confirmed"
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Updated upload status (COMPLETED or PROCESSING)"
          },
          "etag": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Etag",
            "description": "S3 ETag from uploaded object"
          },
          "file_size_bytes": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Size Bytes",
            "description": "Actual file size from S3"
          },
          "file_hash": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Hash",
            "description": "File content hash (from ETag)"
          },
          "verified_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Verified At",
            "description": "When verification completed"
          },
          "completed_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completed At",
            "description": "When upload completed"
          },
          "object_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Id",
            "description": "Created bucket object ID (if create_object_on_confirm was true)"
          },
          "task_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Task Id",
            "description": "Task ID for async processing (if async=true)"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Confirmation message"
          }
        },
        "type": "object",
        "required": [
          "upload_id",
          "status"
        ],
        "title": "ConfirmUploadResponse",
        "description": "Response from upload confirmation.",
        "examples": [
          {
            "completed_at": "2024-01-15T10:35:00Z",
            "description": "Synchronous confirmation with object creation",
            "etag": "d41d8cd98f00b204e9800998ecf8427e",
            "file_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
            "file_size_bytes": 52428800,
            "object_id": "obj_xyz789",
            "status": "COMPLETED",
            "upload_id": "upl_abc123",
            "verified_at": "2024-01-15T10:35:00Z"
          },
          {
            "description": "Asynchronous confirmation",
            "message": "Upload confirmation is being processed in the background.",
            "status": "PROCESSING",
            "task_id": "task_xyz789",
            "upload_id": "upl_abc123"
          }
        ]
      },
      "CreateBatchRequest": {
        "properties": {
          "object_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Object Ids",
            "description": "A list of object IDs to add to the batch.",
            "examples": [
              [
                "object_789",
                "object_101"
              ]
            ]
          }
        },
        "type": "object",
        "required": [
          "object_ids"
        ],
        "title": "CreateBatchRequest",
        "description": "The request model for creating a new batch."
      },
      "CreateBlobRequest": {
        "properties": {
          "property": {
            "type": "string",
            "maxLength": 100,
            "minLength": 1,
            "title": "Property",
            "description": "REQUIRED. Property name from the bucket schema that this blob belongs to. Must match a field defined in the bucket's schema. Used to validate blob type compatibility and determine storage path. Common values: 'video', 'thumbnail', 'transcript', 'document', 'image'",
            "examples": [
              "video",
              "thumbnail",
              "transcript",
              "image",
              "document"
            ]
          },
          "key_prefix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Key Prefix",
            "description": "OPTIONAL. Storage path prefix for organizing blobs within the bucket. If not provided, uses default bucket organization. Use for: grouping blobs by campaign, date, category, etc. Example: 'campaigns/summer_2025' or 'products/electronics'",
            "examples": [
              "campaigns/summer_2025",
              "products/electronics",
              "2025/Q4"
            ]
          },
          "type": {
            "$ref": "#/components/schemas/BucketSchemaFieldType",
            "description": "REQUIRED. The schema field type for this blob. Must match the bucket schema definition for the property. Determines validation rules and processing pipeline. Common types: IMAGE, VIDEO, AUDIO, PDF, DOCUMENT, TEXT",
            "examples": [
              "VIDEO",
              "IMAGE",
              "PDF",
              "AUDIO",
              "TEXT",
              "DOCUMENT"
            ]
          },
          "data": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 2083,
                "minLength": 1,
                "format": "uri"
              },
              {
                "type": "string"
              },
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "items": {},
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Data",
            "description": "EITHER data OR upload_id must be provided (mutually exclusive). \n\nDirect data for the blob. Supports: - HTTP/HTTPS URLs (public or pre-signed S3 URLs) - S3 URLs (s3://bucket/key format) - Base64-encoded content (for small files) \n\nUse this for: - Quick uploads of public URLs - Small files that can be embedded - Existing S3 objects \n\nFor large files or client-side uploads, use upload_id instead. See upload_id field for the presigned URL workflow.",
            "examples": [
              "https://example.com/video.mp4",
              "s3://my-bucket/path/to/file.jpg",
              "data:image/png;base64,iVBORw0KG..."
            ]
          },
          "upload_id": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^upl_[a-zA-Z0-9_-]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Upload Id",
            "description": "EITHER upload_id OR data must be provided. Reference to an existing upload from the presigned URL workflow. \n\n\u26a0\ufe0f  PRESIGNED URLS: Use existing POST /buckets/{id}/uploads endpoint! It already handles presigned URL generation, upload tracking, and validation. DO NOT create a new /presigned-upload endpoint - it's redundant. \n\nWorkflow: 1. POST /buckets/{id}/uploads \u2192 {upload_id, presigned_url} 2. User uploads file to presigned_url 3. POST /uploads/{upload_id}/confirm \u2192 Validates upload 4. Use upload_id here to reference the uploaded file \n\nThe upload must be in CONFIRMED or ACTIVE status. Format: 'upl_' prefix followed by alphanumeric characters. \n\nUse Cases: - Combine multiple uploads into one object - Upload files in parallel, create object later - Reuse same upload across multiple objects \n\nSee: api/buckets/uploads/ for the complete upload system",
            "examples": [
              "upl_abc123def456",
              "upl_xyz789"
            ]
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Metadata for the blob, this will only be applied to the documents that use this blob"
          },
          "canonicalize_source": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Canonicalize Source",
            "description": "If set, override object-level default to control source canonicalization for this blob."
          },
          "force_remirror": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Force Remirror",
            "description": "If set, override object-level default to force re-upload even if an identical blob exists."
          }
        },
        "type": "object",
        "required": [
          "property",
          "type"
        ],
        "title": "CreateBlobRequest",
        "description": "Request model for creating a new blob.\n\n\u26a0\ufe0f  IMPORTANT: For presigned URL uploads, use the existing /buckets/{id}/uploads system!\n    DO NOT create a new presigned upload endpoint - one already exists.\n\nSupports two modes:\n\nMode 1: Direct Data Upload\n    - Provide 'data' field with URL or base64 content\n    - File is processed immediately during object creation\n    - Use for: Small files, public URLs, inline data\n\nMode 2: Upload Reference (Recommended for large files)\n    - First: POST /buckets/{id}/uploads \u2192 Returns presigned_url + upload_id\n    - User uploads file directly to S3 via presigned_url\n    - Then: POST /uploads/{upload_id}/confirm \u2192 Validates upload\n    - Finally: Reference upload_id in this blob request\n    - Use for: Large files, client-side uploads, multi-blob objects\n\nWhy upload_id?\n    - Combine multiple uploads into one object\n    - Upload files in parallel, create object later\n    - Reuse uploads across multiple objects\n    - Better UX: upload progress, retry logic, validation\n\nRelated Endpoints:\n    - POST /buckets/{id}/uploads - Generate presigned URLs (EXISTING SYSTEM)\n    - POST /uploads/{id}/confirm - Confirm upload completed\n    - See: api/buckets/uploads/services.py for full upload workflow\n\nExamples:\n    # Direct data (simple)\n    {\n      \"property\": \"thumbnail\",\n      \"type\": \"IMAGE\",\n      \"data\": \"https://example.com/image.jpg\"\n    }\n\n    # Upload reference (recommended)\n    {\n      \"property\": \"video\",\n      \"type\": \"VIDEO\",\n      \"upload_id\": \"upl_abc123\"  # From /uploads endpoint\n    }\n\n    # Multiple uploads \u2192 one object\n    {\n      \"blobs\": [\n        {\"property\": \"video\", \"upload_id\": \"upl_video123\"},\n        {\"property\": \"thumbnail\", \"upload_id\": \"upl_thumb456\"},\n        {\"property\": \"transcript\", \"upload_id\": \"upl_trans789\"}\n      ]\n    }",
        "examples": [
          {
            "data": "https://example.com/image.jpg",
            "description": "Direct data upload - Simple image from URL",
            "metadata": {
              "alt_text": "Product thumbnail"
            },
            "property": "thumbnail",
            "type": "IMAGE"
          },
          {
            "description": "Upload reference - Video from presigned upload",
            "metadata": {
              "duration_seconds": 120
            },
            "property": "video",
            "type": "VIDEO",
            "upload_id": "upl_abc123def456"
          },
          {
            "blobs": [
              {
                "property": "video",
                "type": "VIDEO",
                "upload_id": "upl_video123"
              },
              {
                "property": "thumbnail",
                "type": "IMAGE",
                "upload_id": "upl_thumb456"
              },
              {
                "property": "transcript",
                "type": "TEXT",
                "upload_id": "upl_trans789"
              }
            ],
            "description": "Multiple uploads in one object - Complete media package",
            "note": "Use in array for multi-file objects"
          },
          {
            "description": "Upload reference workflow - Complete example",
            "property": "document",
            "type": "PDF",
            "upload_id": "upl_abc123",
            "workflow": [
              "1. POST /buckets/{id}/uploads \u2192 {upload_id: 'upl_abc123', presigned_url: '...'}",
              "2. User uploads file to presigned_url (client-side)",
              "3. POST /uploads/upl_abc123/confirm \u2192 Validates upload",
              "4. POST /buckets/{id}/objects with blob referencing upload_id"
            ]
          }
        ]
      },
      "CreateClusterRequest": {
        "properties": {
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Collection Ids",
            "description": "Collections to cluster together"
          },
          "cluster_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cluster Name",
            "description": "Optional human-friendly name for the clustering job"
          },
          "cluster_type": {
            "$ref": "#/components/schemas/ClusterType",
            "description": "Vector or attribute clustering",
            "default": "vector"
          },
          "vector_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VectorBasedConfig"
              },
              {
                "type": "null"
              }
            ],
            "description": "Required when cluster_type is 'vector'"
          },
          "attribute_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AttributeBasedConfig"
              },
              {
                "type": "null"
              }
            ],
            "description": "Required when cluster_type is 'attribute'"
          },
          "llm_labeling": {
            "$ref": "#/components/schemas/LLMLabeling",
            "description": "Configuration for LLM-based cluster labeling"
          }
        },
        "type": "object",
        "required": [
          "collection_ids"
        ],
        "title": "CreateClusterRequest",
        "description": "Create a clustering job for one or more collections.",
        "examples": [
          {
            "cluster_name": "products_clip_hdbscan",
            "cluster_type": "vector",
            "collection_ids": [
              "col_products_v1",
              "col_products_v2"
            ],
            "llm_labeling": {
              "enabled": true,
              "model_name": "gpt-4"
            },
            "vector_config": {
              "clustering_method": "hdbscan",
              "feature_extractor_name": "clip_vit_l_14",
              "hdbscan_parameters": {
                "min_cluster_size": 10,
                "min_samples": 5
              },
              "sample_size": 5000
            }
          },
          {
            "attribute_config": {
              "attributes": [
                "status"
              ],
              "hierarchical_grouping": true
            },
            "cluster_name": "orders_group_by_status",
            "cluster_type": "attribute",
            "collection_ids": [
              "col_orders_v1",
              "col_orders_v2",
              "col_orders_v3"
            ]
          }
        ]
      },
      "CreateCollectionRequest": {
        "properties": {
          "collection_name": {
            "type": "string",
            "title": "Collection Name",
            "description": "Name of the collection to create",
            "examples": [
              "video_frames",
              "product_embeddings"
            ]
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the collection"
          },
          "source": {
            "$ref": "#/components/schemas/SourceConfig",
            "description": "Source configuration (bucket or collection) for this collection"
          },
          "input_schema": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BucketSchema-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Input schema for the collection. If not provided, inferred from source bucket's bucket_schema or source collection's output_schema. REQUIRED for input_mappings to work - defines what fields can be mapped to feature extractors."
          },
          "feature_extractor": {
            "$ref": "#/components/schemas/FeatureExtractorConfig-Input",
            "description": "Single feature extractor for this collection. Use field_passthrough within the extractor config to include additional source fields. For multiple extractors, create multiple collections and use collection-to-collection pipelines."
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the collection is enabled",
            "default": true
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Additional metadata for the collection"
          }
        },
        "type": "object",
        "required": [
          "collection_name",
          "source",
          "feature_extractor"
        ],
        "title": "CreateCollectionRequest",
        "description": "Request model for creating a new collection.\n\nCollections process data from buckets or other collections using a single feature extractor.\n\nKEY ARCHITECTURAL CHANGE: Each collection has EXACTLY ONE feature extractor.\n- Use field_passthrough to include additional source fields in output documents\n- Multiple extractors = multiple collections\n- This simplifies processing and makes output schema deterministic\n\nCRITICAL: To use input_mappings:\n1. Your source bucket MUST have a bucket_schema defined\n2. The input_mappings reference fields from that bucket_schema\n3. The system validates that mapped fields exist in the source schema\n\nExample workflow:\n1. Create bucket with schema: { \"properties\": { \"image\": {\"type\": \"image\"}, \"title\": {\"type\": \"string\"} } }\n2. Upload objects conforming to that schema\n3. Create collection with:\n   - input_mappings: { \"image\": \"image\" }\n   - field_passthrough: [{\"source_path\": \"title\"}]\n4. Output documents will have both extractor outputs AND passthrough fields\n\nSchema Computation:\n- output_schema is computed IMMEDIATELY when collection is created\n- output_schema = field_passthrough fields + extractor output fields\n- No waiting for documents to be processed!",
        "examples": [
          {
            "collection_name": "product_embeddings",
            "description": "Generate image embeddings with passthrough fields",
            "enabled": true,
            "feature_extractor": {
              "feature_extractor_name": "image_extractor",
              "field_passthrough": [
                {
                  "required": true,
                  "source_path": "title"
                },
                {
                  "source_path": "category"
                }
              ],
              "input_mappings": {
                "image": "product_image"
              },
              "parameters": {
                "model": "clip-vit-base-patch32"
              },
              "version": "v1"
            },
            "source": {
              "bucket_id": "bkt_products",
              "type": "bucket"
            }
          },
          {
            "collection_name": "video_frames",
            "description": "Extract frames from videos with metadata passthrough",
            "feature_extractor": {
              "feature_extractor_name": "video_extractor",
              "field_passthrough": [
                {
                  "source_path": "campaign_id"
                },
                {
                  "source_path": "duration_seconds"
                }
              ],
              "input_mappings": {
                "video": "video_url"
              },
              "parameters": {
                "fps": 1
              },
              "version": "v1"
            },
            "source": {
              "bucket_id": "bkt_videos",
              "type": "bucket"
            }
          },
          {
            "collection_name": "scenes_from_frames",
            "description": "Detect scenes from frame collection (collection-to-collection)",
            "feature_extractor": {
              "feature_extractor_name": "scene_detector",
              "field_passthrough": [
                {
                  "source_path": "campaign_id"
                }
              ],
              "input_mappings": {
                "image": "frame_url"
              },
              "version": "v1"
            },
            "source": {
              "collection_id": "col_video_frames",
              "type": "collection"
            }
          }
        ]
      },
      "CreateNamespaceRequest": {
        "properties": {
          "namespace_name": {
            "type": "string",
            "title": "Namespace Name",
            "description": "Name of the namespace to create",
            "example": "spotify_playlists_dev"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the namespace",
            "example": "This namespace contains playlists from Spotify"
          },
          "feature_extractors": {
            "items": {
              "$ref": "#/components/schemas/BaseFeatureExtractorModel-Input"
            },
            "type": "array",
            "minItems": 1,
            "title": "Feature Extractors",
            "description": "List of feature extractors to use. At least one feature extractor must be provided.",
            "example": [
              {
                "feature_extractor_id": "video_extractor_1.0.0",
                "feature_extractor_name": "video_extractor",
                "version": "1.0.0"
              }
            ]
          },
          "payload_indexes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/PayloadIndexConfig-Input"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Payload Indexes",
            "description": "Optional list of custom payload index configurations. Indexes required by selected feature extractors will be added automatically.",
            "example": [
              {
                "field_name": "metadata.title",
                "field_schema": {
                  "lowercase": true,
                  "max_token_len": 15,
                  "min_token_len": 2,
                  "tokenizer": "word",
                  "type": "text"
                },
                "type": "text"
              },
              {
                "field_name": "metadata.description",
                "field_schema": {
                  "is_tenant": true,
                  "type": "keyword"
                },
                "type": "keyword"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "namespace_name",
          "feature_extractors"
        ],
        "title": "CreateNamespaceRequest",
        "description": "Request schema for creating a new namespace."
      },
      "CreateObjectRequest": {
        "properties": {
          "key_prefix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Key Prefix",
            "description": "Storage key/path prefix of the object, this will be used to retrieve the object from the storage. It's at the root of the object.",
            "example": "/contract-2024"
          },
          "blobs": {
            "items": {
              "$ref": "#/components/schemas/CreateBlobRequest"
            },
            "type": "array",
            "title": "Blobs",
            "description": "List of blobs to be created in this object",
            "example": [
              {
                "data": {
                  "num_pages": 5,
                  "title": "Service Agreement 2024"
                },
                "key_prefix": "/content.pdf",
                "metadata": {
                  "author": "John Doe",
                  "department": "Legal"
                },
                "property": "content",
                "type": "PDF"
              }
            ]
          },
          "skip_duplicates": {
            "type": "boolean",
            "title": "Skip Duplicates",
            "description": "Skip duplicate blobs, if a blob with the same hash already exists, it will be skipped.",
            "default": false
          },
          "canonicalize_source": {
            "type": "boolean",
            "title": "Canonicalize Source",
            "description": "Mirror non-S3 sources into internal S3 and reference canonically.",
            "default": true
          },
          "force_remirror": {
            "type": "boolean",
            "title": "Force Remirror",
            "description": "Force re-upload to S3 even if a blob with identical content already exists.",
            "default": false
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "CreateObjectRequest",
        "description": "Request model for creating a bucket object.\n\nObjects can be created with blobs from two sources:\n1. Direct data (URLs, base64) - Use CreateBlobRequest.data field\n2. Upload references - Use CreateBlobRequest.upload_id field (from POST /buckets/{id}/uploads)\n\nUpload Reference Workflow:\n    For large files or client-side uploads, use the presigned URL workflow:\n    1. POST /buckets/{id}/uploads \u2192 Returns {upload_id, presigned_url}\n    2. User uploads file to presigned_url (client-side)\n    3. POST /uploads/{upload_id}/confirm \u2192 Validates upload\n    4. POST /buckets/{id}/objects with upload_id in blobs (this endpoint)\n\nUse Cases:\n    - Single blob with direct data (simple)\n    - Multiple blobs from presigned uploads (recommended for large files)\n    - Mix of direct data and upload references\n    - Combine multiple uploads into one object\n\nSee Also:\n    - CreateBlobRequest for blob field documentation\n    - POST /buckets/{id}/uploads for presigned URL generation",
        "example": {
          "blobs": [
            {
              "data": {
                "num_pages": 5,
                "title": "Service Agreement 2024"
              },
              "key_prefix": "/contract-2024/content.pdf",
              "metadata": {
                "author": "John Doe",
                "department": "Legal"
              },
              "property": "content",
              "type": "json"
            },
            {
              "data": {
                "filename": "https://example.com/images/smartphone-x1.jpg",
                "mime_type": "image/jpeg"
              },
              "key_prefix": "/contract-2024/thumbnail.jpg",
              "metadata": {
                "height": 300,
                "width": 200
              },
              "property": "thumbnail",
              "type": "image"
            }
          ],
          "key_prefix": "/documents",
          "metadata": {
            "category": "contracts",
            "status": "draft",
            "year": 2024
          }
        }
      },
      "CreateObjectsBatchRequest": {
        "properties": {
          "objects": {
            "items": {
              "$ref": "#/components/schemas/CreateObjectRequest"
            },
            "type": "array",
            "title": "Objects",
            "description": "List of objects to be created in this batch."
          }
        },
        "type": "object",
        "required": [
          "objects"
        ],
        "title": "CreateObjectsBatchRequest",
        "description": "Request model for creating multiple bucket objects in a batch.",
        "examples": [
          {
            "objects": [
              {
                "blobs": [
                  {
                    "data": {
                      "num_pages": 5,
                      "title": "Service Agreement 2024"
                    },
                    "key_prefix": "/contract-2024/content.pdf",
                    "metadata": {
                      "author": "John Doe",
                      "department": "Legal"
                    },
                    "property": "content",
                    "type": "json"
                  }
                ],
                "key_prefix": "/documents",
                "metadata": {
                  "category": "contracts",
                  "status": "draft",
                  "year": 2024
                }
              }
            ]
          }
        ]
      },
      "CreateOrganizationRequest": {
        "properties": {
          "organization_name": {
            "type": "string",
            "maxLength": 100,
            "minLength": 1,
            "title": "Organization Name",
            "description": "Display name for the organization."
          },
          "users": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/UserCreateRequest"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Users",
            "description": "Initial users to create with the organization."
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Custom metadata for the organization."
          }
        },
        "type": "object",
        "required": [
          "organization_name"
        ],
        "title": "CreateOrganizationRequest",
        "description": "Payload for creating a new organization (private/admin endpoint).",
        "examples": [
          {
            "metadata": {
              "region": "us-east-1"
            },
            "organization_name": "Acme Corp",
            "users": [
              {
                "email": "admin@acme.com",
                "role": "admin",
                "user_name": "Admin User"
              }
            ]
          }
        ]
      },
      "CreateRetrieverRequest": {
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "title": "Name",
            "description": "Unique pipeline name (REQUIRED)."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Human readable pipeline description (OPTIONAL)."
          },
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Collection Ids",
            "description": "Collections queried by the pipeline (REQUIRED)."
          },
          "stages": {
            "items": {
              "$ref": "#/components/schemas/PipelineStageConfig"
            },
            "type": "array",
            "minItems": 1,
            "title": "Stages",
            "description": "Ordered stage configurations (REQUIRED)."
          },
          "input_schema": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Input"
            },
            "type": "object",
            "title": "Input Schema",
            "description": "Input schema properties keyed by field name (REQUIRED)."
          },
          "budget_limits": {
            "$ref": "#/components/schemas/BudgetLimits",
            "description": "Budget limits for execution (OPTIONAL)."
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Optional pipeline tags for search/filters."
          }
        },
        "type": "object",
        "required": [
          "name",
          "collection_ids",
          "stages"
        ],
        "title": "CreateRetrieverRequest",
        "description": "Payload for creating a new retriever."
      },
      "CreateRetrieverResponse": {
        "properties": {
          "retriever": {
            "$ref": "#/components/schemas/PipelineConfig",
            "description": "Created retriever configuration."
          }
        },
        "type": "object",
        "required": [
          "retriever"
        ],
        "title": "CreateRetrieverResponse",
        "description": "Response after creating a retriever."
      },
      "CreateTaxonomyRequest": {
        "properties": {
          "taxonomy_name": {
            "type": "string",
            "title": "Taxonomy Name",
            "description": "A unique name for the taxonomy within the namespace."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "An optional description of the taxonomy."
          },
          "config": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/FlatTaxonomyConfig-Input"
              },
              {
                "$ref": "#/components/schemas/HierarchicalTaxonomyConfig-Input"
              }
            ],
            "title": "Config",
            "description": "Configuration specific to the taxonomy type.",
            "discriminator": {
              "propertyName": "taxonomy_type",
              "mapping": {
                "flat": "#/components/schemas/FlatTaxonomyConfig-Input",
                "hierarchical": "#/components/schemas/HierarchicalTaxonomyConfig-Input"
              }
            }
          }
        },
        "type": "object",
        "required": [
          "taxonomy_name",
          "config"
        ],
        "title": "CreateTaxonomyRequest",
        "description": "Request model to create a taxonomy.",
        "examples": [
          {
            "config": {
              "collection_id": "col_products_v1",
              "enrichment_fields": [
                {
                  "field_path": "metadata.tags",
                  "merge_mode": "append"
                }
              ],
              "input_mappings": [
                {
                  "input_key": "image_vector",
                  "path": "features.clip",
                  "source_type": "vector"
                }
              ],
              "retriever_id": "ret_clip_v1",
              "taxonomy_type": "flat"
            },
            "taxonomy_name": "product_tags"
          },
          {
            "config": {
              "hierarchy": {
                "col_executives_v1": "col_employees_v1"
              },
              "input_mappings": [
                {
                  "input_key": "face_vec",
                  "path": "features.face",
                  "source_type": "vector"
                }
              ],
              "retriever_id": "ret_face_v1",
              "taxonomy_type": "hierarchical"
            },
            "taxonomy_name": "org_hierarchy"
          }
        ]
      },
      "CreateTriggerRequest": {
        "properties": {
          "cluster_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cluster Id",
            "description": "Optional existing cluster ID"
          },
          "execution_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TriggerExecutionConfig"
              },
              {
                "type": "null"
              }
            ],
            "description": "Required if cluster_id not provided"
          },
          "trigger_type": {
            "$ref": "#/components/schemas/TriggerType",
            "description": "Type of trigger"
          },
          "schedule_config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Schedule Config",
            "description": "Schedule configuration"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Trigger description"
          },
          "status": {
            "$ref": "#/components/schemas/TriggerStatus",
            "description": "Initial status",
            "default": "active"
          }
        },
        "type": "object",
        "required": [
          "trigger_type",
          "schedule_config"
        ],
        "title": "CreateTriggerRequest",
        "description": "Request to create a new trigger."
      },
      "CreateUploadRequest": {
        "properties": {
          "filename": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Filename",
            "description": "Name of the file to upload. REQUIRED. Must be a valid filename without path traversal characters (../, \\). The filename is used to derive the blob_property if not explicitly provided. Examples: 'product_video.mp4', 'thumbnail.jpg', 'transcript.txt'",
            "examples": [
              "product_video.mp4",
              "thumbnail.jpg",
              "document.pdf"
            ]
          },
          "content_type": {
            "type": "string",
            "title": "Content Type",
            "description": "MIME type of the file. REQUIRED. Must be a valid MIME type (e.g., 'video/mp4', 'image/jpeg', 'application/pdf'). The presigned URL will enforce this content type during upload. Used to validate compatibility with bucket schema if create_object_on_confirm=true.",
            "examples": [
              "video/mp4",
              "image/jpeg",
              "image/png",
              "application/pdf",
              "text/plain"
            ]
          },
          "file_size_bytes": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "File Size Bytes",
            "description": "Expected file size in bytes. OPTIONAL but RECOMMENDED. If provided, will be validated against: 1. Tier-based file size limits (100MB free, 5GB pro, 50GB enterprise) 2. Storage quota availability 3. Actual uploaded file size during confirmation. If not provided, quota checking is skipped until confirmation.",
            "examples": [
              10485760,
              104857600
            ]
          },
          "presigned_url_expiration": {
            "type": "integer",
            "maximum": 86400.0,
            "minimum": 60.0,
            "title": "Presigned Url Expiration",
            "description": "How long the presigned URL is valid, in seconds. OPTIONAL, defaults to 3600 (1 hour). Valid range: 60 seconds (1 minute) to 86400 seconds (24 hours). After expiration, the URL cannot be used and you must request a new one. Recommendation: Use shorter expiration (300-900 seconds) for security-sensitive files, longer expiration (3600-7200 seconds) for large files that take time to upload.",
            "default": 3600,
            "examples": [
              3600,
              7200,
              900
            ]
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Custom metadata for tracking purposes. OPTIONAL. Stored with the upload record for filtering and analytics. Does NOT affect the created bucket object (use object_metadata for that). Common uses: campaign tracking, user identification, upload source.",
            "examples": [
              {
                "campaign": "summer_2024",
                "source": "mobile_app",
                "user_id": "user_123"
              },
              {
                "department": "marketing",
                "priority": "high"
              }
            ]
          },
          "create_object_on_confirm": {
            "type": "boolean",
            "title": "Create Object On Confirm",
            "description": "Whether to automatically create a bucket object when upload is confirmed. OPTIONAL, defaults to false. If true:   - Bucket MUST have a schema defined   - blob_property must exist in bucket schema   - content_type must match schema field type   - Validation happens BEFORE generating presigned URL. If false:   - Upload is confirmed but no object is created   - You can manually create the object later using the S3 URL.",
            "default": false
          },
          "object_metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Metadata",
            "description": "Metadata to attach to the created bucket object. OPTIONAL. Only used if create_object_on_confirm=true. This metadata will be:   1. Validated against bucket schema (if keys match schema fields)   2. Attached to the bucket object   3. Passed to downstream documents in connected collections. Example: {'priority': 'high', 'category': 'products', 'tags': ['featured']}",
            "examples": [
              {
                "category": "products",
                "priority": "high"
              },
              {
                "campaign": "q4_2024",
                "status": "draft",
                "tags": [
                  "review",
                  "featured"
                ]
              }
            ]
          },
          "blob_property": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^[a-zA-Z0-9_]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Blob Property",
            "description": "Property name for the blob in the bucket object. OPTIONAL. Defaults to filename without extension (e.g., 'product_video.mp4' \u2192 'product_video'). If create_object_on_confirm=true:   - Must exist in bucket schema   - Must be alphanumeric with underscores only   - Will be validated BEFORE generating presigned URL. Common values: 'video', 'image', 'thumbnail', 'transcript', 'content'.",
            "examples": [
              "video",
              "thumbnail",
              "transcript",
              "content"
            ]
          },
          "blob_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Blob Type",
            "description": "Type of blob. OPTIONAL. Defaults to type derived from content_type (e.g., 'video/mp4' \u2192 'VIDEO'). Must be a valid BucketSchemaFieldType if provided. Valid values: IMAGE, VIDEO, AUDIO, TEXT, PDF, DOCUMENT, etc. If create_object_on_confirm=true, will be validated against bucket schema field type.",
            "examples": [
              "VIDEO",
              "IMAGE",
              "AUDIO",
              "TEXT",
              "PDF"
            ]
          },
          "file_hash": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 64,
                "minLength": 64,
                "pattern": "^[a-f0-9]{64}$"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Hash",
            "description": "SHA256 hash of the file content for duplicate detection. OPTIONAL. If provided:   - System checks for existing confirmed uploads with same hash   - If duplicate found and skip_duplicates=true, returns existing upload   - Hash will be validated against actual S3 ETag during confirmation. If not provided:   - Hash is calculated from S3 ETag after upload   - Duplicate detection only happens during confirmation. Use case: Pre-calculate hash client-side to avoid uploading duplicates. Format: 64-character hexadecimal string (SHA256).",
            "examples": [
              "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
              "2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae"
            ]
          },
          "skip_duplicates": {
            "type": "boolean",
            "title": "Skip Duplicates",
            "description": "Skip upload if a file with the same hash already exists. OPTIONAL, defaults to TRUE. If true (default):   - If file_hash provided: System checks MongoDB for existing completed upload with same hash   - If duplicate found: Returns existing upload details WITHOUT generating new presigned URL   - If file_hash NOT provided: Duplicate check happens during confirmation using S3 ETag   - Saves bandwidth, storage, and upload time by reusing existing files. If false:   - Always generates new presigned URL even if file already uploaded   - Creates separate upload record for same file content   - Useful when you need distinct upload tracking for identical files. Recommendation: Keep default (true) unless you specifically need multiple upload records for same file.",
            "default": true
          }
        },
        "type": "object",
        "required": [
          "filename",
          "content_type"
        ],
        "title": "CreateUploadRequest",
        "description": "Request to generate a presigned URL for direct S3 upload.\n\n\u26a0\ufe0f  \u26a0\ufe0f  \u26a0\ufe0f  THIS IS THE PRESIGNED URL SYSTEM \u26a0\ufe0f  \u26a0\ufe0f  \u26a0\ufe0f\n\nThis endpoint (POST /buckets/{id}/uploads) is the COMPLETE presigned URL system.\nIt handles:\n- \u2705 Presigned URL generation (S3 PUT URLs)\n- \u2705 Upload tracking and status management\n- \u2705 Validation (quotas, file size, content type, schema)\n- \u2705 Duplicate detection\n- \u2705 Auto object creation on confirmation\n- \u2705 Returns upload_id for later reference\n\nDO NOT CREATE A NEW PRESIGNED UPLOAD ENDPOINT!\nIf you need presigned URLs, use this existing system.\n\nIf you think you need a new endpoint:\n1. Check if this system already does it (it probably does)\n2. Extend this system instead of creating redundancy\n3. See api/buckets/uploads/services.py for implementation\n\nIntegration Points:\n- Object creation: Use upload_id in CreateBlobRequest.upload_id field\n- See: shared/buckets/objects/blobs/models.py::CreateBlobRequest\n- See: api/buckets/objects/canonicalization.py::resolve_upload_reference()\n\nWorkflow:\n1. Call this endpoint to get a presigned URL (all validation happens here)\n2. Upload your file directly to S3 using the presigned URL\n3. Call POST /uploads/{upload_id}/confirm to verify upload\n4. Either:\n   a) Automatic object creation (if create_object_on_confirm=true)\n   b) Manual object creation referencing upload_id later\n\nUse Cases:\n    - Upload a video with automatic object creation on confirmation\n    - Upload multiple files, then combine into one object later\n    - Upload in parallel, create object when all complete\n    - Reuse same upload across multiple objects\n    - Track upload progress and status\n\nRequirements:\n    - filename: REQUIRED, will be validated (no path traversal)\n    - content_type: REQUIRED, must be valid MIME type\n    - bucket_id: Comes from URL path parameter, not request body\n    - All other fields: OPTIONAL with sensible defaults\n\nNote:\n    The bucket_id comes from the URL path (/v1/buckets/{bucket_id}/uploads),\n    not from the request body. The bucket is validated before generating presigned URL.",
        "examples": [
          {
            "blob_property": "video",
            "content_type": "video/mp4",
            "create_object_on_confirm": true,
            "description": "Simple video upload with auto object creation",
            "file_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
            "file_size_bytes": 52428800,
            "filename": "product_demo.mp4",
            "object_metadata": {
              "category": "tutorials",
              "title": "Product Demo Video"
            }
          },
          {
            "content_type": "image/jpeg",
            "create_object_on_confirm": false,
            "description": "Image upload with custom expiration and metadata",
            "file_size_bytes": 2097152,
            "filename": "profile.jpg",
            "metadata": {
              "campaign": "summer_2024",
              "upload_source": "mobile_app",
              "user_id": "user_123"
            },
            "presigned_url_expiration": 900
          },
          {
            "blob_property": "raw_video",
            "content_type": "video/quicktime",
            "create_object_on_confirm": true,
            "description": "Large file with extended expiration and skip duplicates",
            "file_hash": "2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae",
            "file_size_bytes": 5368709120,
            "filename": "4k_footage.mov",
            "presigned_url_expiration": 7200,
            "skip_duplicates": true
          },
          {
            "content_type": "text/plain",
            "description": "Minimal upload without duplicate checking",
            "filename": "temp_file.txt",
            "skip_duplicates": false
          },
          {
            "content_type": "video/mp4",
            "create_object_on_confirm": false,
            "description": "Manual object creation - Upload for later reference",
            "file_size_bytes": 104857600,
            "filename": "video.mp4",
            "note": "Set create_object_on_confirm=false to manually reference upload_id",
            "use_case": "Combine multiple uploads into one object, or upload in parallel and create object later",
            "workflow": [
              "1. POST /uploads \u2192 Returns {upload_id: 'upl_abc123', presigned_url: '...'}",
              "2. User uploads file to presigned_url (client-side)",
              "3. POST /uploads/upl_abc123/confirm \u2192 Status: CONFIRMED",
              "4. POST /buckets/{id}/objects:",
              "   {blobs: [{property: 'video', type: 'VIDEO', upload_id: 'upl_abc123'}]}",
              "5. Object created with blob referencing the uploaded file"
            ]
          }
        ]
      },
      "CreatorInfo": {
        "properties": {
          "user_id": {
            "type": "string",
            "title": "User Id",
            "description": "User identifier"
          },
          "email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email",
            "description": "User email address"
          },
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "User display name"
          }
        },
        "type": "object",
        "required": [
          "user_id"
        ],
        "title": "CreatorInfo",
        "description": "Information about who created or updated a resource."
      },
      "CursorPaginationParams": {
        "properties": {
          "method": {
            "$ref": "#/components/schemas/PaginationMethod",
            "description": "Constant identifying cursor pagination (REQUIRED).",
            "default": "cursor"
          },
          "limit": {
            "type": "integer",
            "maximum": 500.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Maximum number of documents to return (REQUIRED).",
            "default": 10
          },
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cursor",
            "description": "Opaque base64 cursor from previous response (OPTIONAL)."
          }
        },
        "type": "object",
        "title": "CursorPaginationParams",
        "description": "Cursor-based pagination referencing last seen position."
      },
      "DBSCANParams": {
        "properties": {
          "eps": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Eps",
            "description": "Maximum distance between two samples for one to be considered in the neighborhood of the other",
            "default": 0.5
          },
          "min_samples": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Min Samples",
            "description": "Number of samples in a neighborhood for a point to be considered a core point",
            "default": 5
          },
          "metric": {
            "type": "string",
            "title": "Metric",
            "description": "Metric to use for distance computation",
            "default": "euclidean"
          },
          "metric_params": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metric Params",
            "description": "Additional keyword arguments for the metric function"
          },
          "algorithm": {
            "type": "string",
            "title": "Algorithm",
            "description": "Algorithm to compute pointwise distances and find nearest neighbors ('auto', 'ball_tree', 'kd_tree', 'brute')",
            "default": "auto"
          },
          "leaf_size": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Leaf Size",
            "description": "Leaf size passed to BallTree or KDTree",
            "default": 30
          },
          "p": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "P",
            "description": "The power of the Minkowski metric to be used to calculate distance between points",
            "default": 2
          },
          "n_jobs": {
            "type": "integer",
            "title": "N Jobs",
            "description": "The number of parallel jobs to run (-1 means using all processors)",
            "default": 1
          }
        },
        "type": "object",
        "title": "DBSCANParams",
        "description": "Parameters for DBSCAN clustering algorithm."
      },
      "DatePartUnit": {
        "type": "string",
        "enum": [
          "year",
          "month",
          "week",
          "day",
          "dayOfWeek",
          "dayOfYear",
          "hour",
          "minute",
          "second"
        ],
        "title": "DatePartUnit",
        "description": "Date part extraction units.\n\nUsed to extract specific components from dates for grouping.\n\nValues:\n    YEAR: Extract year (2024)\n    MONTH: Extract month (1-12)\n    WEEK: Extract week of year (1-53)\n    DAY: Extract day of month (1-31)\n    DAY_OF_WEEK: Extract day of week (1=Sunday, 7=Saturday)\n    DAY_OF_YEAR: Extract day of year (1-366)\n    HOUR: Extract hour (0-23)\n    MINUTE: Extract minute (0-59)\n    SECOND: Extract second (0-59)\n\nExamples:\n    - Use DAY_OF_WEEK to analyze weekly patterns\n    - Use HOUR to find peak usage times"
      },
      "DateTruncUnit": {
        "type": "string",
        "enum": [
          "year",
          "month",
          "week",
          "day",
          "hour",
          "minute",
          "second"
        ],
        "title": "DateTruncUnit",
        "description": "Date truncation units for time-based grouping.\n\nUsed to group data by time periods.\n\nValues:\n    YEAR: Group by year\n    MONTH: Group by month\n    WEEK: Group by week\n    DAY: Group by day\n    HOUR: Group by hour\n    MINUTE: Group by minute\n    SECOND: Group by second\n\nExamples:\n    - Use DAY to group video uploads by day\n    - Use MONTH to analyze monthly trends"
      },
      "DatetimeIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "datetime"
          }
        },
        "type": "object",
        "title": "DatetimeIndexParams",
        "description": "Configuration for datetime index."
      },
      "DenseVector": {
        "properties": {},
        "additionalProperties": true,
        "type": "object",
        "title": "DenseVector",
        "description": "Basic dense vector representation with flexible key naming.\n\nAccepts a single key-value pair where the key can be any string\nand the value must be a list of floats.\n\nExample:\n```json\n{\n    \"embedding\": [0.1, 0.2, 0.3, 0.4, 0.5]\n}\n```\nor\n```json\n{\n    \"my_custom_vector\": [0.1, 0.2, 0.3, 0.4, 0.5]\n}\n```"
      },
      "DescribeCollectionFeaturesResponse": {
        "properties": {
          "features": {
            "items": {
              "$ref": "#/components/schemas/CollectionFeatureDescriptor"
            },
            "type": "array",
            "title": "Features",
            "description": "Feature extractors and fields enabled on this collection"
          }
        },
        "type": "object",
        "required": [
          "features"
        ],
        "title": "DescribeCollectionFeaturesResponse",
        "examples": [
          {
            "features": [
              {
                "feature_extractor_name": "gte_modernbert_base",
                "inputs": [
                  {
                    "path": "text",
                    "type": "string"
                  }
                ],
                "outputs": [
                  {
                    "dim": 768,
                    "path": "features.text_embedding",
                    "type": "vector"
                  }
                ],
                "version": "1.0.0"
              }
            ]
          }
        ]
      },
      "DocumentAggregationRequest": {
        "properties": {
          "group_by": {
            "items": {
              "$ref": "#/components/schemas/GroupByField"
            },
            "type": "array",
            "minItems": 1,
            "title": "Group By",
            "description": "Fields to group results by. REQUIRED, at least one field. Can include field transformations (date_trunc, date_part). Results will have one row per unique combination of group_by values."
          },
          "aggregations": {
            "items": {
              "$ref": "#/components/schemas/AggregationOperation"
            },
            "type": "array",
            "minItems": 1,
            "title": "Aggregations",
            "description": "Aggregation operations to perform. REQUIRED, at least one operation. Each operation produces a calculated field in results. Can combine multiple functions (COUNT, SUM, AVG, etc.)."
          },
          "filters": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Filters",
            "description": "Pre-aggregation filters to apply to source data. OPTIONAL, filters data before grouping. Uses same syntax as standard query filters. Applied before GROUP BY.",
            "examples": [
              {
                "metadata.status": "active"
              },
              {
                "created_at": {
                  "$gte": "2024-01-01"
                },
                "metadata.type": "video"
              }
            ]
          },
          "having": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/HavingCondition"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Having",
            "description": "Post-aggregation filters to apply to results. OPTIONAL, filters groups after aggregation. Uses aggregation aliases as field names. Applied after GROUP BY and aggregation calculations."
          },
          "unwind": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Unwind",
            "description": "Array field to unwind before aggregation. OPTIONAL, creates one document per array element. Useful for aggregating over array contents. Example: 'blobs' to analyze each blob separately.",
            "examples": [
              "blobs",
              "metadata.tags",
              "metadata.categories"
            ]
          },
          "range_buckets": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/RangeBucket"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Range Buckets",
            "description": "Range-based bucketing for numeric fields. OPTIONAL, creates histogram-style buckets. Groups numeric values into defined ranges. Applied during grouping stage."
          },
          "sort_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sort By",
            "description": "Field to sort results by. OPTIONAL, can be group_by field or aggregation alias. Defaults to no specific order. Use with sort_direction to control order.",
            "examples": [
              "total_count",
              "avg_duration",
              "category"
            ]
          },
          "sort_direction": {
            "type": "string",
            "title": "Sort Direction",
            "description": "Sort direction. OPTIONAL, defaults to 'desc' (descending). Valid values: 'asc' (ascending), 'desc' (descending). Used with sort_by field.",
            "default": "desc",
            "examples": [
              "asc",
              "desc"
            ]
          },
          "limit": {
            "anyOf": [
              {
                "type": "integer",
                "exclusiveMinimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Limit",
            "description": "Maximum number of results to return. OPTIONAL, no limit if not specified. Applied after sorting. Useful for 'top N' queries.",
            "examples": [
              10,
              50,
              100
            ]
          }
        },
        "type": "object",
        "required": [
          "group_by",
          "aggregations"
        ],
        "title": "DocumentAggregationRequest",
        "description": "Aggregation request for collection documents.\n\nExtends the base AggregationRequest with document-specific context.\nInherits all fields from AggregationRequest.\n\nRequirements:\n    - group_by: REQUIRED, fields to group by\n    - aggregations: REQUIRED, aggregation operations to perform\n    - All other fields from AggregationRequest are available\n\nExamples:\n    - Count documents by feature type\n    - Daily processing statistics\n    - User-based analytics with filtering",
        "examples": [
          {
            "aggregations": [
              {
                "alias": "total",
                "function": "count"
              }
            ],
            "description": "Count documents by collection",
            "group_by": [
              {
                "alias": "collection",
                "field": "collection_id"
              }
            ],
            "sort_by": "total",
            "sort_direction": "desc"
          },
          {
            "aggregations": [
              {
                "alias": "documents",
                "function": "count"
              },
              {
                "alias": "unique_objects",
                "distinct_field": "object_id",
                "function": "count_distinct"
              }
            ],
            "description": "Daily document creation statistics",
            "group_by": [
              {
                "alias": "date",
                "date_trunc": "day",
                "field": "created_at"
              }
            ],
            "sort_by": "date",
            "sort_direction": "asc"
          },
          {
            "aggregations": [
              {
                "alias": "count",
                "function": "count"
              },
              {
                "alias": "avg_confidence",
                "field": "features.confidence",
                "function": "avg"
              }
            ],
            "description": "Feature distribution with filtering",
            "filters": {
              "collection_id": "my-collection"
            },
            "group_by": [
              {
                "alias": "feature_type",
                "field": "features.type"
              }
            ],
            "having": [
              {
                "field": "count",
                "operator": "gte",
                "value": 10
              }
            ],
            "sort_by": "count",
            "sort_direction": "desc"
          }
        ]
      },
      "DocumentAggregationResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/AggregationResult"
            },
            "type": "array",
            "title": "Results",
            "description": "List of aggregation results, one per group."
          },
          "total_groups": {
            "type": "integer",
            "title": "Total Groups",
            "description": "Total number of unique groups returned."
          },
          "query_info": {
            "additionalProperties": true,
            "type": "object",
            "title": "Query Info",
            "description": "Additional information about the query execution. May include collection info, pipeline stages, execution time, etc."
          }
        },
        "type": "object",
        "required": [
          "results",
          "total_groups"
        ],
        "title": "DocumentAggregationResponse",
        "description": "Response containing document aggregation results.\n\nReturns aggregated statistics grouped by specified fields.",
        "examples": [
          {
            "query_info": {
              "collection_id": "my-collection",
              "execution_time_ms": 32,
              "pipeline_stages": 4
            },
            "results": [
              {
                "group": {
                  "collection": "coll_123"
                },
                "metrics": {
                  "total": 523
                }
              },
              {
                "group": {
                  "collection": "coll_456"
                },
                "metrics": {
                  "total": 187
                }
              }
            ],
            "total_groups": 2
          }
        ]
      },
      "DocumentCreateRequest": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "ID of the collection the document belongs to.",
            "example": "collection_123"
          },
          "document_schema_version": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "v1",
                  "v2"
                ]
              },
              {
                "type": "null"
              }
            ],
            "title": "Document Schema Version",
            "description": "Optional override for document schema version. Defaults to 'v1' until flat schema is enabled."
          },
          "root_object_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Root Object Id",
            "description": "Optional denormalized root object identifier provided during creation."
          },
          "root_bucket_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Root Bucket Id",
            "description": "Optional denormalized bucket identifier provided during creation."
          },
          "source_type": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "bucket",
                  "collection"
                ]
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Type",
            "description": "Optional immediate parent type for the document."
          },
          "source_collection_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Collection Id",
            "description": "Optional parent collection identifier when sourced from a collection."
          },
          "source_document_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Document Id",
            "description": "Optional parent document identifier when sourced from a collection."
          },
          "source_object_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Object Id",
            "description": "Optional parent object identifier when sourced directly from a bucket."
          },
          "lineage_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lineage Path",
            "description": "Optional materialized lineage path to set during creation."
          },
          "lineage": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DocumentSourceLineage"
              },
              {
                "type": "null"
              }
            ],
            "description": "Complete lineage tracking for the document. Recommended for decomposition trees."
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Arbitrary metadata for the document."
          },
          "features": {
            "items": {
              "$ref": "#/components/schemas/FeatureModel"
            },
            "type": "array",
            "title": "Features",
            "description": "Features to associate with the document"
          }
        },
        "type": "object",
        "required": [
          "collection_id"
        ],
        "title": "DocumentCreateRequest",
        "description": "Request model for creating a document."
      },
      "DocumentInputHandling": {
        "type": "string",
        "enum": [
          "individual",
          "grouped"
        ],
        "title": "DocumentInputHandling",
        "description": "How documents are provided to the feature extractor."
      },
      "DocumentListStats": {
        "properties": {
          "total_documents": {
            "type": "integer",
            "title": "Total Documents",
            "description": "Total number of documents in the result",
            "default": 0
          },
          "avg_blobs_per_document": {
            "type": "number",
            "title": "Avg Blobs Per Document",
            "description": "Average number of source blobs per document",
            "default": 0.0
          },
          "documents_with_vectors": {
            "type": "integer",
            "title": "Documents With Vectors",
            "description": "Number of documents with vector embeddings",
            "default": 0
          }
        },
        "type": "object",
        "title": "DocumentListStats",
        "description": "Aggregate statistics for a list of documents."
      },
      "DocumentOutputType": {
        "type": "string",
        "enum": [
          "single",
          "multiple"
        ],
        "title": "DocumentOutputType",
        "description": "Enum for document output types."
      },
      "DocumentResponse": {
        "properties": {
          "document_id": {
            "type": "string",
            "title": "Document Id",
            "description": "REQUIRED. Unique identifier for the document. Format: 'doc_' prefix + alphanumeric characters. Use for: API queries, references, filtering.",
            "examples": [
              "doc_f8966ff29c18e20c6b45e053",
              "doc_abc123"
            ]
          },
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "REQUIRED. ID of the collection this document belongs to. Format: 'col_' prefix + alphanumeric characters. Use for: Collection-scoped queries, filtering.",
            "examples": [
              "col_articles",
              "col_video_frames"
            ]
          },
          "document_schema_version": {
            "type": "string",
            "enum": [
              "v1",
              "v2"
            ],
            "title": "Document Schema Version",
            "description": "Schema version of the document payload returned by the API.",
            "default": "v1",
            "examples": [
              "v1",
              "v2"
            ]
          },
          "root_object_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Root Object Id",
            "description": "Denormalized root object identifier for the document.",
            "examples": [
              "obj_video123"
            ]
          },
          "root_bucket_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Root Bucket Id",
            "description": "Denormalized bucket identifier for the document's root object.",
            "examples": [
              "bkt_marketing"
            ]
          },
          "source_type": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "bucket",
                  "collection"
                ]
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Type",
            "description": "Immediate parent type that produced this document (bucket or collection).",
            "examples": [
              "bucket",
              "collection"
            ]
          },
          "source_collection_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Collection Id",
            "description": "Collection identifier of the immediate parent when sourced from a collection.",
            "examples": [
              "col_frames"
            ]
          },
          "source_document_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Document Id",
            "description": "Document identifier of the immediate parent when sourced from a collection.",
            "examples": [
              "doc_frame_050"
            ]
          },
          "source_object_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Object Id",
            "description": "Bucket object identifier of the immediate parent when sourced from a bucket.",
            "examples": [
              "obj_video_123"
            ]
          },
          "lineage_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lineage Path",
            "description": "Materialized lineage path for fast lookups (e.g., 'bkt_123/col_frames/col_scenes').",
            "examples": [
              "bkt_marketing/col_frames/col_scenes"
            ]
          },
          "lineage": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DocumentSourceLineage"
              },
              {
                "type": "null"
              }
            ],
            "description": "NOT REQUIRED (optional for v2 flat schema). Complete lineage from root object through all transformations. Contains: root_object_id, root_bucket_id, source_type, lineage_chain. For v2 schema, lineage data is stored as flat fields on the document. Use lineage.root_object_id to access the source object ID. Use lineage.root_bucket_id to fetch the source object: GET /buckets/{root_bucket_id}/objects/{root_object_id}"
          },
          "source_blobs": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Source Blobs",
            "description": "Lightweight references to source object's blobs (blob_id, blob_property, blob_type). For full details, fetch: GET /buckets/{bucket_id}/objects/{object_id}"
          },
          "internal_metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Internal Metadata",
            "description": "System metadata (ingestion_status, feature_extractor_config_hash, etc.)"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "User-provided metadata inherited from the source object"
          },
          "vector": {
            "anyOf": [
              {
                "items": {
                  "type": "number"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Vector",
            "description": "Vector embedding for the document (only included when return_vectors=true)"
          },
          "presigned_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Presigned Url",
            "description": "NOT REQUIRED - only populated when return_url=true query parameter is used. Single presigned URL for the primary source blob (for backward compatibility). For multiple blobs, use presigned_urls array or document_blobs[].presigned_url instead."
          },
          "document_blobs": {
            "items": {
              "$ref": "#/components/schemas/BlobURLRef"
            },
            "type": "array",
            "title": "Document Blobs",
            "description": "Artifacts generated during feature extraction (thumbnails, processed outputs). When return_url=true, each entry includes a presigned_url field."
          },
          "presigned_urls": {
            "items": {
              "$ref": "#/components/schemas/PresignedURLModel"
            },
            "type": "array",
            "title": "Presigned Urls",
            "description": "Aggregated presigned URLs for all blobs. Only populated when return_url=true query parameter is provided."
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "document_id",
          "collection_id"
        ],
        "title": "DocumentResponse",
        "description": "Response model for a single document.\n\nThis is the standard response format when fetching documents via API endpoints.\nContains all document data plus optional presigned URLs for S3 blobs.\n\nKey Fields:\n    - document_id: Application ID for queries/references\n    - lineage: Complete processing history and source tracking\n    - metadata: User fields from field_passthrough\n    - source_blobs: Which blobs from source object were processed\n    - document_blobs: Artifacts generated by extractor (thumbnails, etc.)\n    - enrichment fields: Flat taxonomy/cluster fields (e.g., taxonomy_*_label, cluster_id)\n\nQuery Parameters Affecting Response:\n    - return_url=true: Adds presigned_url to each document_blobs entry\n    - return_vectors=true: Includes embedding arrays in response\n\nUse Cases:\n    - Display document details in UI\n    - Download source files or generated artifacts\n    - Understand document provenance and processing\n    - Access enrichment fields (flat) for filtering/display",
        "examples": [
          {
            "collection_id": "col_articles",
            "description": "Text document without artifacts (return_url=false)",
            "document_blobs": [],
            "document_id": "doc_f8966ff29c18e20c6b45e053",
            "internal_metadata": {
              "ingestion_status": "COMPLETED"
            },
            "lineage": {
              "root_bucket_id": "bkt_content",
              "root_object_id": "obj_article_001",
              "source_object_id": "obj_article_001",
              "source_type": "bucket"
            },
            "metadata": {
              "author": "Dr. Smith",
              "title": "AI in Healthcare"
            },
            "presigned_urls": [],
            "source_blobs": [
              {
                "blob_id": "blob_text_001",
                "blob_property": "content",
                "blob_type": "text"
              }
            ]
          },
          {
            "cluster_distance": 0.15,
            "cluster_id": "cl_marketing",
            "collection_id": "col_video_frames",
            "description": "Video document with thumbnail artifact (return_url=true)",
            "document_blobs": [
              {
                "field": "thumbnail",
                "presigned_url": "https://s3.amazonaws.com/bucket/thumbnails/frame_050.jpg?X-Amz-Signature=...",
                "role": "thumbnail",
                "type": "image",
                "url": "s3://bucket/thumbnails/frame_050.jpg"
              }
            ],
            "document_id": "doc_frame_050",
            "lineage": {
              "root_bucket_id": "bkt_marketing",
              "root_object_id": "obj_video_123",
              "source_object_id": "obj_video_123",
              "source_type": "bucket"
            },
            "metadata": {
              "campaign_id": "Q4_2025",
              "duration": 120
            },
            "presigned_urls": [],
            "source_blobs": [
              {
                "blob_id": "blob_video_001",
                "blob_property": "video",
                "blob_type": "video"
              }
            ],
            "taxonomy_products_label": "Electronics",
            "taxonomy_products_score": 0.87
          },
          {
            "cluster_distance": 0.22,
            "cluster_id": "cl_scenes_action",
            "collection_id": "col_scenes",
            "description": "Multi-tier document (collection source) with enrichments",
            "document_blobs": [],
            "document_id": "doc_scene_042",
            "lineage": {
              "lineage_chain": [
                {
                  "collection_id": "col_frames",
                  "feature_extractor_id": "video_extractor_v1"
                },
                {
                  "collection_id": "col_scenes",
                  "feature_extractor_id": "scene_detector_v1"
                }
              ],
              "root_bucket_id": "bkt_marketing",
              "root_object_id": "obj_video_123",
              "source_collection_id": "col_video_frames",
              "source_document_id": "doc_frame_050",
              "source_type": "collection"
            },
            "metadata": {
              "campaign_id": "Q4_2025"
            },
            "source_blobs": [
              {
                "blob_id": "blob_video_001",
                "blob_property": "video",
                "blob_type": "video"
              }
            ]
          }
        ]
      },
      "DocumentSourceLineage": {
        "properties": {
          "root_object_id": {
            "type": "string",
            "title": "Root Object Id",
            "description": "REQUIRED. Original object ID from bucket (root of decomposition tree). All documents derived from the same object share this ID, even through multi-tier processing. Use to: Query all documents from a specific source, build decomposition trees, trace lineage. Format: 'obj_' prefix + alphanumeric characters. Example: Video \u2192 120 frames \u2192 10 scenes all share same root_object_id.",
            "examples": [
              "obj_video123",
              "obj_book456",
              "obj_product789"
            ]
          },
          "root_bucket_id": {
            "type": "string",
            "title": "Root Bucket Id",
            "description": "REQUIRED. Bucket ID containing the root object. Identifies where the original raw data is stored. Use to: Fetch source object, understand data origin, organize by bucket. Format: 'bkt_' prefix + alphanumeric characters. Combined with root_object_id, provides complete path to source: /buckets/{root_bucket_id}/objects/{root_object_id}",
            "examples": [
              "bkt_marketing_videos",
              "bkt_product_catalog",
              "bkt_documents"
            ]
          },
          "source_type": {
            "type": "string",
            "enum": [
              "bucket",
              "collection"
            ],
            "title": "Source Type",
            "description": "REQUIRED. Type of immediate parent source for this document. 'bucket': Document created directly from bucket object (first-stage processing, tier 1). 'collection': Document created from another collection's documents (downstream processing, tier 2+). Use to: Determine if this is first-level or multi-tier processed data. Example: bucket \u2192 frames (source_type='bucket'), frames \u2192 scenes (source_type='collection').",
            "examples": [
              "bucket",
              "collection"
            ]
          },
          "source_object_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Object Id",
            "description": "REQUIRED when source_type='bucket', NOT REQUIRED when source_type='collection'. Object ID of immediate parent when document created from bucket. For first-stage processing, this equals root_object_id. Use to: Identify immediate source object for tier-1 documents. Example: Video extractor processes obj_video123 \u2192 source_object_id = obj_video123.",
            "examples": [
              "obj_video123",
              "obj_document456"
            ]
          },
          "source_document_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Document Id",
            "description": "REQUIRED when source_type='collection', NOT REQUIRED when source_type='bucket'. Document ID of immediate parent when document created from collection. Points to the specific upstream document that was processed to create this document. Use to: Trace back one level in decomposition tree, understand transformation flow. Example: Scene detector processes doc_frame050 \u2192 source_document_id = doc_frame050.",
            "examples": [
              "doc_frame050",
              "doc_chapter05",
              "doc_paragraph_003"
            ]
          },
          "source_collection_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Collection Id",
            "description": "REQUIRED when source_type='collection', NOT REQUIRED when source_type='bucket'. Collection ID of immediate parent when document created from collection. Identifies which upstream collection provided the source document. Use to: Navigate decomposition tree, query upstream documents, validate dependencies. Example: Scenes from frames \u2192 source_collection_id = col_video_frames.",
            "examples": [
              "col_video_frames",
              "col_book_chapters",
              "col_paragraphs"
            ]
          },
          "lineage_chain": {
            "items": {
              "$ref": "#/components/schemas/LineageStep"
            },
            "type": "array",
            "title": "Lineage Chain",
            "description": "NOT REQUIRED (defaults to empty list). Ordered list of processing steps from root object to this document. Each step shows: collection_id, feature_extractor_id, document_id (if intermediate), timestamp. Length indicates depth in the decomposition tree (1 = tier 1, 2 = tier 2, 3 = tier 3, etc.). Use for: Visualizing processing pipeline, debugging, understanding transformation flow. Example: [frames step, scenes step] = 2-tier processing.",
            "examples": [
              [
                {
                  "collection_id": "col_frames",
                  "feature_extractor_id": "video_extractor_v1",
                  "timestamp": "2025-10-21T10:00:00Z"
                }
              ],
              []
            ]
          }
        },
        "type": "object",
        "required": [
          "root_object_id",
          "root_bucket_id",
          "source_type"
        ],
        "title": "DocumentSourceLineage",
        "description": "Complete lineage chain for a document in a decomposition tree.\n\nEvery document in Mixpeek tracks its complete processing history from the\noriginal raw object in a bucket through all transformation stages.\n\nThis enables:\n- Tracing any document back to its source object\n- Understanding the full processing pipeline\n- Querying all documents derived from a specific object\n- Building decomposition tree visualizations\n\nExample lineage for a scene document:\n    Object (video) \u2192 Frames Collection \u2192 Scenes Collection\n    root_object_id tracks the original video\n    lineage_chain shows: [frames step, scenes step]\n\nExample:\n    ```python\n    # First-level processing (bucket \u2192 collection)\n    lineage = DocumentSourceLineage(\n        root_object_id=\"obj_video123\",\n        root_bucket_id=\"bkt_marketing\",\n        source_type=\"bucket\",\n        source_object_id=\"obj_video123\",\n        lineage_chain=[\n            LineageStep(\n                collection_id=\"col_frames\",\n                feature_extractor_id=\"video_extractor_v1\",\n                timestamp=datetime.now()\n            )\n        ]\n    )\n\n    # Second-level processing (collection \u2192 collection)\n    lineage = DocumentSourceLineage(\n        root_object_id=\"obj_video123\",\n        root_bucket_id=\"bkt_marketing\",\n        source_type=\"collection\",\n        source_document_id=\"doc_frame050\",\n        source_collection_id=\"col_frames\",\n        lineage_chain=[\n            LineageStep(...),  # frames step\n            LineageStep(...)   # scenes step\n        ]\n    )\n    ```",
        "examples": [
          {
            "description": "First-level processing: video \u2192 frames",
            "lineage_chain": [
              {
                "collection_id": "col_frames",
                "feature_extractor_id": "video_extractor_v1",
                "timestamp": "2025-10-18T10:30:00Z"
              }
            ],
            "root_bucket_id": "bkt_marketing",
            "root_object_id": "obj_video123",
            "source_object_id": "obj_video123",
            "source_type": "bucket"
          },
          {
            "description": "Second-level processing: frames \u2192 scenes",
            "lineage_chain": [
              {
                "collection_id": "col_frames",
                "document_id": "doc_frame050",
                "feature_extractor_id": "video_extractor_v1",
                "timestamp": "2025-10-18T10:30:00Z"
              },
              {
                "collection_id": "col_scenes",
                "feature_extractor_id": "scene_detector_v1",
                "timestamp": "2025-10-18T10:31:15Z"
              }
            ],
            "root_bucket_id": "bkt_marketing",
            "root_object_id": "obj_video123",
            "source_collection_id": "col_frames",
            "source_document_id": "doc_frame050",
            "source_type": "collection"
          }
        ]
      },
      "DocumentUpdateRequest": {
        "properties": {
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "New metadata for the document to update."
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "DocumentUpdateRequest",
        "description": "Request model for updating a document."
      },
      "DynamicValue": {
        "properties": {
          "type": {
            "type": "string",
            "const": "dynamic",
            "title": "Type",
            "default": "dynamic"
          },
          "field": {
            "type": "string",
            "title": "Field",
            "description": "The dot-notation path to the value in the runtime query request, e.g., 'inputs.user_id'",
            "examples": [
              "inputs.query_text",
              "filters.AND[0].value"
            ]
          }
        },
        "type": "object",
        "required": [
          "field"
        ],
        "title": "DynamicValue",
        "description": "A value that should be dynamically resolved from the query request."
      },
      "EmailConfig": {
        "properties": {
          "to_addresses": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "To Addresses",
            "description": "Email addresses to send to"
          },
          "subject_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Subject Template",
            "description": "Template for email subject"
          },
          "body_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Body Template",
            "description": "Template for email body"
          },
          "content_type": {
            "$ref": "#/components/schemas/NotificationContentType",
            "description": "Format of the email body",
            "default": "html"
          },
          "cc_addresses": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Cc Addresses",
            "description": "CC addresses"
          },
          "bcc_addresses": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Bcc Addresses",
            "description": "BCC addresses"
          }
        },
        "type": "object",
        "required": [
          "to_addresses"
        ],
        "title": "EmailConfig",
        "description": "Configuration for email notifications."
      },
      "EnrichmentField": {
        "properties": {
          "field_path": {
            "type": "string",
            "title": "Field Path",
            "description": "Dot-notation path of the field to copy from the taxonomy node."
          },
          "merge_mode": {
            "$ref": "#/components/schemas/EnrichmentMergeMode",
            "description": "Whether to overwrite the target's value or append (for arrays).",
            "default": "replace"
          }
        },
        "type": "object",
        "required": [
          "field_path"
        ],
        "title": "EnrichmentField",
        "description": "Field-level enrichment behaviour specification.",
        "examples": [
          {
            "field_path": "metadata.tags",
            "merge_mode": "append"
          },
          {
            "field_path": "category",
            "merge_mode": "replace"
          }
        ]
      },
      "EnrichmentMergeMode": {
        "type": "string",
        "enum": [
          "replace",
          "append"
        ],
        "title": "EnrichmentMergeMode",
        "description": "How a field from the taxonomy node should be merged into the target doc."
      },
      "ErrorDetail": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable error message"
          },
          "type": {
            "type": "string",
            "title": "Type",
            "description": "Stable error type identifier (machine-readable)"
          },
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Details",
            "description": "Optional structured details to help debugging (validation errors, IDs, etc.)"
          }
        },
        "type": "object",
        "required": [
          "message",
          "type"
        ],
        "title": "ErrorDetail",
        "description": "Error detail model."
      },
      "ErrorResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Always false for error responses",
            "default": false
          },
          "status": {
            "type": "integer",
            "title": "Status",
            "description": "HTTP status code for this error"
          },
          "error": {
            "$ref": "#/components/schemas/ErrorDetail",
            "description": "Error details payload"
          }
        },
        "type": "object",
        "required": [
          "status",
          "error"
        ],
        "title": "ErrorResponse",
        "description": "Error response model.",
        "examples": [
          {
            "error": {
              "details": {
                "id": "ns_123",
                "resource": "namespace"
              },
              "message": "Namespace not found",
              "type": "NotFoundError"
            },
            "status": 404,
            "success": false
          }
        ]
      },
      "EvaluationRequest": {
        "properties": {
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "The ID of the retriever to evaluate."
          },
          "dataset_name": {
            "type": "string",
            "title": "Dataset Name",
            "description": "A name for the evaluation dataset directory located under the `evaluations/` root folder."
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "dataset_name"
        ],
        "title": "EvaluationRequest",
        "description": "Request model for initiating a retriever evaluation."
      },
      "ExecuteClusterRequest": {
        "properties": {
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Collection Ids",
            "description": "IDs of the collections to cluster together"
          },
          "config": {
            "$ref": "#/components/schemas/ClusteringConfig",
            "description": "Clustering configuration including algorithm and parameters"
          },
          "namespace_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Namespace Id",
            "description": "Namespace ID for the request"
          },
          "internal_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Internal Id",
            "description": "Internal ID for the request"
          },
          "sample_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sample Size",
            "description": "Number of documents to sample for clustering"
          },
          "store_results": {
            "type": "boolean",
            "title": "Store Results",
            "description": "Whether to store clustering results",
            "default": true
          },
          "include_members": {
            "type": "boolean",
            "title": "Include Members",
            "description": "Whether to include cluster membership in results",
            "default": false
          },
          "compute_metrics": {
            "type": "boolean",
            "title": "Compute Metrics",
            "description": "Whether to compute clustering quality metrics",
            "default": true
          },
          "save_artifacts": {
            "type": "boolean",
            "title": "Save Artifacts",
            "description": "Whether to save clustering artifacts (e.g., parquet) to S3",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "collection_ids",
          "config"
        ],
        "title": "ExecuteClusterRequest",
        "description": "Request to execute clustering on one or more collections.",
        "examples": [
          {
            "collection_ids": [
              "col_products_v1",
              "col_products_v2"
            ],
            "compute_metrics": true,
            "config": {
              "algorithm": "kmeans",
              "algorithm_params": {
                "max_iter": 300,
                "n_clusters": 5
              },
              "feature_vector": {
                "vector_name": "text_extractor_v1_embedding"
              },
              "normalize_features": true
            },
            "include_members": false,
            "sample_size": 10000,
            "store_results": true
          }
        ]
      },
      "ExecuteClusterResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether clustering was successful"
          },
          "run_id": {
            "type": "string",
            "title": "Run Id",
            "description": "Unique identifier for this clustering run"
          },
          "algorithm": {
            "$ref": "#/components/schemas/ClusteringAlgorithm",
            "description": "Algorithm used for clustering"
          },
          "num_clusters": {
            "type": "integer",
            "title": "Num Clusters",
            "description": "Number of clusters found"
          },
          "num_documents": {
            "type": "integer",
            "title": "Num Documents",
            "description": "Number of documents clustered"
          },
          "centroids": {
            "items": {
              "$ref": "#/components/schemas/ClusterCentroid"
            },
            "type": "array",
            "title": "Centroids",
            "description": "Cluster centroids with features"
          },
          "metrics": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Metrics",
            "description": "Clustering quality metrics"
          },
          "parquet_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parquet Path",
            "description": "S3 key path to parquet file with full results"
          },
          "members_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Members Key",
            "description": "S3 key to members.parquet (if saved)"
          },
          "execution_time_ms": {
            "type": "integer",
            "title": "Execution Time Ms",
            "description": "Total execution time in milliseconds"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp of clustering"
          }
        },
        "type": "object",
        "required": [
          "success",
          "algorithm",
          "num_clusters",
          "num_documents",
          "centroids",
          "execution_time_ms"
        ],
        "title": "ExecuteClusterResponse",
        "description": "Response from cluster execution.",
        "examples": [
          {
            "algorithm": "kmeans",
            "centroids": [
              {
                "centroid_vector": [
                  0.1,
                  0.2,
                  0.3
                ],
                "cluster_id": "cluster_001",
                "feature_dimensions": 512,
                "num_members": 2000,
                "vector_name": "product_embedding"
              }
            ],
            "created_at": "2024-01-15T10:30:00Z",
            "execution_time_ms": 5432,
            "members_key": "int_abc123/ns_xyz789/engine_cluster_build/run_xyz789/members.parquet",
            "metrics": {
              "davies_bouldin_score": 0.8,
              "silhouette_score": 0.65
            },
            "num_clusters": 5,
            "num_documents": 10000,
            "parquet_path": "int_abc123/ns_xyz789/engine_cluster_build/run_xyz789/clusters.parquet",
            "run_id": "run_xyz789",
            "success": true
          }
        ]
      },
      "ExecuteRetrieverRequest": {
        "properties": {
          "inputs": {
            "additionalProperties": true,
            "type": "object",
            "title": "Inputs",
            "description": "Runtime inputs for the pipeline mapped to the input schema. Keys must match the pipeline's input_schema field names. Values depend on field types (text, vector, filters, etc.). REQUIRED unless all pipeline inputs have defaults. \n\nCommon input keys:\n- 'query': Text search query\n- 'embedding': Pre-computed vector for search\n- 'filter': Additional filters to apply\n\n\nExample: {\"query\": \"machine learning\", \"limit\": 50}",
            "examples": [
              {
                "query": "artificial intelligence"
              },
              {
                "min_score": 0.7,
                "query": "customer feedback"
              },
              {
                "category": "blog",
                "embedding": [
                  0.1,
                  0.2,
                  0.3
                ]
              }
            ]
          },
          "collection_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Collection Ids",
            "description": "OPTIONAL. List of collection IDs to search. When provided, OVERRIDES the pipeline's default collection_ids. Use this to dynamically filter which collections to query at runtime. Can be combined with collection_names (both will be merged). When NOT provided, uses the pipeline's default collections. \n\nUse cases:\n- Search subset of pipeline collections: [\"col_123\", \"col_456\"]\n- Search single collection: [\"col_primary\"]\n- Test different collection combinations\n\n\nNote: Collection IDs must exist in the namespace or request will fail.",
            "examples": [
              [
                "col_marketing_2024",
                "col_sales_2024"
              ],
              [
                "col_product_catalog"
              ],
              [
                "col_archived_docs",
                "col_current_docs"
              ]
            ]
          },
          "collection_names": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Collection Names",
            "description": "OPTIONAL. List of collection names to search (human-readable identifiers). Names are resolved to collection IDs automatically before execution. When provided, OVERRIDES the pipeline's default collections. Can be combined with collection_ids (both will be merged). When NOT provided, uses the pipeline's default collections. \n\nBenefits:\n- More readable than remembering collection IDs\n- Stable across environments (dev/staging/prod)\n- Easier for humans to understand query scope\n\n\nNote: Names must match exactly (case-sensitive). If a name doesn't exist, request will fail with NotFoundError.",
            "examples": [
              [
                "marketing_campaigns",
                "sales_materials"
              ],
              [
                "product_documentation"
              ],
              [
                "blog_posts",
                "case_studies",
                "whitepapers"
              ]
            ]
          },
          "pagination": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/OffsetPaginationParams"
              },
              {
                "$ref": "#/components/schemas/CursorPaginationParams"
              },
              {
                "$ref": "#/components/schemas/ScrollPaginationParams"
              },
              {
                "$ref": "#/components/schemas/KeysetPaginationParams"
              }
            ],
            "title": "Pagination",
            "description": "Pagination strategy configuration. Defaults to cursor-based pagination with limit=20. Supported methods: OFFSET, CURSOR, SCROLL, KEYSET. Each method has different tradeoffs for performance and use cases."
          },
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "OPTIONAL. Additional filters applied during pipeline execution. These filters are MERGED with any filters defined in pipeline stages. Use LogicalOperator for complex AND/OR/NOT logic. When NOT provided, only pipeline stage filters apply."
          }
        },
        "type": "object",
        "title": "ExecuteRetrieverRequest",
        "description": "Request to execute a retriever.",
        "examples": [
          {
            "description": "Simple query with pipeline defaults",
            "inputs": {
              "query": "artificial intelligence trends"
            }
          },
          {
            "collection_ids": [
              "col_products_2024",
              "col_documentation"
            ],
            "description": "Query with collection ID override",
            "inputs": {
              "query": "product features"
            }
          },
          {
            "collection_names": [
              "customer_feedback",
              "case_studies"
            ],
            "description": "Query with collection name override (human-readable)",
            "inputs": {
              "query": "customer testimonials"
            }
          },
          {
            "collection_ids": [
              "col_archived_security"
            ],
            "collection_names": [
              "current_security_docs"
            ],
            "description": "Mix collection IDs and names",
            "inputs": {
              "query": "security best practices"
            }
          },
          {
            "collection_names": [
              "blog_posts",
              "research_papers"
            ],
            "description": "Multi-collection search with filters and pagination",
            "filters": {
              "AND": [
                {
                  "field": "published_date",
                  "operator": "gte",
                  "value": "2024-01-01"
                },
                {
                  "field": "category",
                  "operator": "in",
                  "value": [
                    "AI",
                    "ML"
                  ]
                }
              ]
            },
            "inputs": {
              "query": "machine learning"
            },
            "pagination": {
              "cursor": "next_page_token_abc",
              "limit": 50
            }
          }
        ]
      },
      "ExecuteRetrieverResponse": {
        "properties": {
          "execution_id": {
            "type": "string",
            "title": "Execution Id",
            "description": "Identifier of this execution run (REQUIRED)."
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Execution status (e.g., 'completed', 'failed') (REQUIRED)."
          },
          "documents": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Documents",
            "description": "Final document results after pipeline completion (REQUIRED)."
          },
          "pagination": {
            "additionalProperties": true,
            "type": "object",
            "title": "Pagination",
            "description": "Pagination metadata (varies by pagination method) (REQUIRED)."
          },
          "stage_statistics": {
            "$ref": "#/components/schemas/PipelineExecutionStatistics",
            "description": "Per-stage execution statistics (REQUIRED)."
          },
          "budget": {
            "additionalProperties": true,
            "type": "object",
            "title": "Budget",
            "description": "Snapshot of budget usage for this execution (REQUIRED)."
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Pipeline-level error if execution failed (OPTIONAL)."
          }
        },
        "type": "object",
        "required": [
          "execution_id",
          "status"
        ],
        "title": "ExecuteRetrieverResponse",
        "description": "Response from retriever execution."
      },
      "ExecuteTaxonomyRequest": {
        "properties": {
          "taxonomy": {
            "$ref": "#/components/schemas/TaxonomyModel",
            "description": "Full taxonomy model with configuration (fetched from DB by controller)"
          },
          "retriever": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/RetrieverModel-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional retriever configuration override for testing. If omitted, uses the retriever configured in the taxonomy."
          },
          "source_documents": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Documents",
            "description": "Sample documents to test enrichment (typically 1-5 docs). Results are returned immediately, not persisted. \u26a0\ufe0f Do NOT pass collection_id expecting batch processing!"
          },
          "source_collection_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Source Collection Id",
            "description": "\u26a0\ufe0f IGNORED IN ON_DEMAND MODE. This field exists for legacy compatibility only. To enrich collections, use taxonomy_applications on the collection."
          },
          "target_collection_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Target Collection Id",
            "description": "\u26a0\ufe0f IGNORED IN ON_DEMAND MODE. This field exists for legacy compatibility only. Results are never persisted via this endpoint."
          },
          "join_mode": {
            "$ref": "#/components/schemas/JoinMode",
            "description": "Must be 'on_demand'. BATCH mode is NOT supported via API. Batch enrichment is automatic (triggered by engine during ingestion).",
            "default": "on_demand"
          },
          "batch_size": {
            "type": "integer",
            "maximum": 10000.0,
            "minimum": 1.0,
            "title": "Batch Size",
            "description": "Batch size for the scroll iterator",
            "default": 1000
          },
          "scroll_filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional filters applied to the source collection prior to enrichment."
          }
        },
        "type": "object",
        "required": [
          "taxonomy"
        ],
        "title": "ExecuteTaxonomyRequest",
        "description": "Request model for on-demand taxonomy validation and testing ONLY.\n\n\u26a0\ufe0f IMPORTANT: This endpoint is ONLY for testing taxonomy configuration with sample documents.\n\nDO NOT USE THIS FOR BATCH ENRICHMENT:\n\u274c Do NOT use this to enrich an entire collection\n\u274c Do NOT use source_collection_id expecting batch processing\n\u274c Do NOT use target_collection_id expecting persistence\n\nHOW TAXONOMY ENRICHMENT ACTUALLY WORKS:\n\u2705 Automatic during ingestion: Attach taxonomies to collections via `taxonomy_applications`\n\u2705 On-the-fly in retrieval: Add `taxonomy_join` stage to retriever pipelines\n\nThis endpoint validates:\n- Taxonomy configuration is correct\n- Retriever can find matching taxonomy nodes\n- Enrichment fields are properly applied\n\nFor production enrichment, see:\n- Collections API: attach taxonomies via `taxonomy_applications` field\n- Retrievers API: add `taxonomy_join` stage for on-the-fly enrichment",
        "examples": [
          {
            "batch_size": 1000,
            "join_mode": "on_demand",
            "source_collection_id": "col_catalog_v2",
            "target_collection_id": "col_catalog_enriched_v2",
            "taxonomy": {
              "config": {
                "input_mappings": [
                  {
                    "input_key": "image_vector",
                    "path": "features.clip",
                    "source_type": "vector"
                  }
                ],
                "retriever_id": "ret_clip_v1",
                "source_collection": {
                  "collection_id": "col_products_v1"
                },
                "taxonomy_type": "flat"
              },
              "input_mappings": [
                {
                  "input_key": "image_vector",
                  "path": "features.clip",
                  "source_type": "vector"
                }
              ],
              "namespace_id": "ns_123",
              "retriever_id": "ret_clip_v1",
              "taxonomy_name": "product_tags"
            }
          }
        ]
      },
      "ExecutionDetail": {
        "properties": {
          "execution_id": {
            "type": "string",
            "title": "Execution Id",
            "description": "Identifier of this execution run (REQUIRED)."
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Execution status (e.g., 'completed', 'failed') (REQUIRED)."
          },
          "documents": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Documents",
            "description": "Final document results after pipeline completion (REQUIRED)."
          },
          "pagination": {
            "additionalProperties": true,
            "type": "object",
            "title": "Pagination",
            "description": "Pagination metadata (varies by pagination method) (REQUIRED)."
          },
          "stage_statistics": {
            "$ref": "#/components/schemas/PipelineExecutionStatistics",
            "description": "Per-stage execution statistics (REQUIRED)."
          },
          "budget": {
            "additionalProperties": true,
            "type": "object",
            "title": "Budget",
            "description": "Snapshot of budget usage for this execution (REQUIRED)."
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Pipeline-level error if execution failed (OPTIONAL)."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp when execution began"
          },
          "completed_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completed At",
            "description": "Timestamp when execution finished"
          },
          "current_stage": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Current Stage",
            "description": "Stage currently running when execution in-flight"
          },
          "stages_completed": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Stages Completed",
            "description": "Number of stages finished so far",
            "default": 0
          },
          "total_stages": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Stages",
            "description": "Total stages configured",
            "default": 0
          }
        },
        "type": "object",
        "required": [
          "execution_id",
          "status"
        ],
        "title": "ExecutionDetail",
        "description": "Alias wrapper for execution detail documentation."
      },
      "ExplainRetrieverRequest": {
        "properties": {
          "inputs": {
            "additionalProperties": true,
            "type": "object",
            "title": "Inputs",
            "description": "Hypothetical inputs used to tailor estimation"
          },
          "filters": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Filters",
            "description": "Optional filter hints for explain plan"
          }
        },
        "type": "object",
        "title": "ExplainRetrieverRequest",
        "description": "Request to get execution plan for a retriever."
      },
      "ExplainRetrieverResponse": {
        "properties": {
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "Retriever identifier"
          },
          "retriever_name": {
            "type": "string",
            "title": "Retriever Name",
            "description": "Retriever name"
          },
          "estimated_cost": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Estimated Cost",
            "description": "Estimated cost breakdown (credits/time)"
          },
          "execution_plan": {
            "items": {
              "$ref": "#/components/schemas/ExplainStagePlan"
            },
            "type": "array",
            "title": "Execution Plan",
            "description": "Ordered stage plan"
          },
          "optimization_suggestions": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Optimization Suggestions",
            "description": "Potential optimizations"
          },
          "total_estimated_stages": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Estimated Stages",
            "description": "Total stages considered"
          },
          "bottleneck_stages": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Bottleneck Stages",
            "description": "Stages expected to dominate cost"
          },
          "optimization_level": {
            "type": "string",
            "title": "Optimization Level",
            "description": "Optimizer level applied (e.g., none/mvp/advanced)",
            "default": "mvp"
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "retriever_name",
          "estimated_cost",
          "total_estimated_stages"
        ],
        "title": "ExplainRetrieverResponse",
        "description": "Explain plan response for a retriever."
      },
      "ExplainStagePlan": {
        "properties": {
          "stage_index": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Stage Index",
            "description": "Zero-based stage index"
          },
          "stage_name": {
            "type": "string",
            "title": "Stage Name",
            "description": "Stage instance name"
          },
          "stage_type": {
            "type": "string",
            "title": "Stage Type",
            "description": "Stage type identifier"
          },
          "estimated_input": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Estimated Input",
            "description": "Estimated documents entering stage"
          },
          "estimated_output": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Estimated Output",
            "description": "Estimated documents leaving stage"
          },
          "estimated_efficiency": {
            "type": "number",
            "minimum": 0.0,
            "title": "Estimated Efficiency",
            "description": "Estimated output/input ratio"
          },
          "estimated_cost_credits": {
            "type": "number",
            "minimum": 0.0,
            "title": "Estimated Cost Credits",
            "description": "Estimated credit cost"
          },
          "estimated_duration_ms": {
            "type": "number",
            "minimum": 0.0,
            "title": "Estimated Duration Ms",
            "description": "Estimated latency contribution"
          },
          "cache_likely": {
            "type": "boolean",
            "title": "Cache Likely",
            "description": "Whether cache hit is likely"
          },
          "optimization_notes": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Optimization Notes",
            "description": "Hints specific to this stage"
          },
          "warnings": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Warnings",
            "description": "Warnings associated with this stage"
          }
        },
        "type": "object",
        "required": [
          "stage_index",
          "stage_name",
          "stage_type",
          "estimated_input",
          "estimated_output",
          "estimated_efficiency",
          "estimated_cost_credits",
          "estimated_duration_ms",
          "cache_likely"
        ],
        "title": "ExplainStagePlan",
        "description": "Stage-level details returned from explain plan endpoint."
      },
      "FeatureAddress": {
        "properties": {
          "scheme": {
            "type": "string",
            "title": "Scheme",
            "default": "mixpeek"
          },
          "extractor": {
            "type": "string",
            "title": "Extractor"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "output": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Output"
          }
        },
        "type": "object",
        "required": [
          "extractor",
          "version"
        ],
        "title": "FeatureAddress",
        "description": "Canonical feature address: mixpeek://{extractor}@{version}/{output}.\n\nShort form without the output segment is allowed only if the extractor has\na single vector output."
      },
      "FeatureExtractorConfig-Input": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Version of the feature extractor"
          },
          "parameters": {
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ParameterConfig"
                },
                {}
              ]
            },
            "type": "object",
            "title": "Parameters",
            "description": "Parameters for the feature extractor (model name, thresholds, etc.). See extractor-specific documentation for available parameters.",
            "examples": [
              {
                "dimensions": 1536,
                "model": "text-embedding-3-small"
              },
              {
                "fps": 1,
                "max_frames": 100
              }
            ]
          },
          "input_mappings": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              }
            ],
            "title": "Input Mappings",
            "description": "Mapping from extractor input names to source field paths. Tells the extractor which source fields to process. Example: {'image': 'thumbnail_url', 'text': 'description'}",
            "examples": [
              {
                "image": "product_image",
                "text": "title"
              },
              {
                "video": "video_url"
              },
              {
                "text": "content"
              }
            ]
          },
          "field_passthrough": {
            "items": {
              "$ref": "#/components/schemas/FieldPassthrough"
            },
            "type": "array",
            "title": "Field Passthrough",
            "description": "NOT REQUIRED. List of specific fields to pass through from source to output documents. These fields are included alongside extractor-computed features (embeddings, detections, etc.). Empty list = only extractor outputs in documents (default behavior). With entries = specified fields + extractor outputs in documents. \n\nHow It Works:\n1. During processing, fields are extracted from source object/document\n2. They appear in output documents at the root level\n3. Field filtering happens automatically (only listed fields included)\n4. Use target_path to rename fields for cleaner schemas\n\nCommon Use Cases:\n- Preserve identifiers: campaign_id, product_sku, order_id\n- Keep metadata: category, tags, author, created_at\n- Enable filtering: department, status, priority, region\n- Maintain context: title, description, source_url\n\nBehavior:\n- Works with include_all_source_fields=False (default): ONLY these fields included\n- Works with include_all_source_fields=True: These configs used for renaming/defaults\n- Fields must exist in source bucket_schema or upstream collection output_schema\n- Missing optional fields are omitted (unless default provided)\n- Missing required fields cause processing errors\n\nOutput Schema:\noutput_schema = field_passthrough fields + extractor output fields\nExample: ['title', 'category', 'text_extractor_v1_embedding']",
            "examples": [
              [
                {
                  "required": true,
                  "source_path": "title"
                },
                {
                  "required": true,
                  "source_path": "campaign_id"
                }
              ],
              [
                {
                  "default": "uncategorized",
                  "source_path": "category"
                },
                {
                  "source_path": "metadata.author",
                  "target_path": "author"
                }
              ]
            ]
          },
          "include_all_source_fields": {
            "type": "boolean",
            "title": "Include All Source Fields",
            "description": "NOT REQUIRED. Whether to include ALL fields from source object/document in output. Default: False (only field_passthrough fields included). \n\nWhen False (RECOMMENDED):\n- Only fields listed in field_passthrough are included in output\n- Creates clean, predictable output schemas\n- Prevents data leakage of unwanted fields\n- Output = field_passthrough fields + extractor outputs\n\nWhen True (USE WITH CAUTION):\n- ALL source fields are included in output documents\n- field_passthrough still used for renaming/defaults/requirements\n- Can result in large documents if source has many fields\n- Can leak sensitive or unnecessary data\n- Output = all source fields + extractor outputs\n\nUse True When:\n- You want to preserve complete source data\n- Source has limited, well-defined fields\n- Downstream processing needs all context\n\nUse False When (MOST CASES):\n- You want clean, controlled output schemas\n- Source has many fields you don't need\n- You want explicit field selection\n- You're concerned about document size\n\nExamples:\nFalse: source={a,b,c,d} + passthrough=[a,b] \u2192 output={a,b,embedding}\nTrue:  source={a,b,c,d} + passthrough=[a\u2192x] \u2192 output={x,b,c,d,embedding}",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version"
        ],
        "title": "FeatureExtractorConfig",
        "description": "Configuration for a feature extractor with field passthrough support.\n\nA feature extractor processes source data (from buckets or collections) and\nproduces features (embeddings, extracted text, detected objects, etc.).\n\nWith field passthrough, you can also include selected source fields in the\noutput documents alongside the computed features.\n\nCore Concepts:\n    1. **Feature Extraction**: Extractors compute features from input data\n       (e.g., text \u2192 embeddings, image \u2192 detections, video \u2192 scenes)\n    2. **Field Passthrough**: Selectively preserve source fields in output\n       (e.g., title, category, campaign_id from source \u2192 output documents)\n    3. **Output Schema**: Combination of passed-through fields + extractor outputs\n       (e.g., {title, category, text_embedding} all in one document)\n\nHow Field Passthrough Works:\n    1. Define which source fields to include via field_passthrough list\n    2. During processing, these fields are extracted from source\n    3. They appear in output documents at root level\n    4. Combine with extractor outputs for complete documents\n    5. Use target_path to rename fields for cleaner schemas\n\nField Selection Modes:\n    - **Explicit** (field_passthrough + include_all=False):\n      Only listed fields pass through. Clean, controlled output.\n      Example: passthrough=[title, category] \u2192 output has ONLY title, category, embedding\n\n    - **Inclusive** (include_all=True):\n      All source fields pass through, field_passthrough for renaming.\n      Example: source has 10 fields \u2192 output has all 10 + embedding\n\n    - **None** (no field_passthrough):\n      Only extractor outputs in documents.\n      Example: \u2192 output has ONLY embedding (no source fields)\n\nUse Cases:\n    - **Preserve Identifiers**: Keep campaign_id, product_sku, order_id for tracking\n    - **Enable Filtering**: Pass category, status, department for query filters\n    - **Maintain Context**: Include title, description for display\n    - **Track Metadata**: Preserve author, created_at, source for lineage\n    - **Business Logic**: Keep priority, region, type for application logic\n\nCommon Patterns:\n    1. **Minimal Passthrough** (recommended):\n       field_passthrough=[{\"source_path\": \"id\"}], include_all=False\n       \u2192 Clean output, only ID + extractor features\n\n    2. **Metadata Preservation**:\n       field_passthrough=[\n           {\"source_path\": \"title\"},\n           {\"source_path\": \"category\"},\n           {\"source_path\": \"created_at\"}\n       ]\n       \u2192 Document has context for display and filtering\n\n    3. **Field Renaming**:\n       field_passthrough=[\n           {\"source_path\": \"doc_title\", \"target_path\": \"title\"},\n           {\"source_path\": \"metadata.author\", \"target_path\": \"author\"}\n       ]\n       \u2192 Cleaner output schema with flattened fields\n\n    4. **Required Fields**:\n       field_passthrough=[\n           {\"source_path\": \"campaign_id\", \"required\": True},\n           {\"source_path\": \"priority\", \"default\": 0}\n       ]\n       \u2192 Ensures critical fields always present\n\nRequirements:\n    - feature_extractor_name: REQUIRED - name of the extractor\n    - version: REQUIRED - extractor version (e.g., \"v1\")\n    - parameters: NOT REQUIRED - extractor-specific config (model, thresholds, etc.)\n    - input_mappings: NOT REQUIRED - maps extractor inputs to source fields\n    - field_passthrough: NOT REQUIRED - which source fields to preserve (default: none)\n    - include_all_source_fields: NOT REQUIRED - preserve all fields (default: false)",
        "examples": [
          {
            "description": "Text extractor with field passthrough",
            "feature_extractor_name": "text_extractor",
            "field_passthrough": [
              {
                "required": true,
                "source_path": "title"
              },
              {
                "source_path": "author"
              }
            ],
            "input_mappings": {
              "text": "content"
            },
            "parameters": {
              "model": "text-embedding-3-small"
            },
            "version": "v1"
          },
          {
            "description": "Video extractor with campaign metadata",
            "feature_extractor_name": "video_extractor",
            "field_passthrough": [
              {
                "source_path": "campaign_id"
              },
              {
                "source_path": "duration_seconds"
              }
            ],
            "input_mappings": {
              "video": "video_url"
            },
            "parameters": {
              "fps": 1
            },
            "version": "v1"
          },
          {
            "description": "Image extractor with all source fields",
            "feature_extractor_name": "image_extractor",
            "include_all_source_fields": true,
            "input_mappings": {
              "image": "product_image"
            },
            "parameters": {
              "model": "clip-vit-base-patch32"
            },
            "version": "v1"
          },
          {
            "description": "Text extractor with field renaming",
            "feature_extractor_name": "text_extractor",
            "field_passthrough": [
              {
                "source_path": "metadata.author",
                "target_path": "author"
              },
              {
                "source_path": "metadata.created_at",
                "target_path": "created_at"
              }
            ],
            "input_mappings": {
              "text": "content"
            },
            "version": "v1"
          }
        ]
      },
      "FeatureExtractorConfig-Output": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Version of the feature extractor"
          },
          "parameters": {
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ParameterConfig"
                },
                {}
              ]
            },
            "type": "object",
            "title": "Parameters",
            "description": "Parameters for the feature extractor (model name, thresholds, etc.). See extractor-specific documentation for available parameters.",
            "examples": [
              {
                "dimensions": 1536,
                "model": "text-embedding-3-small"
              },
              {
                "fps": 1,
                "max_frames": 100
              }
            ]
          },
          "input_mappings": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              }
            ],
            "title": "Input Mappings",
            "description": "Mapping from extractor input names to source field paths. Tells the extractor which source fields to process. Example: {'image': 'thumbnail_url', 'text': 'description'}",
            "examples": [
              {
                "image": "product_image",
                "text": "title"
              },
              {
                "video": "video_url"
              },
              {
                "text": "content"
              }
            ]
          },
          "field_passthrough": {
            "items": {
              "$ref": "#/components/schemas/FieldPassthrough"
            },
            "type": "array",
            "title": "Field Passthrough",
            "description": "NOT REQUIRED. List of specific fields to pass through from source to output documents. These fields are included alongside extractor-computed features (embeddings, detections, etc.). Empty list = only extractor outputs in documents (default behavior). With entries = specified fields + extractor outputs in documents. \n\nHow It Works:\n1. During processing, fields are extracted from source object/document\n2. They appear in output documents at the root level\n3. Field filtering happens automatically (only listed fields included)\n4. Use target_path to rename fields for cleaner schemas\n\nCommon Use Cases:\n- Preserve identifiers: campaign_id, product_sku, order_id\n- Keep metadata: category, tags, author, created_at\n- Enable filtering: department, status, priority, region\n- Maintain context: title, description, source_url\n\nBehavior:\n- Works with include_all_source_fields=False (default): ONLY these fields included\n- Works with include_all_source_fields=True: These configs used for renaming/defaults\n- Fields must exist in source bucket_schema or upstream collection output_schema\n- Missing optional fields are omitted (unless default provided)\n- Missing required fields cause processing errors\n\nOutput Schema:\noutput_schema = field_passthrough fields + extractor output fields\nExample: ['title', 'category', 'text_extractor_v1_embedding']",
            "examples": [
              [
                {
                  "required": true,
                  "source_path": "title"
                },
                {
                  "required": true,
                  "source_path": "campaign_id"
                }
              ],
              [
                {
                  "default": "uncategorized",
                  "source_path": "category"
                },
                {
                  "source_path": "metadata.author",
                  "target_path": "author"
                }
              ]
            ]
          },
          "include_all_source_fields": {
            "type": "boolean",
            "title": "Include All Source Fields",
            "description": "NOT REQUIRED. Whether to include ALL fields from source object/document in output. Default: False (only field_passthrough fields included). \n\nWhen False (RECOMMENDED):\n- Only fields listed in field_passthrough are included in output\n- Creates clean, predictable output schemas\n- Prevents data leakage of unwanted fields\n- Output = field_passthrough fields + extractor outputs\n\nWhen True (USE WITH CAUTION):\n- ALL source fields are included in output documents\n- field_passthrough still used for renaming/defaults/requirements\n- Can result in large documents if source has many fields\n- Can leak sensitive or unnecessary data\n- Output = all source fields + extractor outputs\n\nUse True When:\n- You want to preserve complete source data\n- Source has limited, well-defined fields\n- Downstream processing needs all context\n\nUse False When (MOST CASES):\n- You want clean, controlled output schemas\n- Source has many fields you don't need\n- You want explicit field selection\n- You're concerned about document size\n\nExamples:\nFalse: source={a,b,c,d} + passthrough=[a,b] \u2192 output={a,b,embedding}\nTrue:  source={a,b,c,d} + passthrough=[a\u2192x] \u2192 output={x,b,c,d,embedding}",
            "default": false
          },
          "feature_extractor_id": {
            "type": "string",
            "title": "Feature Extractor Id",
            "description": "Construct unique identifier for the feature extractor instance (name + version).",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version",
          "feature_extractor_id"
        ],
        "title": "FeatureExtractorConfig",
        "description": "Configuration for a feature extractor with field passthrough support.\n\nA feature extractor processes source data (from buckets or collections) and\nproduces features (embeddings, extracted text, detected objects, etc.).\n\nWith field passthrough, you can also include selected source fields in the\noutput documents alongside the computed features.\n\nCore Concepts:\n    1. **Feature Extraction**: Extractors compute features from input data\n       (e.g., text \u2192 embeddings, image \u2192 detections, video \u2192 scenes)\n    2. **Field Passthrough**: Selectively preserve source fields in output\n       (e.g., title, category, campaign_id from source \u2192 output documents)\n    3. **Output Schema**: Combination of passed-through fields + extractor outputs\n       (e.g., {title, category, text_embedding} all in one document)\n\nHow Field Passthrough Works:\n    1. Define which source fields to include via field_passthrough list\n    2. During processing, these fields are extracted from source\n    3. They appear in output documents at root level\n    4. Combine with extractor outputs for complete documents\n    5. Use target_path to rename fields for cleaner schemas\n\nField Selection Modes:\n    - **Explicit** (field_passthrough + include_all=False):\n      Only listed fields pass through. Clean, controlled output.\n      Example: passthrough=[title, category] \u2192 output has ONLY title, category, embedding\n\n    - **Inclusive** (include_all=True):\n      All source fields pass through, field_passthrough for renaming.\n      Example: source has 10 fields \u2192 output has all 10 + embedding\n\n    - **None** (no field_passthrough):\n      Only extractor outputs in documents.\n      Example: \u2192 output has ONLY embedding (no source fields)\n\nUse Cases:\n    - **Preserve Identifiers**: Keep campaign_id, product_sku, order_id for tracking\n    - **Enable Filtering**: Pass category, status, department for query filters\n    - **Maintain Context**: Include title, description for display\n    - **Track Metadata**: Preserve author, created_at, source for lineage\n    - **Business Logic**: Keep priority, region, type for application logic\n\nCommon Patterns:\n    1. **Minimal Passthrough** (recommended):\n       field_passthrough=[{\"source_path\": \"id\"}], include_all=False\n       \u2192 Clean output, only ID + extractor features\n\n    2. **Metadata Preservation**:\n       field_passthrough=[\n           {\"source_path\": \"title\"},\n           {\"source_path\": \"category\"},\n           {\"source_path\": \"created_at\"}\n       ]\n       \u2192 Document has context for display and filtering\n\n    3. **Field Renaming**:\n       field_passthrough=[\n           {\"source_path\": \"doc_title\", \"target_path\": \"title\"},\n           {\"source_path\": \"metadata.author\", \"target_path\": \"author\"}\n       ]\n       \u2192 Cleaner output schema with flattened fields\n\n    4. **Required Fields**:\n       field_passthrough=[\n           {\"source_path\": \"campaign_id\", \"required\": True},\n           {\"source_path\": \"priority\", \"default\": 0}\n       ]\n       \u2192 Ensures critical fields always present\n\nRequirements:\n    - feature_extractor_name: REQUIRED - name of the extractor\n    - version: REQUIRED - extractor version (e.g., \"v1\")\n    - parameters: NOT REQUIRED - extractor-specific config (model, thresholds, etc.)\n    - input_mappings: NOT REQUIRED - maps extractor inputs to source fields\n    - field_passthrough: NOT REQUIRED - which source fields to preserve (default: none)\n    - include_all_source_fields: NOT REQUIRED - preserve all fields (default: false)",
        "examples": [
          {
            "description": "Text extractor with field passthrough",
            "feature_extractor_name": "text_extractor",
            "field_passthrough": [
              {
                "required": true,
                "source_path": "title"
              },
              {
                "source_path": "author"
              }
            ],
            "input_mappings": {
              "text": "content"
            },
            "parameters": {
              "model": "text-embedding-3-small"
            },
            "version": "v1"
          },
          {
            "description": "Video extractor with campaign metadata",
            "feature_extractor_name": "video_extractor",
            "field_passthrough": [
              {
                "source_path": "campaign_id"
              },
              {
                "source_path": "duration_seconds"
              }
            ],
            "input_mappings": {
              "video": "video_url"
            },
            "parameters": {
              "fps": 1
            },
            "version": "v1"
          },
          {
            "description": "Image extractor with all source fields",
            "feature_extractor_name": "image_extractor",
            "include_all_source_fields": true,
            "input_mappings": {
              "image": "product_image"
            },
            "parameters": {
              "model": "clip-vit-base-patch32"
            },
            "version": "v1"
          },
          {
            "description": "Text extractor with field renaming",
            "feature_extractor_name": "text_extractor",
            "field_passthrough": [
              {
                "source_path": "metadata.author",
                "target_path": "author"
              },
              {
                "source_path": "metadata.created_at",
                "target_path": "created_at"
              }
            ],
            "input_mappings": {
              "text": "content"
            },
            "version": "v1"
          }
        ]
      },
      "FeatureExtractorResponseModel": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "feature_extractor_id": {
            "type": "string",
            "title": "Feature Extractor Id"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "icon": {
            "type": "string",
            "title": "Icon"
          },
          "input_schema": {
            "additionalProperties": true,
            "type": "object",
            "title": "Input Schema"
          },
          "output_schema": {
            "additionalProperties": true,
            "type": "object",
            "title": "Output Schema"
          },
          "parameter_schema": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parameter Schema"
          },
          "supported_input_types": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Supported Input Types"
          },
          "max_inputs": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Max Inputs"
          },
          "default_parameters": {
            "additionalProperties": true,
            "type": "object",
            "title": "Default Parameters"
          },
          "document_output_type": {
            "$ref": "#/components/schemas/DocumentOutputType"
          },
          "document_input_handling": {
            "$ref": "#/components/schemas/DocumentInputHandling"
          },
          "required_vector_indexes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/VectorIndexDefinition"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required Vector Indexes"
          },
          "required_payload_indexes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/PayloadIndexConfig-Output"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required Payload Indexes"
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version",
          "feature_extractor_id",
          "description",
          "icon",
          "input_schema",
          "output_schema",
          "parameter_schema",
          "supported_input_types",
          "max_inputs",
          "default_parameters",
          "document_output_type",
          "document_input_handling",
          "required_vector_indexes",
          "required_payload_indexes"
        ],
        "title": "FeatureExtractorResponseModel",
        "description": "Feature extractor response model."
      },
      "FeatureModel": {
        "properties": {
          "feature_extractor_id": {
            "type": "string",
            "title": "Feature Extractor Id",
            "description": "ID of the feature extractor that produced this response"
          },
          "payload": {
            "additionalProperties": true,
            "type": "object",
            "title": "Payload",
            "description": "Metadata of the feature"
          },
          "vectors": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DenseVector"
              },
              {
                "$ref": "#/components/schemas/SparseVector"
              },
              {
                "$ref": "#/components/schemas/MultiDenseVector"
              },
              {
                "$ref": "#/components/schemas/NamedDenseVectors"
              },
              {
                "type": "null"
              }
            ],
            "title": "Vectors",
            "description": "Vector representation of the feature. Can be any supported vector type."
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "feature_extractor_id"
        ],
        "title": "FeatureModel",
        "description": "Response from a feature extractor."
      },
      "FeatureVectorRef": {
        "properties": {
          "feature_address": {
            "$ref": "#/components/schemas/FeatureAddress",
            "description": "Canonical feature address: mixpeek://{extractor}@{version}/{output}"
          }
        },
        "type": "object",
        "required": [
          "feature_address"
        ],
        "title": "FeatureVectorRef",
        "description": "Canonical reference to a feature vector produced by an extractor.\n\nUse a canonical feature address: mixpeek://{extractor}@{version}/{output}"
      },
      "FieldPassthrough": {
        "properties": {
          "source_path": {
            "type": "string",
            "title": "Source Path",
            "description": "REQUIRED. Dot-notation path to the source field to pass through. Simple fields: Use field name directly (e.g., 'title', 'campaign_id'). Nested fields: Use dot notation (e.g., 'metadata.author', 'config.fps'). Blob fields: Access blob data (e.g., 'blobs.thumbnail.url'). Wildcards: Use * to collect from arrays (e.g., 'blobs.*.metadata.tags'). The field must exist in the source bucket schema or upstream collection schema.",
            "examples": [
              "title",
              "campaign_id",
              "metadata.author",
              "blobs.thumbnail.url",
              "config.model_version"
            ]
          },
          "target_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Target Path",
            "description": "OPTIONAL. Target field name in output document. If NOT PROVIDED: Uses the last part of source_path (e.g., 'metadata.author' \u2192 'author'). If PROVIDED: Renames the field (e.g., 'doc_title' \u2192 'title'). Use for: Flattening nested fields, creating cleaner schemas, avoiding name conflicts. Example: source_path='metadata.author' target_path='author' creates doc['author'].",
            "examples": [
              "author",
              "title",
              "video_title",
              "product_sku",
              "user_name"
            ]
          },
          "default": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "title": "Default",
            "description": "OPTIONAL. Default value if source field doesn't exist or is None. If NOT PROVIDED and field missing: Field is omitted from output document. If PROVIDED and field missing: Field is included with this default value. Use for: Ensuring fields always exist, providing fallbacks, handling missing data. Type should match expected field type (string, int, list, dict, etc.).",
            "examples": [
              "Unknown",
              "N/A",
              0,
              [],
              {},
              false
            ]
          },
          "required": {
            "type": "boolean",
            "title": "Required",
            "description": "OPTIONAL. Whether this field MUST exist in source. If True and field missing: Raises validation error, processing fails. If False and field missing: Field omitted (or default used if provided). Use True for: Critical identifiers, required business fields, mandatory metadata. Use False for: Optional metadata, nice-to-have fields, supplementary data. Default: False (field is optional).",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "source_path"
        ],
        "title": "FieldPassthrough",
        "description": "Configuration for passing fields from source to output documents.\n\nField passthrough allows you to select specific fields from the source\n(bucket object or upstream collection document) to include in the output\ndocuments alongside the features computed by the extractor.\n\nThis is useful for preserving metadata, IDs, or other contextual information\nthat should flow through your processing pipeline.\n\nHow It Works:\n    1. You specify source fields using source_path (supports dot notation)\n    2. Fields are extracted from the source object/document during processing\n    3. They appear in the output document alongside extractor-computed features\n    4. Only fields listed in field_passthrough are included (unless include_all_source_fields=True)\n    5. Optionally rename fields using target_path for cleaner output schemas\n\nUse Cases:\n    - Preserve identifiers: campaign_id, product_sku, user_id\n    - Keep metadata: category, tags, author, timestamp\n    - Maintain business context: priority, status, region\n    - Enable filtering: department, type, source\n    - Track lineage: original_filename, upload_date\n\nField Selection:\n    - WITHOUT field_passthrough: Only extractor outputs appear in documents\n    - WITH field_passthrough: Specified fields + extractor outputs\n    - WITH include_all_source_fields=True: All source fields + extractor outputs\n\nRequirements:\n    - source_path is REQUIRED - specifies which field to pass through\n    - target_path is OPTIONAL - renames the field in output (default: use source field name)\n    - default is OPTIONAL - provides fallback if field missing (default: omit field)\n    - required is OPTIONAL - errors if field missing (default: false, omit field)",
        "examples": [
          {
            "description": "Required field, no renaming",
            "required": true,
            "source_path": "title"
          },
          {
            "default": "uncategorized",
            "description": "Optional field with default",
            "source_path": "category"
          },
          {
            "description": "Nested field flattened with rename",
            "source_path": "metadata.author",
            "target_path": "author"
          },
          {
            "description": "Required identifier",
            "required": true,
            "source_path": "campaign_id"
          },
          {
            "default": 0,
            "description": "Optional field with fallback",
            "required": false,
            "source_path": "priority"
          },
          {
            "description": "Rename for cleaner schema",
            "source_path": "doc_title",
            "target_path": "title"
          }
        ]
      },
      "FileFilters": {
        "properties": {
          "include_patterns": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Include Patterns",
            "description": "Glob patterns to include (e.g. ['*.mp4', '*.mov'])."
          },
          "exclude_patterns": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Exclude Patterns",
            "description": "Glob patterns to exclude (e.g. ['*/drafts/*', '*_temp.*'])."
          },
          "min_size_bytes": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Size Bytes",
            "description": "Minimum file size (bytes). Files smaller are skipped."
          },
          "max_size_bytes": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Size Bytes",
            "description": "Maximum file size (bytes). Files larger are skipped."
          },
          "modified_after": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modified After",
            "description": "Only sync files modified after this timestamp."
          },
          "modified_before": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modified Before",
            "description": "Only sync files modified before this timestamp."
          },
          "mime_types": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mime Types",
            "description": "Optional list of MIME types to include."
          }
        },
        "type": "object",
        "title": "FileFilters",
        "description": "Filter rules controlling which files are synced from providers."
      },
      "FilterCondition": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "Field name to filter on"
          },
          "operator": {
            "$ref": "#/components/schemas/FilterOperator",
            "description": "Comparison operator",
            "default": "eq"
          },
          "value": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DynamicValue"
              },
              {}
            ],
            "title": "Value",
            "description": "Value to compare against"
          }
        },
        "type": "object",
        "required": [
          "field",
          "value"
        ],
        "title": "FilterCondition",
        "description": "Represents a single filter condition.\n\nAttributes:\n    field: The field to filter on\n    operator: The comparison operator\n    value: The value to compare against"
      },
      "FilterOperator": {
        "type": "string",
        "enum": [
          "eq",
          "ne",
          "gt",
          "lt",
          "gte",
          "lte",
          "in",
          "nin",
          "contains",
          "starts_with",
          "ends_with",
          "regex",
          "exists",
          "is_null",
          "text"
        ],
        "title": "FilterOperator",
        "description": "Supported filter operators across database implementations."
      },
      "FlatTaxonomyConfig-Input": {
        "properties": {
          "taxonomy_type": {
            "type": "string",
            "const": "flat",
            "title": "Taxonomy Type",
            "description": "Discriminator identifying this as a flat taxonomy.",
            "default": "flat"
          },
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "The retriever to use for matching against the source collection."
          },
          "input_mappings": {
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "title": "Input Mappings",
            "description": "Input mappings defining how to construct retriever inputs."
          },
          "source_collection": {
            "$ref": "#/components/schemas/SourceCollection-Input",
            "description": "The single source collection for this flat taxonomy."
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "input_mappings",
          "source_collection"
        ],
        "title": "FlatTaxonomyConfig",
        "description": "Configuration for a *flat* taxonomy - single source collection with one retriever.",
        "examples": [
          {
            "input_mappings": [
              {
                "input_key": "image_vector",
                "path": "features.clip_vit_l_14",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_clip_v1",
            "source_collection": {
              "collection_id": "col_products_v1",
              "enrichment_fields": [
                {
                  "field_path": "metadata.tags",
                  "merge_mode": "append"
                }
              ]
            },
            "taxonomy_type": "flat"
          }
        ]
      },
      "FlatTaxonomyConfig-Output": {
        "properties": {
          "taxonomy_type": {
            "type": "string",
            "const": "flat",
            "title": "Taxonomy Type",
            "description": "Discriminator identifying this as a flat taxonomy.",
            "default": "flat"
          },
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "The retriever to use for matching against the source collection."
          },
          "input_mappings": {
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "title": "Input Mappings",
            "description": "Input mappings defining how to construct retriever inputs."
          },
          "source_collection": {
            "$ref": "#/components/schemas/SourceCollection-Output",
            "description": "The single source collection for this flat taxonomy."
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "input_mappings",
          "source_collection"
        ],
        "title": "FlatTaxonomyConfig",
        "description": "Configuration for a *flat* taxonomy - single source collection with one retriever.",
        "examples": [
          {
            "input_mappings": [
              {
                "input_key": "image_vector",
                "path": "features.clip_vit_l_14",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_clip_v1",
            "source_collection": {
              "collection_id": "col_products_v1",
              "enrichment_fields": [
                {
                  "field_path": "metadata.tags",
                  "merge_mode": "append"
                }
              ]
            },
            "taxonomy_type": "flat"
          }
        ]
      },
      "FloatIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "float"
          }
        },
        "type": "object",
        "title": "FloatIndexParams",
        "description": "Configuration for float index."
      },
      "FolderItem": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Folder ID in Google Drive"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Folder name"
          },
          "path": {
            "type": "string",
            "title": "Path",
            "description": "Full path from root"
          },
          "mime_type": {
            "type": "string",
            "title": "Mime Type",
            "description": "MIME type (application/vnd.google-apps.folder)"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "path",
          "mime_type"
        ],
        "title": "FolderItem",
        "description": "Represents a folder in Google Drive."
      },
      "GaussianMixtureParams": {
        "properties": {
          "n_components": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Components",
            "description": "Number of mixture components",
            "default": 1
          },
          "covariance_type": {
            "type": "string",
            "title": "Covariance Type",
            "description": "Type of covariance parameters ('full', 'tied', 'diag', 'spherical')",
            "default": "full"
          },
          "tol": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Tol",
            "description": "Convergence threshold",
            "default": 0.001
          },
          "reg_covar": {
            "type": "number",
            "minimum": 0.0,
            "title": "Reg Covar",
            "description": "Regularization added to the diagonal of covariance",
            "default": 1e-06
          },
          "max_iter": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Max Iter",
            "description": "Maximum number of EM iterations",
            "default": 100
          },
          "n_init": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Init",
            "description": "Number of initializations to perform",
            "default": 1
          },
          "init_params": {
            "type": "string",
            "title": "Init Params",
            "description": "Method used to initialize weights, means and covariances ('kmeans' or 'random')",
            "default": "kmeans"
          },
          "weights_init": {
            "anyOf": [
              {
                "items": {},
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Weights Init",
            "description": "Initial weights"
          },
          "means_init": {
            "anyOf": [
              {
                "items": {},
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Means Init",
            "description": "Initial means"
          },
          "precisions_init": {
            "anyOf": [
              {
                "items": {},
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Precisions Init",
            "description": "Initial precisions"
          },
          "random_state": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Random State",
            "description": "Random seed for reproducibility",
            "default": 42
          },
          "warm_start": {
            "type": "boolean",
            "title": "Warm Start",
            "description": "If True, use the solution of the last fit as initialization",
            "default": false
          },
          "verbose": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Verbose",
            "description": "Enable verbose output",
            "default": 0
          },
          "verbose_interval": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Verbose Interval",
            "description": "Number of iterations between each verbose message",
            "default": 10
          }
        },
        "type": "object",
        "title": "GaussianMixtureParams",
        "description": "Parameters for Gaussian Mixture Model clustering."
      },
      "GenericDeleteResponse": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "default": "Successfully deleted"
          },
          "success": {
            "type": "boolean",
            "title": "Success",
            "default": true
          }
        },
        "type": "object",
        "title": "GenericDeleteResponse",
        "description": "GenericDeleteResponse."
      },
      "GenericSuccessResponse": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "default": "Successfully completed"
          },
          "success": {
            "type": "boolean",
            "title": "Success",
            "default": true
          }
        },
        "type": "object",
        "title": "GenericSuccessResponse",
        "description": "GenericSuccessResponse."
      },
      "GeoIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "geo"
          }
        },
        "type": "object",
        "title": "GeoIndexParams",
        "description": "Configuration for geo index."
      },
      "GoogleDriveConfig": {
        "properties": {
          "provider_type": {
            "type": "string",
            "const": "google_drive",
            "title": "Provider Type",
            "default": "google_drive"
          },
          "credentials": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/GoogleDriveServiceAccountCredentials"
              },
              {
                "$ref": "#/components/schemas/GoogleDriveOAuthCredentials"
              }
            ],
            "title": "Credentials",
            "description": "REQUIRED. Authentication credentials for Google Drive API access. Choose service_account for production (recommended) or oauth for personal access. The 'type' field determines which credential type is used.",
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "oauth": "#/components/schemas/GoogleDriveOAuthCredentials",
                "service_account": "#/components/schemas/GoogleDriveServiceAccountCredentials"
              }
            }
          },
          "shared_drive_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Shared Drive Id",
            "description": "NOT REQUIRED. Google Workspace shared drive (Team Drive) identifier. When provided, sync operations are scoped to this shared drive only. When omitted, syncs from 'My Drive' of the authenticated account. Find ID: Open shared drive in browser, copy ID from URL. Format: 0A{alphanumeric-string}",
            "examples": [
              "0AH-Xabc123def456",
              "0ABcDeFgHiJkLmNoPqR"
            ]
          },
          "impersonate_user": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Impersonate User",
            "description": "NOT REQUIRED. Email address to impersonate when using service account credentials. Requires domain-wide delegation to be enabled for the service account. Used in G Suite environments to access files as a specific user. When omitted, uses the service account's own access. Format: Valid email address in the G Suite domain.",
            "examples": [
              "user@example.com",
              "admin@company.com"
            ]
          }
        },
        "type": "object",
        "required": [
          "credentials"
        ],
        "title": "GoogleDriveConfig",
        "description": "Google Drive and Google Workspace shared drive configuration.\n\nThis configuration enables Mixpeek to connect to Google Drive for automated\nfile ingestion and synchronization. Supports both personal Drive and Google\nWorkspace shared drives (formerly Team Drives).\n\nAuthentication Options:\n    - Service Account: Recommended for production. No user interaction required.\n    - OAuth2: Suitable for personal Drive access or development.\n\nRequirements:\n    - Google Drive API enabled in Google Cloud Console\n    - Appropriate authentication credentials configured\n    - Files/folders shared with the service account or OAuth user\n    - Network connectivity to drive.googleapis.com\n\nUse Cases:\n    - Sync marketing materials from shared drives\n    - Ingest documents from team collaboration folders\n    - Monitor and process uploaded media files\n    - Archive and search historical documents",
        "examples": [
          {
            "credentials": {
              "client_email": "sync@mixpeek-prod-456.iam.gserviceaccount.com",
              "client_id": "123456789012345678901",
              "private_key": "-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n",
              "private_key_id": "a1b2c3d4e5f6...",
              "project_id": "mixpeek-prod-456",
              "type": "service_account"
            },
            "description": "Service account accessing shared drive",
            "provider_type": "google_drive",
            "shared_drive_id": "0AH-Xabc123def456"
          },
          {
            "credentials": {
              "client_id": "123456789012-abc.apps.googleusercontent.com",
              "client_secret": "GOCSPX-abc123def456",
              "refresh_token": "1//0abc123def456...",
              "type": "oauth"
            },
            "description": "OAuth accessing personal Drive",
            "provider_type": "google_drive"
          },
          {
            "credentials": {
              "client_email": "sync@enterprise-sync.iam.gserviceaccount.com",
              "client_id": "987654321098765432109",
              "private_key": "-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n",
              "private_key_id": "xyz789...",
              "project_id": "enterprise-sync",
              "type": "service_account"
            },
            "description": "Service account with domain-wide delegation",
            "impersonate_user": "admin@company.com",
            "provider_type": "google_drive"
          }
        ]
      },
      "GoogleDriveOAuthCredentials": {
        "properties": {
          "type": {
            "type": "string",
            "const": "oauth",
            "title": "Type",
            "default": "oauth"
          },
          "client_id": {
            "type": "string",
            "title": "Client Id",
            "description": "REQUIRED. OAuth 2.0 client ID from Google Cloud Console. Found in the API credentials section. Format: {id}.apps.googleusercontent.com",
            "examples": [
              "123456789012-abcdefghijklmnop.apps.googleusercontent.com"
            ]
          },
          "client_secret": {
            "type": "string",
            "title": "Client Secret",
            "description": "REQUIRED. OAuth 2.0 client secret from Google Cloud Console. SECURITY: This field is encrypted at rest. Never log or expose this value. Format: Alphanumeric string from Google Cloud Console.",
            "examples": [
              "GOCSPX-abc123def456ghi789jkl012"
            ]
          },
          "refresh_token": {
            "type": "string",
            "title": "Refresh Token",
            "description": "REQUIRED. Long-lived refresh token obtained during OAuth consent flow. Used to automatically obtain new access tokens without user interaction. SECURITY: Encrypted at rest. Can be revoked by user at any time. Obtain via: Complete OAuth flow with drive.readonly or drive scope."
          }
        },
        "type": "object",
        "required": [
          "client_id",
          "client_secret",
          "refresh_token"
        ],
        "title": "GoogleDriveOAuthCredentials",
        "description": "Credentials for Google Drive OAuth2 user authentication.\n\nOAuth2 credentials provide access to Google Drive on behalf of a specific user.\nThis authentication method is suitable when accessing personal Drive files or\nwhen service account delegation is not available.\n\nPrerequisites:\n    - Create OAuth 2.0 credentials in Google Cloud Console\n    - Configure authorized redirect URIs\n    - Complete OAuth consent flow to obtain refresh token\n    - Ensure appropriate OAuth scopes are granted (drive.readonly or drive)\n\nSecurity:\n    - client_secret and refresh_token are encrypted at rest\n    - Access tokens are automatically refreshed and cached temporarily\n    - Credentials are scoped to the user who granted consent\n\nUse Cases:\n    - Personal Drive file access for individual users\n    - Prototyping and development without service account setup\n    - Environments where service account delegation is not feasible\n\nLimitations:\n    - Requires user interaction during initial setup\n    - Access is limited to files the consenting user can access\n    - Refresh tokens can be revoked by the user"
      },
      "GoogleDriveServiceAccountCredentials": {
        "properties": {
          "type": {
            "type": "string",
            "const": "service_account",
            "title": "Type",
            "default": "service_account"
          },
          "project_id": {
            "type": "string",
            "title": "Project Id",
            "description": "REQUIRED. Google Cloud project ID where the service account was created. Found in the JSON key file as 'project_id'. Format: lowercase alphanumeric with hyphens (e.g., 'my-project-123').",
            "examples": [
              "mixpeek-prod-456",
              "customer-ingestion"
            ]
          },
          "private_key_id": {
            "type": "string",
            "title": "Private Key Id",
            "description": "REQUIRED. Unique identifier for the private key. Found in the JSON key file as 'private_key_id'. Format: 40-character hexadecimal string.",
            "examples": [
              "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0"
            ]
          },
          "private_key": {
            "type": "string",
            "title": "Private Key",
            "description": "REQUIRED. PEM-encoded RSA private key for authentication. Found in the JSON key file as 'private_key'. SECURITY: This field is encrypted at rest. Never log or expose this value. Format: Must include BEGIN/END PRIVATE KEY markers."
          },
          "client_email": {
            "type": "string",
            "title": "Client Email",
            "description": "REQUIRED. Service account email address. Found in the JSON key file as 'client_email'. Share Drive files/folders with this email to grant access. Format: {account-name}@{project-id}.iam.gserviceaccount.com",
            "examples": [
              "mixpeek-sync@my-project-123.iam.gserviceaccount.com",
              "ingestion@customer-project.iam.gserviceaccount.com"
            ]
          },
          "client_id": {
            "type": "string",
            "title": "Client Id",
            "description": "REQUIRED. Numeric service account identifier. Found in the JSON key file as 'client_id'. Format: 21-digit numeric string.",
            "examples": [
              "123456789012345678901"
            ]
          }
        },
        "type": "object",
        "required": [
          "project_id",
          "private_key_id",
          "private_key",
          "client_email",
          "client_id"
        ],
        "title": "GoogleDriveServiceAccountCredentials",
        "description": "Credentials for Google Drive service account authentication.\n\nService accounts provide server-to-server authentication for Google Drive\nwithout requiring user interaction. They are ideal for automated sync operations.\n\nPrerequisites:\n    - Create a service account in Google Cloud Console\n    - Enable Google Drive API for the project\n    - Download the JSON key file\n    - Share target Drive files/folders with the service account email\n\nSecurity:\n    - private_key field is encrypted at rest using MongoDB client-side field level encryption\n    - Credentials never appear in logs or API responses\n    - Use domain-wide delegation for G Suite environments\n\nUse Cases:\n    - Automated ingestion pipelines from shared drives\n    - Scheduled sync operations without user interaction\n    - Service-to-service integration for enterprise deployments"
      },
      "GroupByField": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "The field path to group by. Supports dot notation for nested fields (e.g., 'metadata.category'). For date fields, can be combined with date_trunc or date_part.",
            "examples": [
              "metadata.category",
              "status",
              "created_at",
              "metadata.user_id"
            ]
          },
          "alias": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Alias",
            "description": "Optional alias for the grouped field in results. If not provided, uses the field name. Useful for nested fields to create simpler result names.",
            "examples": [
              "category",
              "upload_date",
              "user"
            ]
          },
          "date_trunc": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DateTruncUnit"
              },
              {
                "type": "null"
              }
            ],
            "description": "Truncate date field to specified unit. REQUIRED when grouping by date/time periods. Only valid for date/datetime fields. Cannot be used with date_part.",
            "examples": [
              "day",
              "month",
              "hour"
            ]
          },
          "date_part": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DatePartUnit"
              },
              {
                "type": "null"
              }
            ],
            "description": "Extract specific part from date field. OPTIONAL for analyzing date patterns. Only valid for date/datetime fields. Cannot be used with date_trunc.",
            "examples": [
              "hour",
              "dayOfWeek",
              "month"
            ]
          }
        },
        "type": "object",
        "required": [
          "field"
        ],
        "title": "GroupByField",
        "description": "Configuration for grouping by a field.\n\nDefines how to group data by a specific field, with optional transformations.\n\nRequirements:\n    - field: REQUIRED, the field to group by\n    - alias: OPTIONAL, name for the grouped field in results\n    - date_trunc: OPTIONAL, truncate date fields to time periods\n    - date_part: OPTIONAL, extract part of date field\n\nExamples:\n    - Simple grouping: GroupByField(field=\"metadata.category\")\n    - Daily grouping: GroupByField(field=\"created_at\", date_trunc=DateTruncUnit.DAY)\n    - Hour of day: GroupByField(field=\"created_at\", date_part=DatePartUnit.HOUR)",
        "examples": [
          {
            "alias": "category",
            "description": "Group by category",
            "field": "metadata.category"
          },
          {
            "alias": "date",
            "date_trunc": "day",
            "description": "Group by day",
            "field": "created_at"
          },
          {
            "alias": "hour",
            "date_part": "hour",
            "description": "Group by hour of day",
            "field": "created_at"
          }
        ]
      },
      "HDBSCANParams": {
        "properties": {
          "min_cluster_size": {
            "type": "integer",
            "minimum": 2.0,
            "title": "Min Cluster Size",
            "description": "Minimum number of samples in a cluster",
            "default": 5
          },
          "min_samples": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Samples",
            "description": "Number of samples in a neighborhood for a point to be considered a core point. Defaults to min_cluster_size if None"
          },
          "cluster_selection_epsilon": {
            "type": "number",
            "minimum": 0.0,
            "title": "Cluster Selection Epsilon",
            "description": "A distance threshold for cluster selection. Clusters below this value will be merged",
            "default": 0.0
          },
          "max_cluster_size": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Cluster Size",
            "description": "Maximum number of samples in a cluster. Clusters above this size will be split"
          },
          "metric": {
            "type": "string",
            "title": "Metric",
            "description": "Metric to use for distance computation",
            "default": "euclidean"
          },
          "alpha": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Alpha",
            "description": "A distance scaling parameter",
            "default": 1.0
          },
          "cluster_selection_method": {
            "type": "string",
            "title": "Cluster Selection Method",
            "description": "Method to select clusters from the condensed tree ('eom' or 'leaf')",
            "default": "eom"
          },
          "allow_single_cluster": {
            "type": "boolean",
            "title": "Allow Single Cluster",
            "description": "Allow HDBSCAN to find only a single cluster",
            "default": false
          },
          "prediction_data": {
            "type": "boolean",
            "title": "Prediction Data",
            "description": "Whether to generate extra data for predicting cluster membership",
            "default": false
          },
          "match_reference_implementation": {
            "type": "boolean",
            "title": "Match Reference Implementation",
            "description": "Whether to match the reference implementation exactly",
            "default": false
          }
        },
        "type": "object",
        "title": "HDBSCANParams",
        "description": "Parameters for HDBSCAN clustering algorithm."
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "HavingCondition": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "The aggregated field to filter on. REQUIRED, must match an aggregation operation alias. Used after aggregation to filter groups. Not a source field, but a computed field.",
            "examples": [
              "total_count",
              "avg_duration",
              "total_views"
            ]
          },
          "operator": {
            "type": "string",
            "title": "Operator",
            "description": "Comparison operator. REQUIRED, valid operators: gt (greater than), gte (greater than or equal), lt (less than), lte (less than or equal), eq (equal), ne (not equal).",
            "examples": [
              "gt",
              "gte",
              "lt",
              "lte",
              "eq",
              "ne"
            ]
          },
          "value": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ],
            "title": "Value",
            "description": "Value to compare against. REQUIRED, type should match aggregation result type. Numeric for COUNT/SUM/AVG, string for grouped values.",
            "examples": [
              100,
              60.0,
              "active"
            ]
          }
        },
        "type": "object",
        "required": [
          "field",
          "operator",
          "value"
        ],
        "title": "HavingCondition",
        "description": "Filtering condition for aggregated results.\n\nFilters groups after aggregation (like SQL HAVING clause).\n\nRequirements:\n    - field: REQUIRED, the aggregation alias to filter on\n    - operator: REQUIRED, comparison operator\n    - value: REQUIRED, value to compare against\n\nExamples:\n    - Keep high-count groups: HavingCondition(field=\"total_count\", operator=\"gt\", value=100)\n    - Filter by average: HavingCondition(field=\"avg_duration\", operator=\"gte\", value=60)",
        "examples": [
          {
            "description": "Groups with more than 100 items",
            "field": "total_count",
            "operator": "gt",
            "value": 100
          },
          {
            "description": "Average duration at least 60 seconds",
            "field": "avg_duration",
            "operator": "gte",
            "value": 60
          }
        ]
      },
      "HealthCheck": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/HealthStatus-Input",
            "description": "Current health status",
            "default": "healthy"
          },
          "last_check": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Check",
            "description": "When the health was last checked"
          },
          "issues": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Issues",
            "description": "List of current issues if any"
          }
        },
        "type": "object",
        "title": "HealthCheck",
        "description": "Health check information for a retriever."
      },
      "HealthCheckResponse": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/HealthStatus-Output",
            "description": "Overall API health status"
          },
          "data": {
            "$ref": "#/components/schemas/HealthServiceStatus",
            "description": "Per-service health status flags"
          },
          "errors": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HealthServiceErrors"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional per-service error messages when a service check fails"
          },
          "meta": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "Optional metadata such as configured S3 bucket/region/endpoint"
          }
        },
        "type": "object",
        "required": [
          "status",
          "data"
        ],
        "title": "HealthCheckResponse",
        "description": "Health check response model."
      },
      "HealthServiceErrors": {
        "properties": {
          "redis": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Redis",
            "description": "Redis error message, if any"
          },
          "mongodb": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mongodb",
            "description": "MongoDB error message, if any"
          },
          "qdrant": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Qdrant",
            "description": "Qdrant error message, if any"
          },
          "s3": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "S3",
            "description": "S3 error message, if any"
          },
          "celery": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Celery",
            "description": "Celery error message, if any"
          },
          "engine": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Engine",
            "description": "Engine error message, if any"
          },
          "clickhouse": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Clickhouse",
            "description": "ClickHouse error message, if any"
          }
        },
        "type": "object",
        "title": "HealthServiceErrors",
        "description": "Optional error messages for dependent services (present when a check fails)."
      },
      "HealthServiceStatus": {
        "properties": {
          "redis": {
            "type": "boolean",
            "title": "Redis",
            "description": "Connectivity to Redis successful",
            "examples": [
              true
            ]
          },
          "mongodb": {
            "type": "boolean",
            "title": "Mongodb",
            "description": "Connectivity to MongoDB successful",
            "examples": [
              true
            ]
          },
          "qdrant": {
            "type": "boolean",
            "title": "Qdrant",
            "description": "Connectivity to Qdrant successful",
            "examples": [
              true
            ]
          },
          "s3": {
            "type": "boolean",
            "title": "S3",
            "description": "Connectivity to S3 successful",
            "examples": [
              true
            ]
          },
          "celery": {
            "type": "boolean",
            "title": "Celery",
            "description": "Celery task execution successful",
            "examples": [
              true
            ]
          },
          "engine": {
            "type": "boolean",
            "title": "Engine",
            "description": "Engine HTTP health endpoint responded healthy",
            "examples": [
              true
            ]
          },
          "clickhouse": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Clickhouse",
            "description": "ClickHouse analytics backend healthy (optional, None if disabled)",
            "examples": [
              true,
              null
            ]
          }
        },
        "type": "object",
        "required": [
          "redis",
          "mongodb",
          "qdrant",
          "s3",
          "celery",
          "engine"
        ],
        "title": "HealthServiceStatus",
        "description": "Status flags for dependent services."
      },
      "HealthStatus-Input": {
        "type": "string",
        "enum": [
          "healthy",
          "degraded",
          "unhealthy"
        ],
        "title": "HealthStatus",
        "description": "Health status of a retriever."
      },
      "HealthStatus-Output": {
        "type": "string",
        "enum": [
          "OK",
          "DEGRADED"
        ],
        "title": "HealthStatus",
        "description": "Overall health status."
      },
      "HierarchicalNode-Input": {
        "properties": {
          "collection_id": {
            "type": "string",
            "pattern": "^col_[a-zA-Z0-9_]+$",
            "title": "Collection Id",
            "description": "REQUIRED. Collection ID representing this node in the hierarchy. Must reference an existing collection containing documents for this hierarchy level. Format: 'col_' prefix followed by alphanumeric/underscore characters. Used to: Match documents against this level, identify node in path, store enrichment data. Example: 'col_executives' for executive level, 'col_products_phones' for phones category.",
            "examples": [
              "col_executives",
              "col_managers",
              "col_employees",
              "col_products_phones",
              "col_electronics"
            ]
          },
          "parent_collection_id": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^col_[a-zA-Z0-9_]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parent Collection Id",
            "description": "OPTIONAL. Collection ID of the parent node in the hierarchy. When None: This is a root node (top of hierarchy). When set: References parent node's collection_id, creating parent-child relationship. Format: Same as collection_id ('col_' prefix). Used to: Build hierarchy tree, determine inheritance order, construct path arrays. Example: 'col_managers' is parent of 'col_executives', 'col_products' is parent of 'col_electronics'. Validation: Must reference a valid collection_id from another node in same taxonomy.",
            "examples": [
              "col_employees",
              "col_managers",
              "col_products",
              null
            ]
          },
          "label": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Label",
            "description": "OPTIONAL. Human-readable display name for this hierarchy node. Used in UI, visualizations, and taxonomy assignment results. NOT REQUIRED - When None: collection name or auto-generated label may be used. Format: Free text, typically title case, 2-50 characters. Examples: 'Executive Leadership', 'Mobile Phones', 'Engineering Team'. Can be LLM-generated or manually specified during taxonomy creation.",
            "examples": [
              "Executive Leadership",
              "Management Team",
              "All Employees",
              "Mobile Phones",
              "Electronics",
              null
            ]
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Summary",
            "description": "OPTIONAL. Brief description of this hierarchy level and its contents. Used for: Documentation, UI tooltips, understanding hierarchy structure. NOT REQUIRED - When None: no summary available for this node. Format: Free text, typically 1-3 sentences, up to 500 characters. Can be LLM-generated or manually provided.",
            "examples": [
              "Top-level executives with strategic decision-making authority",
              "Mid-level managers overseeing teams and projects",
              "High-end smartphones with premium features",
              null
            ]
          },
          "keywords": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Keywords",
            "description": "OPTIONAL. Keywords or tags describing this hierarchy level. Used for: Search, filtering, categorization, LLM understanding. NOT REQUIRED - When None: no keywords defined for this node. Format: List of strings, typically 3-10 keywords per node. Can be LLM-generated from collection contents or manually specified.",
            "examples": [
              [
                "executive",
                "leadership",
                "C-suite",
                "strategic"
              ],
              [
                "manager",
                "supervisor",
                "team-lead"
              ],
              [
                "smartphone",
                "mobile",
                "premium",
                "flagship"
              ],
              null
            ]
          },
          "retriever_id": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^ret_[a-zA-Z0-9_]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Retriever Id",
            "description": "OPTIONAL. Retriever to use for matching documents at this hierarchy level. When None: Uses taxonomy-level retriever_id (inheritance from parent config). When set: Overrides taxonomy-level retriever for this specific node. Format: 'ret_' prefix followed by alphanumeric characters. Use for: Specialized matching at certain levels (e.g., face recognition for employees, semantic search for products). Must reference an existing RetrieverModel.",
            "examples": [
              "ret_face_recognition",
              "ret_clip_products",
              "ret_text_semantic",
              null
            ]
          },
          "enrichment_fields": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EnrichmentField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enrichment Fields",
            "description": "OPTIONAL. Fields to enrich into documents when they match this hierarchy level. Specifies which properties from node collection to copy to matched documents. When None: No field-level enrichment (only taxonomy assignment recorded). Format: List of EnrichmentField objects with field_path and merge_mode. Inheritance: Child nodes inherit all parent enrichment_fields plus their own. Example: executives node adds 'executive_level' on top of inherited 'employee_id', 'department'.",
            "examples": [
              [
                {
                  "field_path": "executive_level",
                  "merge_mode": "replace"
                },
                {
                  "field_path": "budget_authority",
                  "merge_mode": "replace"
                }
              ],
              [
                {
                  "field_path": "product_category",
                  "merge_mode": "replace"
                },
                {
                  "field_path": "tags",
                  "merge_mode": "append"
                }
              ],
              null
            ]
          },
          "input_mappings": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input Mappings",
            "description": "OPTIONAL. Custom input mappings for the retriever at this hierarchy level. Specifies how to construct retriever inputs from document features. When None: Uses taxonomy-level input_mappings (inheritance). When set: Overrides taxonomy-level mappings for this specific node. Format: List of InputMapping objects specifying input_key, source_type, path. Use for: Different matching strategies at different levels (e.g., face at employee level, text at department level).",
            "examples": [
              [
                {
                  "input_key": "face_embedding",
                  "path": "features.face",
                  "source_type": "vector"
                }
              ],
              [
                {
                  "input_key": "text",
                  "path": "description",
                  "source_type": "text"
                }
              ],
              null
            ]
          }
        },
        "type": "object",
        "required": [
          "collection_id"
        ],
        "title": "HierarchicalNode",
        "description": "A node in a hierarchical taxonomy representing one level in the tree structure.\n\nEach node represents a collection containing documents at a specific hierarchy level.\nNodes form parent-child relationships to create multi-level taxonomies with\nproperty inheritance. When a document matches a child node, it inherits all\nproperties from parent nodes up to the root.\n\nUse Cases:\n    - Define organizational hierarchies: employees \u2192 managers \u2192 executives\n    - Create product categorizations: products \u2192 electronics \u2192 phones \u2192 smartphones\n    - Build classification trees: industries \u2192 technology \u2192 software\n    - Implement face recognition hierarchies: people \u2192 employees \u2192 team members\n    - Enable property inheritance: child nodes get all parent properties\n\nHierarchy Behavior:\n    - Root nodes: parent_collection_id = None (top of hierarchy)\n    - Child nodes: parent_collection_id references parent node's collection_id\n    - Property inheritance: Children inherit all parent enrichment_fields\n    - Path construction: Creates path array from root to leaf\n    - Multi-level matching: Documents matched at deepest applicable level\n\nConfiguration:\n    - Per-node retrievers: Override taxonomy-level retriever for specific nodes\n    - Per-node enrichment: Override which fields to enrich at each level\n    - Per-node input mappings: Customize retriever inputs per hierarchy level\n    - Labels/summaries: Human-readable metadata for UI display\n\nRelated Models:\n    - HierarchicalTaxonomyConfig: Contains list of hierarchical nodes\n    - TaxonomyAssignment: Result of matching documents to nodes\n    - EnrichmentField: Specifies which fields to enrich from node\n\nRequirements:\n    - collection_id: REQUIRED - must reference an existing collection\n    - parent_collection_id: REQUIRED for non-root nodes (None for root)\n    - All other fields: OPTIONAL with inheritance from taxonomy-level config",
        "examples": [
          {
            "collection_id": "col_employees",
            "description": "Root node - All employees (no parent)",
            "enrichment_fields": [
              {
                "field_path": "employee_id",
                "merge_mode": "replace"
              },
              {
                "field_path": "department",
                "merge_mode": "replace"
              }
            ],
            "input_mappings": [
              {
                "input_key": "face_embedding",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "keywords": [
              "employee",
              "staff",
              "personnel"
            ],
            "label": "All Employees",
            "retriever_id": "ret_face_recognition",
            "summary": "Complete employee directory with basic information"
          },
          {
            "collection_id": "col_managers",
            "description": "Mid-level node - Managers (child of employees)",
            "enrichment_fields": [
              {
                "field_path": "team_size",
                "merge_mode": "replace"
              },
              {
                "field_path": "reports_to",
                "merge_mode": "replace"
              }
            ],
            "keywords": [
              "manager",
              "supervisor",
              "team-lead"
            ],
            "label": "Management Team",
            "parent_collection_id": "col_employees",
            "summary": "Managers overseeing teams and projects"
          },
          {
            "collection_id": "col_executives",
            "description": "Leaf node - Executives (child of managers)",
            "enrichment_fields": [
              {
                "field_path": "executive_level",
                "merge_mode": "replace"
              },
              {
                "field_path": "budget_authority",
                "merge_mode": "replace"
              }
            ],
            "keywords": [
              "executive",
              "leadership",
              "C-suite"
            ],
            "label": "Executive Leadership",
            "parent_collection_id": "col_managers",
            "summary": "C-suite and VP-level executives with strategic authority"
          },
          {
            "collection_id": "col_products",
            "description": "Product hierarchy - Root category",
            "enrichment_fields": [
              {
                "field_path": "product_id",
                "merge_mode": "replace"
              },
              {
                "field_path": "tags",
                "merge_mode": "append"
              }
            ],
            "keywords": [
              "product",
              "catalog",
              "inventory"
            ],
            "label": "All Products",
            "retriever_id": "ret_clip_products",
            "summary": "Complete product catalog"
          },
          {
            "collection_id": "col_electronics",
            "description": "Product hierarchy - Electronics category",
            "enrichment_fields": [
              {
                "field_path": "warranty_years",
                "merge_mode": "replace"
              }
            ],
            "keywords": [
              "electronics",
              "devices",
              "tech"
            ],
            "label": "Electronics",
            "parent_collection_id": "col_products",
            "summary": "Electronic devices and accessories"
          },
          {
            "collection_id": "col_test_category",
            "description": "Minimal node - Only required fields",
            "parent_collection_id": "col_test_root"
          }
        ]
      },
      "HierarchicalNode-Output": {
        "properties": {
          "collection_id": {
            "type": "string",
            "pattern": "^col_[a-zA-Z0-9_]+$",
            "title": "Collection Id",
            "description": "REQUIRED. Collection ID representing this node in the hierarchy. Must reference an existing collection containing documents for this hierarchy level. Format: 'col_' prefix followed by alphanumeric/underscore characters. Used to: Match documents against this level, identify node in path, store enrichment data. Example: 'col_executives' for executive level, 'col_products_phones' for phones category.",
            "examples": [
              "col_executives",
              "col_managers",
              "col_employees",
              "col_products_phones",
              "col_electronics"
            ]
          },
          "parent_collection_id": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^col_[a-zA-Z0-9_]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parent Collection Id",
            "description": "OPTIONAL. Collection ID of the parent node in the hierarchy. When None: This is a root node (top of hierarchy). When set: References parent node's collection_id, creating parent-child relationship. Format: Same as collection_id ('col_' prefix). Used to: Build hierarchy tree, determine inheritance order, construct path arrays. Example: 'col_managers' is parent of 'col_executives', 'col_products' is parent of 'col_electronics'. Validation: Must reference a valid collection_id from another node in same taxonomy.",
            "examples": [
              "col_employees",
              "col_managers",
              "col_products",
              null
            ]
          },
          "label": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Label",
            "description": "OPTIONAL. Human-readable display name for this hierarchy node. Used in UI, visualizations, and taxonomy assignment results. NOT REQUIRED - When None: collection name or auto-generated label may be used. Format: Free text, typically title case, 2-50 characters. Examples: 'Executive Leadership', 'Mobile Phones', 'Engineering Team'. Can be LLM-generated or manually specified during taxonomy creation.",
            "examples": [
              "Executive Leadership",
              "Management Team",
              "All Employees",
              "Mobile Phones",
              "Electronics",
              null
            ]
          },
          "summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Summary",
            "description": "OPTIONAL. Brief description of this hierarchy level and its contents. Used for: Documentation, UI tooltips, understanding hierarchy structure. NOT REQUIRED - When None: no summary available for this node. Format: Free text, typically 1-3 sentences, up to 500 characters. Can be LLM-generated or manually provided.",
            "examples": [
              "Top-level executives with strategic decision-making authority",
              "Mid-level managers overseeing teams and projects",
              "High-end smartphones with premium features",
              null
            ]
          },
          "keywords": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Keywords",
            "description": "OPTIONAL. Keywords or tags describing this hierarchy level. Used for: Search, filtering, categorization, LLM understanding. NOT REQUIRED - When None: no keywords defined for this node. Format: List of strings, typically 3-10 keywords per node. Can be LLM-generated from collection contents or manually specified.",
            "examples": [
              [
                "executive",
                "leadership",
                "C-suite",
                "strategic"
              ],
              [
                "manager",
                "supervisor",
                "team-lead"
              ],
              [
                "smartphone",
                "mobile",
                "premium",
                "flagship"
              ],
              null
            ]
          },
          "retriever_id": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^ret_[a-zA-Z0-9_]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Retriever Id",
            "description": "OPTIONAL. Retriever to use for matching documents at this hierarchy level. When None: Uses taxonomy-level retriever_id (inheritance from parent config). When set: Overrides taxonomy-level retriever for this specific node. Format: 'ret_' prefix followed by alphanumeric characters. Use for: Specialized matching at certain levels (e.g., face recognition for employees, semantic search for products). Must reference an existing RetrieverModel.",
            "examples": [
              "ret_face_recognition",
              "ret_clip_products",
              "ret_text_semantic",
              null
            ]
          },
          "enrichment_fields": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EnrichmentField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enrichment Fields",
            "description": "OPTIONAL. Fields to enrich into documents when they match this hierarchy level. Specifies which properties from node collection to copy to matched documents. When None: No field-level enrichment (only taxonomy assignment recorded). Format: List of EnrichmentField objects with field_path and merge_mode. Inheritance: Child nodes inherit all parent enrichment_fields plus their own. Example: executives node adds 'executive_level' on top of inherited 'employee_id', 'department'.",
            "examples": [
              [
                {
                  "field_path": "executive_level",
                  "merge_mode": "replace"
                },
                {
                  "field_path": "budget_authority",
                  "merge_mode": "replace"
                }
              ],
              [
                {
                  "field_path": "product_category",
                  "merge_mode": "replace"
                },
                {
                  "field_path": "tags",
                  "merge_mode": "append"
                }
              ],
              null
            ]
          },
          "input_mappings": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input Mappings",
            "description": "OPTIONAL. Custom input mappings for the retriever at this hierarchy level. Specifies how to construct retriever inputs from document features. When None: Uses taxonomy-level input_mappings (inheritance). When set: Overrides taxonomy-level mappings for this specific node. Format: List of InputMapping objects specifying input_key, source_type, path. Use for: Different matching strategies at different levels (e.g., face at employee level, text at department level).",
            "examples": [
              [
                {
                  "input_key": "face_embedding",
                  "path": "features.face",
                  "source_type": "vector"
                }
              ],
              [
                {
                  "input_key": "text",
                  "path": "description",
                  "source_type": "text"
                }
              ],
              null
            ]
          }
        },
        "type": "object",
        "required": [
          "collection_id"
        ],
        "title": "HierarchicalNode",
        "description": "A node in a hierarchical taxonomy representing one level in the tree structure.\n\nEach node represents a collection containing documents at a specific hierarchy level.\nNodes form parent-child relationships to create multi-level taxonomies with\nproperty inheritance. When a document matches a child node, it inherits all\nproperties from parent nodes up to the root.\n\nUse Cases:\n    - Define organizational hierarchies: employees \u2192 managers \u2192 executives\n    - Create product categorizations: products \u2192 electronics \u2192 phones \u2192 smartphones\n    - Build classification trees: industries \u2192 technology \u2192 software\n    - Implement face recognition hierarchies: people \u2192 employees \u2192 team members\n    - Enable property inheritance: child nodes get all parent properties\n\nHierarchy Behavior:\n    - Root nodes: parent_collection_id = None (top of hierarchy)\n    - Child nodes: parent_collection_id references parent node's collection_id\n    - Property inheritance: Children inherit all parent enrichment_fields\n    - Path construction: Creates path array from root to leaf\n    - Multi-level matching: Documents matched at deepest applicable level\n\nConfiguration:\n    - Per-node retrievers: Override taxonomy-level retriever for specific nodes\n    - Per-node enrichment: Override which fields to enrich at each level\n    - Per-node input mappings: Customize retriever inputs per hierarchy level\n    - Labels/summaries: Human-readable metadata for UI display\n\nRelated Models:\n    - HierarchicalTaxonomyConfig: Contains list of hierarchical nodes\n    - TaxonomyAssignment: Result of matching documents to nodes\n    - EnrichmentField: Specifies which fields to enrich from node\n\nRequirements:\n    - collection_id: REQUIRED - must reference an existing collection\n    - parent_collection_id: REQUIRED for non-root nodes (None for root)\n    - All other fields: OPTIONAL with inheritance from taxonomy-level config",
        "examples": [
          {
            "collection_id": "col_employees",
            "description": "Root node - All employees (no parent)",
            "enrichment_fields": [
              {
                "field_path": "employee_id",
                "merge_mode": "replace"
              },
              {
                "field_path": "department",
                "merge_mode": "replace"
              }
            ],
            "input_mappings": [
              {
                "input_key": "face_embedding",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "keywords": [
              "employee",
              "staff",
              "personnel"
            ],
            "label": "All Employees",
            "retriever_id": "ret_face_recognition",
            "summary": "Complete employee directory with basic information"
          },
          {
            "collection_id": "col_managers",
            "description": "Mid-level node - Managers (child of employees)",
            "enrichment_fields": [
              {
                "field_path": "team_size",
                "merge_mode": "replace"
              },
              {
                "field_path": "reports_to",
                "merge_mode": "replace"
              }
            ],
            "keywords": [
              "manager",
              "supervisor",
              "team-lead"
            ],
            "label": "Management Team",
            "parent_collection_id": "col_employees",
            "summary": "Managers overseeing teams and projects"
          },
          {
            "collection_id": "col_executives",
            "description": "Leaf node - Executives (child of managers)",
            "enrichment_fields": [
              {
                "field_path": "executive_level",
                "merge_mode": "replace"
              },
              {
                "field_path": "budget_authority",
                "merge_mode": "replace"
              }
            ],
            "keywords": [
              "executive",
              "leadership",
              "C-suite"
            ],
            "label": "Executive Leadership",
            "parent_collection_id": "col_managers",
            "summary": "C-suite and VP-level executives with strategic authority"
          },
          {
            "collection_id": "col_products",
            "description": "Product hierarchy - Root category",
            "enrichment_fields": [
              {
                "field_path": "product_id",
                "merge_mode": "replace"
              },
              {
                "field_path": "tags",
                "merge_mode": "append"
              }
            ],
            "keywords": [
              "product",
              "catalog",
              "inventory"
            ],
            "label": "All Products",
            "retriever_id": "ret_clip_products",
            "summary": "Complete product catalog"
          },
          {
            "collection_id": "col_electronics",
            "description": "Product hierarchy - Electronics category",
            "enrichment_fields": [
              {
                "field_path": "warranty_years",
                "merge_mode": "replace"
              }
            ],
            "keywords": [
              "electronics",
              "devices",
              "tech"
            ],
            "label": "Electronics",
            "parent_collection_id": "col_products",
            "summary": "Electronic devices and accessories"
          },
          {
            "collection_id": "col_test_category",
            "description": "Minimal node - Only required fields",
            "parent_collection_id": "col_test_root"
          }
        ]
      },
      "HierarchicalTaxonomyConfig-Input": {
        "properties": {
          "taxonomy_type": {
            "type": "string",
            "const": "hierarchical",
            "title": "Taxonomy Type",
            "description": "Discriminator identifying this as a hierarchical taxonomy.",
            "default": "hierarchical"
          },
          "retriever_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Retriever Id",
            "description": "Default retriever to use for all nodes unless overridden per-node."
          },
          "input_mappings": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input Mappings",
            "description": "Default input mappings for all nodes unless overridden per-node."
          },
          "inference_strategy": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HierarchyInferenceStrategy"
              },
              {
                "type": "null"
              }
            ],
            "description": "Strategy for inferring hierarchy structure from collections. Can be 'schema' (overlap-based), 'cluster' (clustering-based), or 'llm' (AI-based). When set, will infer relationships from inference_collections."
          },
          "inference_collections": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inference Collections",
            "description": "Collection IDs to use for hierarchy inference. The inference_strategy will analyze these collections to discover relationships. Can be combined with hierarchical_nodes for hybrid configuration."
          },
          "llm_provider": {
            "anyOf": [
              {
                "type": "string",
                "const": "openai_chat_v1"
              },
              {
                "type": "null"
              }
            ],
            "title": "Llm Provider",
            "description": "LLM provider to use for hierarchy inference (default openai_chat_v1)"
          },
          "llm_model": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Llm Model",
            "description": "LLM model name (e.g., gpt-4o-mini)"
          },
          "llm_prompt_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Llm Prompt Template",
            "description": "Optional prompt template. Variables available: {collection_id}, {collection_name}."
          },
          "llm_sample_size": {
            "type": "integer",
            "title": "Llm Sample Size",
            "description": "Optional number of sample docs to include in prompts (0 = disabled).",
            "default": 0
          },
          "cluster_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cluster Ids",
            "description": "Cluster IDs to use for CLUSTER inference strategy"
          },
          "cluster_overlap_threshold": {
            "type": "number",
            "title": "Cluster Overlap Threshold",
            "description": "Minimum overlap ratio to establish parent-child relationship between clusters",
            "default": 0.7
          },
          "hierarchical_nodes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/HierarchicalNode-Input"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Hierarchical Nodes",
            "description": "Explicit node definitions that either: 1) Define the entire hierarchy (when inference_strategy is None), 2) Add additional nodes to an inferred hierarchy, or 3) Override specific relationships in an inferred hierarchy. Supports true hybrid: infer from some collections, manually add others."
          }
        },
        "type": "object",
        "title": "HierarchicalTaxonomyConfig",
        "description": "Hybrid hierarchical taxonomy configuration supporting inference with manual additions.\n\nAll hierarchical taxonomies are hybrid:\n- Base hierarchy can be inferred via schema, clustering, or LLM\n- Additional collections can be explicitly added with specific retrievers\n- Supports mixing inference strategies with manual additions/overrides\n\nExamples:\n1. Pure inference: Set inference_strategy + inference_collections\n2. Pure manual: Set hierarchical_nodes only\n3. Hybrid: Set inference_strategy + inference_collections + hierarchical_nodes\n   (infers base from collections, adds/overrides with explicit nodes)",
        "examples": [
          {
            "hierarchical_nodes": [
              {
                "collection_id": "col_employees_v1"
              },
              {
                "collection_id": "col_executives_v1",
                "parent_collection_id": "col_employees_v1"
              }
            ],
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_face_v1",
            "taxonomy_type": "hierarchical"
          },
          {
            "inference_collections": [
              "col_people_v1",
              "col_employees_v1",
              "col_managers_v1"
            ],
            "inference_strategy": "schema",
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_face_v1",
            "taxonomy_type": "hierarchical"
          },
          {
            "hierarchical_nodes": [
              {
                "collection_id": "col_special_products",
                "enrichment_fields": [
                  {
                    "field_path": "premium_tags",
                    "merge_mode": "append"
                  }
                ],
                "parent_collection_id": "col_products_v1",
                "retriever_id": "ret_special_v1"
              }
            ],
            "inference_collections": [
              "col_products_v1",
              "col_categories_v1"
            ],
            "inference_strategy": "cluster",
            "retriever_id": "ret_clip_v1",
            "taxonomy_type": "hierarchical"
          }
        ]
      },
      "HierarchicalTaxonomyConfig-Output": {
        "properties": {
          "taxonomy_type": {
            "type": "string",
            "const": "hierarchical",
            "title": "Taxonomy Type",
            "description": "Discriminator identifying this as a hierarchical taxonomy.",
            "default": "hierarchical"
          },
          "retriever_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Retriever Id",
            "description": "Default retriever to use for all nodes unless overridden per-node."
          },
          "input_mappings": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input Mappings",
            "description": "Default input mappings for all nodes unless overridden per-node."
          },
          "inference_strategy": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HierarchyInferenceStrategy"
              },
              {
                "type": "null"
              }
            ],
            "description": "Strategy for inferring hierarchy structure from collections. Can be 'schema' (overlap-based), 'cluster' (clustering-based), or 'llm' (AI-based). When set, will infer relationships from inference_collections."
          },
          "inference_collections": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inference Collections",
            "description": "Collection IDs to use for hierarchy inference. The inference_strategy will analyze these collections to discover relationships. Can be combined with hierarchical_nodes for hybrid configuration."
          },
          "llm_provider": {
            "anyOf": [
              {
                "type": "string",
                "const": "openai_chat_v1"
              },
              {
                "type": "null"
              }
            ],
            "title": "Llm Provider",
            "description": "LLM provider to use for hierarchy inference (default openai_chat_v1)"
          },
          "llm_model": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Llm Model",
            "description": "LLM model name (e.g., gpt-4o-mini)"
          },
          "llm_prompt_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Llm Prompt Template",
            "description": "Optional prompt template. Variables available: {collection_id}, {collection_name}."
          },
          "llm_sample_size": {
            "type": "integer",
            "title": "Llm Sample Size",
            "description": "Optional number of sample docs to include in prompts (0 = disabled).",
            "default": 0
          },
          "cluster_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cluster Ids",
            "description": "Cluster IDs to use for CLUSTER inference strategy"
          },
          "cluster_overlap_threshold": {
            "type": "number",
            "title": "Cluster Overlap Threshold",
            "description": "Minimum overlap ratio to establish parent-child relationship between clusters",
            "default": 0.7
          },
          "hierarchical_nodes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/HierarchicalNode-Output"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Hierarchical Nodes",
            "description": "Explicit node definitions that either: 1) Define the entire hierarchy (when inference_strategy is None), 2) Add additional nodes to an inferred hierarchy, or 3) Override specific relationships in an inferred hierarchy. Supports true hybrid: infer from some collections, manually add others."
          }
        },
        "type": "object",
        "title": "HierarchicalTaxonomyConfig",
        "description": "Hybrid hierarchical taxonomy configuration supporting inference with manual additions.\n\nAll hierarchical taxonomies are hybrid:\n- Base hierarchy can be inferred via schema, clustering, or LLM\n- Additional collections can be explicitly added with specific retrievers\n- Supports mixing inference strategies with manual additions/overrides\n\nExamples:\n1. Pure inference: Set inference_strategy + inference_collections\n2. Pure manual: Set hierarchical_nodes only\n3. Hybrid: Set inference_strategy + inference_collections + hierarchical_nodes\n   (infers base from collections, adds/overrides with explicit nodes)",
        "examples": [
          {
            "hierarchical_nodes": [
              {
                "collection_id": "col_employees_v1"
              },
              {
                "collection_id": "col_executives_v1",
                "parent_collection_id": "col_employees_v1"
              }
            ],
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_face_v1",
            "taxonomy_type": "hierarchical"
          },
          {
            "inference_collections": [
              "col_people_v1",
              "col_employees_v1",
              "col_managers_v1"
            ],
            "inference_strategy": "schema",
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_face_v1",
            "taxonomy_type": "hierarchical"
          },
          {
            "hierarchical_nodes": [
              {
                "collection_id": "col_special_products",
                "enrichment_fields": [
                  {
                    "field_path": "premium_tags",
                    "merge_mode": "append"
                  }
                ],
                "parent_collection_id": "col_products_v1",
                "retriever_id": "ret_special_v1"
              }
            ],
            "inference_collections": [
              "col_products_v1",
              "col_categories_v1"
            ],
            "inference_strategy": "cluster",
            "retriever_id": "ret_clip_v1",
            "taxonomy_type": "hierarchical"
          }
        ]
      },
      "HierarchyInferenceStrategy": {
        "type": "string",
        "enum": [
          "schema",
          "cluster",
          "llm"
        ],
        "title": "HierarchyInferenceStrategy",
        "description": "Strategy for inferring the base hierarchy structure.\n\nCan be combined with manual overrides via hierarchical_nodes for hybrid configuration:\n- SCHEMA: Infer based on overlapping collection schemas\n- CLUSTER: Infer based on clustering algorithms and overlap detection\n- LLM: Infer using AI/language models"
      },
      "InputMapping": {
        "properties": {
          "input_key": {
            "type": "string",
            "title": "Input Key",
            "description": "Key used in the constructed inputs payload."
          },
          "source_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/InputSourceType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Source of the value (payload, literal, vector)."
          },
          "path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Path",
            "description": "Dot-notation path inside payload/vector when source_type is PAYLOAD or VECTOR."
          },
          "override": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "title": "Override",
            "description": "Static value used when source_type is LITERAL. Overrides any path."
          }
        },
        "type": "object",
        "required": [
          "input_key"
        ],
        "title": "InputMapping",
        "description": "Declarative mapping for building inputs from various sources.\n\n- input_key: The key used in the constructed inputs payload\n- source_type: Where to fetch the value (payload, literal, vector)\n- path: Dot-notation path when source_type is PAYLOAD or VECTOR\n- override: Static value when source_type is LITERAL",
        "examples": [
          {
            "input_key": "query_text",
            "path": "content.title",
            "source_type": "payload"
          },
          {
            "input_key": "lang",
            "override": "en",
            "source_type": "literal"
          },
          {
            "input_key": "image_vector",
            "path": "features.clip_vit_l_14",
            "source_type": "vector"
          }
        ]
      },
      "InputSourceType": {
        "type": "string",
        "enum": [
          "payload",
          "literal",
          "vector"
        ],
        "title": "InputSourceType",
        "description": "Where the value for an input should be retrieved from."
      },
      "IntegerIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "integer"
          },
          "lookup": {
            "type": "boolean",
            "title": "Lookup",
            "default": true
          },
          "range": {
            "type": "boolean",
            "title": "Range",
            "default": true
          }
        },
        "type": "object",
        "title": "IntegerIndexParams",
        "description": "Configuration for integer index."
      },
      "InteractionResponse": {
        "properties": {
          "feature_id": {
            "type": "string",
            "title": "Feature Id",
            "description": "ID of the document/feature that was interacted with. REQUIRED. This should be the document_id returned in retriever results. Used to track which specific items users engage with.",
            "examples": [
              "doc_abc123",
              "prod_xyz789",
              "feat_12345"
            ]
          },
          "interaction_type": {
            "items": {
              "$ref": "#/components/schemas/InteractionType"
            },
            "type": "array",
            "minItems": 1,
            "title": "Interaction Type",
            "description": "List of interaction types that occurred. REQUIRED. Multiple types can be recorded simultaneously (e.g., VIEW + CLICK + LONG_VIEW for a result the user engaged with). Use the InteractionType enum values.",
            "examples": [
              [
                "click"
              ],
              [
                "positive_feedback",
                "click",
                "long_view"
              ],
              [
                "negative_feedback"
              ],
              [
                "purchase",
                "click"
              ]
            ]
          },
          "position": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Position",
            "description": "Position in search results where interaction occurred (0-indexed). NOT REQUIRED. Critical for Learning to Rank - helps identify position bias. E.g., position=0 means first result, position=9 means 10th result. Higher engagement at lower positions suggests higher quality.",
            "examples": [
              0,
              1,
              5,
              15
            ]
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Additional context about the interaction. NOT REQUIRED. Can include device, duration, viewport info, etc. Use this to enrich interaction data with application-specific context.",
            "examples": [
              {
                "device": "mobile",
                "duration_ms": 5000,
                "page": "search_results",
                "viewport_position": 0.75
              },
              {
                "interaction_reason": "not_relevant",
                "page_number": 2,
                "results_count": 50,
                "search_latency_ms": 150
              }
            ]
          },
          "user_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Id",
            "description": "Customer's authenticated user identifier. NOT REQUIRED. Persists across sessions for long-term tracking. Enables personalization and user-specific metrics. Use your application's user ID format.",
            "examples": [
              "user_abc123",
              "customer_456",
              "usr_xyz789"
            ]
          },
          "session_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Session Id",
            "description": "Temporary identifier for a single search session. NOT REQUIRED. Typically 30min-1hr duration. Tracks anonymous and authenticated users within a session. Use to group related queries and understand search journeys.",
            "examples": [
              "sess_abc123",
              "session_xyz789_1234567890"
            ]
          },
          "interaction_id": {
            "type": "string",
            "title": "Interaction Id",
            "description": "Unique identifier for this interaction record. System-assigned UUID. Use this to reference the interaction in subsequent requests.",
            "examples": [
              "int_abc123xyz789",
              "550e8400-e29b-41d4-a716-446655440000"
            ]
          }
        },
        "type": "object",
        "required": [
          "feature_id",
          "interaction_type",
          "interaction_id"
        ],
        "title": "InteractionResponse",
        "description": "Response model for a stored interaction.\n\nExtends SearchInteraction with system-assigned fields.",
        "examples": [
          {
            "description": "Simple click interaction",
            "feature_id": "doc_abc123",
            "interaction_type": [
              "click"
            ],
            "position": 2
          },
          {
            "description": "Engaged view with metadata",
            "feature_id": "prod_xyz789",
            "interaction_type": [
              "view",
              "click",
              "long_view"
            ],
            "metadata": {
              "device": "mobile",
              "duration_ms": 12000,
              "viewport_position": 0.85
            },
            "position": 0,
            "session_id": "sess_abc",
            "user_id": "user_123"
          },
          {
            "description": "Negative feedback",
            "feature_id": "doc_bad456",
            "interaction_type": [
              "negative_feedback",
              "return_to_results"
            ],
            "metadata": {
              "interaction_reason": "not_relevant"
            },
            "position": 5,
            "session_id": "sess_xyz"
          },
          {
            "description": "Purchase conversion",
            "feature_id": "prod_789",
            "interaction_type": [
              "purchase"
            ],
            "position": 1,
            "session_id": "sess_purchase_001",
            "user_id": "user_456"
          }
        ]
      },
      "InteractionTuningRecommendation": {
        "properties": {
          "recommendation_type": {
            "type": "string",
            "title": "Recommendation Type",
            "description": "Type of recommendation",
            "examples": [
              "increase_k",
              "adjust_rerank_threshold",
              "enable_cache"
            ]
          },
          "current_value": {
            "anyOf": [
              {},
              {
                "type": "null"
              }
            ],
            "title": "Current Value",
            "description": "Current setting value"
          },
          "recommended_value": {
            "title": "Recommended Value",
            "description": "Recommended value"
          },
          "expected_impact": {
            "type": "string",
            "title": "Expected Impact",
            "description": "Expected performance impact"
          },
          "confidence": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Confidence",
            "description": "Confidence score"
          },
          "reasoning": {
            "type": "string",
            "title": "Reasoning",
            "description": "Explanation of recommendation"
          }
        },
        "type": "object",
        "required": [
          "recommendation_type",
          "recommended_value",
          "expected_impact",
          "confidence",
          "reasoning"
        ],
        "title": "InteractionTuningRecommendation",
        "description": "Recommendation for interaction tuning."
      },
      "InteractionTuningResponse": {
        "properties": {
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "Retriever identifier"
          },
          "analysis_period": {
            "$ref": "#/components/schemas/TimeRange",
            "description": "Analysis period"
          },
          "recommendations": {
            "items": {
              "$ref": "#/components/schemas/InteractionTuningRecommendation"
            },
            "type": "array",
            "title": "Recommendations",
            "description": "Tuning recommendations"
          },
          "current_performance": {
            "additionalProperties": true,
            "type": "object",
            "title": "Current Performance",
            "description": "Current performance baseline"
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "analysis_period",
          "recommendations",
          "current_performance"
        ],
        "title": "InteractionTuningResponse",
        "description": "Response for interaction tuning analysis.",
        "examples": [
          {
            "analysis_period": {
              "end": "2025-10-28T00:00:00Z",
              "start": "2025-10-21T00:00:00Z"
            },
            "current_performance": {
              "avg_latency_ms": 145.3,
              "avg_results": 10,
              "cache_hit_rate": 0.72,
              "p95_latency_ms": 287.5
            },
            "recommendations": [
              {
                "confidence": 0.85,
                "current_value": 10,
                "expected_impact": "Improve recall by ~15%, increase latency by ~8ms",
                "reasoning": "Query patterns show users often click beyond top 10 results",
                "recommendation_type": "increase_k",
                "recommended_value": 20
              }
            ],
            "retriever_id": "ret_abc123"
          }
        ]
      },
      "InteractionType": {
        "type": "string",
        "enum": [
          "view",
          "click",
          "positive_feedback",
          "negative_feedback",
          "purchase",
          "add_to_cart",
          "wishlist",
          "long_view",
          "share",
          "bookmark",
          "query_refinement",
          "zero_results",
          "filter_toggle",
          "skip",
          "return_to_results"
        ],
        "title": "InteractionType",
        "description": "Types of user interactions with search results.\n\nThese interaction types are used to track user behavior and improve retrieval quality\nthrough Learning to Rank (LTR), collaborative filtering, and embedding fine-tuning.\n\nValues:\n    VIEW: User viewed a search result\n    CLICK: User clicked on a search result\n    POSITIVE_FEEDBACK: User explicitly marked result as relevant/helpful\n    NEGATIVE_FEEDBACK: User explicitly marked result as not relevant\n    PURCHASE: User purchased the item (high-value conversion signal)\n    ADD_TO_CART: User added item to cart (mid-funnel signal)\n    WISHLIST: User saved item for later (engagement signal)\n    LONG_VIEW: User spent significant time viewing (dwell time)\n    SHARE: User shared the result (strong engagement signal)\n    BOOKMARK: User bookmarked the result\n    QUERY_REFINEMENT: User modified their search query\n    ZERO_RESULTS: Query yielded no results (helps identify gaps)\n    FILTER_TOGGLE: User modified filters (helps understand intent)\n    SKIP: User skipped over result to click something lower (negative signal)\n    RETURN_TO_RESULTS: User quickly returned to results (negative signal)\n\nUsage in Retrieval Optimization:\n    - LTR (Learning to Rank): Train models to predict click-through rates\n    - Collaborative Filtering: Find similar users/items based on interactions\n    - Embedding Fine-tuning: Adjust embeddings based on what users actually click\n    - Query Understanding: Analyze refinements and zero-result queries\n    - Result Quality: Identify poorly-performing results via skip/return patterns"
      },
      "JoinMode": {
        "type": "string",
        "enum": [
          "on_demand",
          "batch"
        ],
        "title": "JoinMode"
      },
      "JoinResponse": {
        "properties": {
          "stats": {
            "$ref": "#/components/schemas/JoinStats"
          },
          "results": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Results"
          }
        },
        "type": "object",
        "required": [
          "stats"
        ],
        "title": "JoinResponse"
      },
      "JoinStats": {
        "properties": {
          "processed_docs": {
            "type": "integer",
            "title": "Processed Docs",
            "default": 0
          },
          "batches": {
            "type": "integer",
            "title": "Batches",
            "default": 0
          },
          "errors": {
            "type": "integer",
            "title": "Errors",
            "default": 0
          }
        },
        "type": "object",
        "title": "JoinStats"
      },
      "KMeansParams": {
        "properties": {
          "n_clusters": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 2.0,
            "title": "N Clusters",
            "description": "Number of clusters to form",
            "default": 8
          },
          "max_iter": {
            "type": "integer",
            "maximum": 10000.0,
            "minimum": 1.0,
            "title": "Max Iter",
            "description": "Maximum number of iterations",
            "default": 300
          },
          "random_state": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Random State",
            "description": "Random seed for reproducibility",
            "default": 42
          },
          "n_init": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Init",
            "description": "Number of times k-means will run with different centroid seeds",
            "default": 10
          },
          "tol": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Tol",
            "description": "Tolerance for convergence",
            "default": 0.0001
          },
          "init": {
            "type": "string",
            "title": "Init",
            "description": "Method for initialization ('k-means++' or 'random')",
            "default": "k-means++"
          },
          "verbose": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Verbose",
            "description": "Verbosity mode",
            "default": 0
          },
          "copy_x": {
            "type": "boolean",
            "title": "Copy X",
            "description": "If True, the original data is not modified",
            "default": true
          },
          "algorithm": {
            "type": "string",
            "title": "Algorithm",
            "description": "K-means algorithm to use ('lloyd', 'elkan', or 'auto')",
            "default": "lloyd"
          }
        },
        "type": "object",
        "title": "KMeansParams",
        "description": "Parameters for K-Means clustering algorithm."
      },
      "KeyStatus": {
        "type": "string",
        "enum": [
          "active",
          "revoked",
          "expired"
        ],
        "title": "KeyStatus",
        "description": "Lifecycle state of an API key.\n\nStatus determines whether an API key can be used for authentication:\n\n- ACTIVE: Key is valid and can be used for API requests. Last_used_at timestamp\n  is updated on each successful authentication.\n- REVOKED: Key has been manually revoked by an admin or user. Cannot be\n  reactivated. A new key must be created instead.\n- EXPIRED: Key has passed its expires_at timestamp. Automatically set by the\n  authentication system. Cannot be reactivated."
      },
      "KeysetPaginationParams": {
        "properties": {
          "method": {
            "$ref": "#/components/schemas/PaginationMethod",
            "description": "Constant identifying keyset pagination (REQUIRED).",
            "default": "keyset"
          },
          "limit": {
            "type": "integer",
            "maximum": 500.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Maximum number of documents to return (REQUIRED).",
            "default": 10
          },
          "after": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "After",
            "description": "Last seen keyset marker. Must include deterministic sort fields (OPTIONAL)."
          }
        },
        "type": "object",
        "title": "KeysetPaginationParams",
        "description": "Stateless keyset pagination relying on last seen sort key."
      },
      "KeywordIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "keyword"
          },
          "is_tenant": {
            "type": "boolean",
            "title": "Is Tenant",
            "default": false
          }
        },
        "type": "object",
        "title": "KeywordIndexParams",
        "description": "Configuration for keyword index."
      },
      "LLMLabeling": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether to generate labels for clusters using LLM",
            "default": false
          },
          "provider": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "openai",
                  "google"
                ]
              },
              {
                "type": "null"
              }
            ],
            "title": "Provider",
            "description": "LLM provider to use for labeling. Supported: 'openai', 'google'"
          },
          "model_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Model Name",
            "description": "LLM model identifier. For OpenAI defaults to 'gpt-4o-mini'. For Google defaults to 'gemini-2.5-flash'."
          },
          "include_summary": {
            "type": "boolean",
            "title": "Include Summary",
            "description": "Whether to generate cluster summaries",
            "default": true
          },
          "include_keywords": {
            "type": "boolean",
            "title": "Include Keywords",
            "description": "Whether to extract keywords for clusters",
            "default": true
          },
          "max_samples_per_cluster": {
            "type": "integer",
            "title": "Max Samples Per Cluster",
            "description": "Maximum samples to send to LLM per cluster",
            "default": 10
          },
          "custom_prompt": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Custom Prompt",
            "description": "Custom prompt template for labeling"
          },
          "parameters": {
            "additionalProperties": true,
            "type": "object",
            "title": "Parameters",
            "description": "Provider-specific parameters forwarded to the LLM service. For OpenAI: temperature, max_tokens, top_p, json_output, etc. For Google: temperature, top_k, max_output_tokens, json_output, etc."
          }
        },
        "type": "object",
        "title": "LLMLabeling",
        "description": "Configuration for LLM-based cluster labeling."
      },
      "LineageStep": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "Collection ID where this processing step occurred",
            "examples": [
              "col_video_frames",
              "col_scenes",
              "col_embeddings"
            ]
          },
          "feature_extractor_id": {
            "type": "string",
            "title": "Feature Extractor Id",
            "description": "Feature extractor that processed the data in this step",
            "examples": [
              "video_extractor_v1",
              "scene_detector_v1",
              "text_extractor_v1"
            ]
          },
          "document_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Document Id",
            "description": "Document ID from this step (for intermediate steps). Allows tracing back through the decomposition tree.",
            "examples": [
              "doc_frame001",
              "doc_scene005"
            ]
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "When this processing step occurred",
            "examples": [
              "2025-10-18T10:30:00Z"
            ]
          }
        },
        "type": "object",
        "required": [
          "collection_id",
          "feature_extractor_id"
        ],
        "title": "LineageStep",
        "description": "Single processing step in a document's lineage chain.\n\nEach step represents one transformation in the decomposition tree,\ntracking which collection and feature extractor produced the document.\n\nExample:\n    ```python\n    step = LineageStep(\n        collection_id=\"col_video_frames\",\n        feature_extractor_id=\"video_extractor_v1\",\n        document_id=\"doc_frame123\",\n        timestamp=datetime.now()\n    )\n    ```",
        "examples": [
          {
            "collection_id": "col_video_frames",
            "document_id": "doc_frame123",
            "feature_extractor_id": "video_extractor_v1",
            "timestamp": "2025-10-18T10:30:00Z"
          }
        ]
      },
      "ListBatchesRequest": {
        "properties": {
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TaskStatusEnum"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter batches by status."
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "The number of batches to skip.",
            "default": 0
          },
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "The maximum number of batches to return.",
            "default": 100
          }
        },
        "type": "object",
        "title": "ListBatchesRequest",
        "description": "The request model for listing batches."
      },
      "ListBatchesResponse": {
        "properties": {
          "batches": {
            "items": {
              "$ref": "#/components/schemas/BatchModel"
            },
            "type": "array",
            "title": "Batches",
            "description": "A list of batches."
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "The total number of batches found."
          }
        },
        "type": "object",
        "required": [
          "batches",
          "total_count"
        ],
        "title": "ListBatchesResponse",
        "description": "The response model for listing batches."
      },
      "ListBucketsRequest": {
        "properties": {
          "search": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Search",
            "description": "Search term for wildcard search across all text fields"
          },
          "filters": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Filters",
            "description": "Filters to apply to the bucket list"
          },
          "sort": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sort",
            "description": "Sort options for the bucket list"
          },
          "case_sensitive": {
            "type": "boolean",
            "title": "Case Sensitive",
            "description": "If True, filters and search will be case-sensitive",
            "default": false
          },
          "limit": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Number of results to return",
            "default": 10
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Number of results to skip",
            "default": 0
          }
        },
        "type": "object",
        "title": "ListBucketsRequest",
        "description": "Request model for listing buckets."
      },
      "ListBucketsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/BucketResponse"
            },
            "type": "array",
            "title": "Results"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of buckets matching the query"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BucketListStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Aggregate statistics across all buckets in the result"
          }
        },
        "type": "object",
        "required": [
          "results",
          "total_count",
          "pagination"
        ],
        "title": "ListBucketsResponse",
        "description": "Response model for listing buckets."
      },
      "ListClusterExecutionsRequest": {
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filters to apply when listing cluster executions"
          },
          "sort": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SortOption"
              },
              {
                "type": "null"
              }
            ],
            "description": "Sort options for the results"
          },
          "search": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Search",
            "description": "Search query for filtering executions"
          }
        },
        "type": "object",
        "title": "ListClusterExecutionsRequest",
        "description": "Request model for listing cluster execution history."
      },
      "ListClusterExecutionsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/ClusterExecutionResult"
            },
            "type": "array",
            "title": "Results",
            "description": "List of cluster execution results"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of executions matching the query"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ClusterExecutionListStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Aggregate statistics across all executions in the result"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "total_count"
        ],
        "title": "ListClusterExecutionsResponse",
        "description": "Response model for listing cluster execution history."
      },
      "ListClustersRequest": {
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filters to apply when listing clusters"
          },
          "sort": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SortOption"
              },
              {
                "type": "null"
              }
            ],
            "description": "Sort options for the results"
          },
          "search": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Search",
            "description": "Search query for filtering clusters"
          }
        },
        "type": "object",
        "title": "ListClustersRequest",
        "description": "Request model for listing clusters."
      },
      "ListClustersResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/ClusterModel"
            },
            "type": "array",
            "title": "Results",
            "description": "List of cluster models"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of clusters matching the query"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ClusterListStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Aggregate statistics across all clusters in the result"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "total_count"
        ],
        "title": "ListClustersResponse",
        "description": "Response model for listing clusters."
      },
      "ListCollectionsRequest": {
        "properties": {
          "filters": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Filters",
            "description": "Filters to apply when listing collections. Supports nested field filtering like 'taxonomy_applications.taxonomy_id'. Format: {\"AND\": [{\"field\": \"field_name\", \"operator\": \"eq\", \"value\": \"value\"}]}"
          },
          "sort": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SortOption"
              },
              {
                "type": "null"
              }
            ],
            "description": "Sort options for the results"
          },
          "search": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Search",
            "description": "Search query for filtering collections"
          },
          "case_sensitive": {
            "type": "boolean",
            "title": "Case Sensitive",
            "description": "If True, filters and search will be case-sensitive",
            "default": false
          }
        },
        "type": "object",
        "title": "ListCollectionsRequest",
        "description": "Request model for listing collections.\n\nTo filter by taxonomy, use dot notation in filters:\nfilters.AND = [{\"field\": \"taxonomy_applications.taxonomy_id\", \"operator\": \"eq\", \"value\": \"tax_123\"}]"
      },
      "ListCollectionsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/CollectionResponse"
            },
            "type": "array",
            "title": "Results",
            "description": "List of collections"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of collections matching the query"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CollectionListStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Aggregate statistics across all collections in the result"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "total_count"
        ],
        "title": "ListCollectionsResponse",
        "description": "Response model for listing collections."
      },
      "ListDocumentsRequest": {
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filters to apply."
          },
          "sort": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SortOption"
              },
              {
                "type": "null"
              }
            ],
            "description": "Sort options."
          },
          "search": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Search",
            "description": "Search term."
          },
          "return_url": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Return Url",
            "description": "Whether to return presigned URLs for object keys.",
            "default": false
          },
          "return_vectors": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Return Vectors",
            "description": "Whether to return vector embeddings in the document results.",
            "default": false
          }
        },
        "type": "object",
        "title": "ListDocumentsRequest",
        "description": "Request model for listing documents."
      },
      "ListDocumentsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/DocumentResponse"
            },
            "type": "array",
            "title": "Results"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DocumentListStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Aggregate statistics across all documents in the result"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination"
        ],
        "title": "ListDocumentsResponse",
        "description": "Response model for listing documents."
      },
      "ListExecutionsResponse": {
        "properties": {
          "executions": {
            "items": {
              "$ref": "#/components/schemas/PipelineExecutionSummary"
            },
            "type": "array",
            "title": "Executions",
            "description": "Execution summaries"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationMetadata",
            "description": "Pagination metadata"
          }
        },
        "type": "object",
        "required": [
          "pagination"
        ],
        "title": "ListExecutionsResponse",
        "description": "Re-export shared execution listing response for OpenAPI docs."
      },
      "ListFoldersResponse": {
        "properties": {
          "folders": {
            "items": {
              "$ref": "#/components/schemas/FolderItem"
            },
            "type": "array",
            "title": "Folders"
          },
          "parent_path": {
            "type": "string",
            "title": "Parent Path",
            "description": "Path of the parent folder"
          }
        },
        "type": "object",
        "required": [
          "folders",
          "parent_path"
        ],
        "title": "ListFoldersResponse",
        "description": "Response payload for list folders endpoint."
      },
      "ListInteractionsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/InteractionResponse"
            },
            "type": "array",
            "title": "Results",
            "description": "List of interactions matching the query filters"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information for navigating result pages"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination"
        ],
        "title": "ListInteractionsResponse",
        "description": "Response for listing interactions with pagination.\n\nReturns a paginated list of interaction records matching the query filters."
      },
      "ListNamespacesRequest": {
        "properties": {
          "filters": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Filters",
            "description": "Optional filters to apply to the namespace list.",
            "example": {
              "description": "test",
              "namespace_name": {
                "$regex": "^my_namespace"
              }
            }
          },
          "sort": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sort",
            "description": "Optional sort criteria for the namespace list.",
            "example": {
              "direction": "asc",
              "field": "namespace_name"
            }
          },
          "search": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Search",
            "description": "Search term for wildcard search across all text fields.",
            "example": "production"
          },
          "case_sensitive": {
            "type": "boolean",
            "title": "Case Sensitive",
            "description": "If True, filters and search will be case-sensitive",
            "default": false
          }
        },
        "type": "object",
        "title": "ListNamespacesRequest",
        "description": "Request schema for listing namespaces.",
        "examples": [
          {
            "filters": {
              "description": "test",
              "namespace_name": {
                "$regex": "^my_namespace"
              }
            },
            "sort": {
              "direction": "asc",
              "field": "namespace_name"
            }
          }
        ]
      },
      "ListNamespacesResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/NamespaceModel"
            },
            "type": "array",
            "title": "Results",
            "description": "List of namespaces matching the query"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information for the current result window"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of namespaces that match the query"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/NamespaceListStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Aggregate statistics across all namespaces in the result"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "total_count"
        ],
        "title": "ListNamespacesResponse",
        "description": "Response schema for listing namespaces.",
        "examples": [
          {
            "pagination": {
              "has_more": false,
              "limit": 10,
              "skip": 0
            },
            "results": [
              {
                "created_at": "2024-01-15T10:30:00Z",
                "description": "This namespace contains playlists from Spotify",
                "feature_extractors": [
                  {
                    "feature_extractor_name": "video_extractor",
                    "version": "1.0.0"
                  }
                ],
                "namespace_id": "ns_ab12cd34ef",
                "namespace_name": "spotify_playlists_dev",
                "payload_indexes": [
                  {
                    "field_name": "metadata.title",
                    "type": "text"
                  }
                ],
                "updated_at": "2024-01-15T10:30:00Z"
              }
            ],
            "total_count": 1
          }
        ]
      },
      "ListObjectsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/ObjectResponse"
            },
            "type": "array",
            "title": "Results",
            "description": "List of objects matching the query"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ObjectListStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Aggregate statistics across all objects in the result"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination"
        ],
        "title": "ListObjectsResponse",
        "description": "Response model for listing objects in a bucket.",
        "examples": [
          {
            "pagination": {
              "has_more": false,
              "limit": 10,
              "skip": 0
            },
            "results": [
              {
                "blobs": [],
                "bucket_id": "bkt_9xy8z7",
                "created_at": "2024-10-21T10:30:00Z",
                "key_prefix": "/contract-2024",
                "metadata": {
                  "category": "contracts",
                  "year": 2024
                },
                "object_id": "obj_123abc456def",
                "status": "DRAFT",
                "updated_at": "2024-10-21T10:30:00Z"
              }
            ]
          }
        ]
      },
      "ListRetrieversResponse": {
        "properties": {
          "retrievers": {
            "items": {
              "$ref": "#/components/schemas/RetrieverModel-Output"
            },
            "type": "array",
            "title": "Retrievers",
            "description": "List of retrievers in the namespace."
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of retrievers.",
            "default": 0
          }
        },
        "type": "object",
        "title": "ListRetrieversResponse",
        "description": "Response from listing retrievers."
      },
      "ListTasksResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/TaskResponse"
            },
            "type": "array",
            "title": "Results"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination"
        ],
        "title": "ListTasksResponse",
        "description": "Response model for listing tasks."
      },
      "ListTaxonomiesRequest": {
        "properties": {
          "search": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Search",
            "description": "Search term to filter taxonomies by name"
          },
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filters to apply to the taxonomy list"
          },
          "sort": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SortOption"
              },
              {
                "type": "null"
              }
            ],
            "description": "Sort configuration for the taxonomy list"
          },
          "case_sensitive": {
            "type": "boolean",
            "title": "Case Sensitive",
            "description": "If True, filters and search will be case-sensitive",
            "default": false
          }
        },
        "type": "object",
        "title": "ListTaxonomiesRequest",
        "description": "Request model to list taxonomies."
      },
      "ListTaxonomiesResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/TaxonomyResponse"
            },
            "type": "array",
            "title": "Results"
          },
          "pagination": {
            "additionalProperties": true,
            "type": "object",
            "title": "Pagination"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count"
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TaxonomyListStats"
              },
              {
                "type": "null"
              }
            ],
            "description": "Aggregate statistics across all taxonomies in the result"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "total_count"
        ],
        "title": "ListTaxonomiesResponse",
        "description": "Response model for listing taxonomies."
      },
      "ListTriggersRequest": {
        "properties": {
          "cluster_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cluster Id",
            "description": "Filter by cluster ID"
          },
          "trigger_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TriggerType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by trigger type"
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TriggerStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by status"
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Pagination offset",
            "default": 0
          },
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Results per page",
            "default": 50
          },
          "sort_by": {
            "type": "string",
            "title": "Sort By",
            "description": "Field to sort by",
            "default": "created_at"
          },
          "direction": {
            "type": "string",
            "title": "Direction",
            "description": "Sort direction (asc/desc)",
            "default": "desc"
          }
        },
        "type": "object",
        "title": "ListTriggersRequest",
        "description": "Request to list triggers with filters and pagination."
      },
      "ListTriggersResponse": {
        "properties": {
          "triggers": {
            "items": {
              "$ref": "#/components/schemas/TriggerModel"
            },
            "type": "array",
            "title": "Triggers",
            "description": "List of triggers"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of triggers"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Current offset"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Current limit"
          }
        },
        "type": "object",
        "required": [
          "triggers",
          "total",
          "offset",
          "limit"
        ],
        "title": "ListTriggersResponse",
        "description": "Response for list triggers request."
      },
      "ListUploadsRequest": {
        "properties": {
          "filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Complex filters using logical operators (AND, OR, NOT). Supports shorthand syntax: pass field-value pairs for equality matching. Examples:   - Filter by status: {'status': 'PENDING'}   - Filter by metadata: {'metadata.campaign': 'summer_2024'}   - Complex: {'AND': [{'field': 'status', 'operator': 'eq', 'value': 'PENDING'},                       {'field': 'file_size_bytes', 'operator': 'gte', 'value': 1000000}]} See LogicalOperator documentation for full syntax.",
            "examples": [
              {
                "status": "PENDING"
              },
              {
                "metadata.campaign": "summer_2024"
              },
              {
                "AND": [
                  {
                    "field": "status",
                    "operator": "eq",
                    "value": "COMPLETED"
                  },
                  {
                    "field": "created_at",
                    "operator": "gte",
                    "value": "2024-01-01T00:00:00Z"
                  }
                ]
              }
            ]
          },
          "sort": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SortOption"
              },
              {
                "type": "null"
              }
            ],
            "description": "Sort options for ordering results. Can sort by any field including metadata fields using dot notation. Default: created_at descending (newest first). Examples:   - Sort by creation date: {'field': 'created_at', 'direction': 'desc'}   - Sort by file size: {'field': 'file_size_bytes', 'direction': 'asc'}   - Sort by metadata: {'field': 'metadata.priority', 'direction': 'desc'}",
            "examples": [
              {
                "direction": "desc",
                "field": "created_at"
              },
              {
                "direction": "asc",
                "field": "file_size_bytes"
              },
              {
                "direction": "desc",
                "field": "metadata.priority"
              }
            ]
          },
          "search": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Search",
            "description": "Full-text search across filename and metadata fields. Case-insensitive partial matching. Searches in: filename, metadata values (converted to strings). Examples:   - 'video' - finds 'product_video.mp4', 'tutorial_video.mov'   - 'summer' - finds uploads with metadata.campaign='summer_2024'",
            "examples": [
              "video",
              "summer_2024",
              "profile"
            ]
          },
          "return_presigned_urls": {
            "type": "boolean",
            "title": "Return Presigned Urls",
            "description": "Whether to regenerate presigned URLs for S3 access in the response. OPTIONAL, defaults to false. If true:   - Generates new GET presigned URLs for completed uploads   - Useful for downloading files from S3   - Adds ~50ms per upload to response time. If false:   - No presigned URLs in response   - Faster response time. Note: Original PUT presigned URLs are never returned (security).",
            "default": false
          },
          "limit": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Maximum number of uploads to return. OPTIONAL, defaults to 20.",
            "default": 20,
            "examples": [
              20,
              50,
              100
            ]
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Number of uploads to skip for pagination. OPTIONAL, defaults to 0.",
            "default": 0,
            "examples": [
              0,
              20,
              100
            ]
          }
        },
        "type": "object",
        "title": "ListUploadsRequest",
        "description": "Request model for listing uploads with filtering, sorting, and search.\n\nProvides flexible querying capabilities using the same filter/sort framework\nas documents, objects, and other list endpoints.\n\nSupports:\n    - Complex filters using LogicalOperator (AND, OR, NOT)\n    - Shorthand filter syntax: {\"metadata.campaign\": \"summer_2024\"}\n    - Full-text search across filename and metadata\n    - Multi-field sorting\n    - Pagination with limit/offset\n\nExamples:\n    - List all pending uploads in a bucket\n    - Find uploads by metadata campaign\n    - Search for uploads by filename pattern\n    - Sort by file size or creation date",
        "examples": [
          {
            "description": "List all pending uploads",
            "filters": {
              "status": "PENDING"
            },
            "limit": 20,
            "offset": 0,
            "sort": {
              "direction": "desc",
              "field": "created_at"
            }
          },
          {
            "description": "Find large completed uploads",
            "filters": {
              "AND": [
                {
                  "field": "status",
                  "operator": "eq",
                  "value": "COMPLETED"
                },
                {
                  "field": "file_size_bytes",
                  "operator": "gte",
                  "value": 10485760
                }
              ]
            },
            "limit": 50,
            "sort": {
              "direction": "desc",
              "field": "file_size_bytes"
            }
          },
          {
            "description": "Search for video uploads in summer campaign",
            "filters": {
              "metadata.campaign": "summer_2024"
            },
            "limit": 100,
            "search": "video"
          },
          {
            "description": "List failed uploads for debugging",
            "filters": {
              "status": "FAILED"
            },
            "limit": 50,
            "return_presigned_urls": true,
            "sort": {
              "direction": "desc",
              "field": "created_at"
            }
          }
        ]
      },
      "ListUploadsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/UploadResponse"
            },
            "type": "array",
            "title": "Results",
            "description": "List of upload records matching the query"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination metadata including total count, limit, offset, has_more"
          },
          "stats": {
            "$ref": "#/components/schemas/UploadListStats",
            "description": "Aggregate statistics across all uploads in the result"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "stats"
        ],
        "title": "ListUploadsResponse",
        "description": "Response model for listing uploads.",
        "examples": [
          {
            "pagination": {
              "has_more": true,
              "limit": 20,
              "offset": 0,
              "total_count": 42
            },
            "results": [
              {
                "bucket_id": "bkt_prod",
                "created_at": "2024-01-15T10:30:00Z",
                "file_size_bytes": 52428800,
                "filename": "video1.mp4",
                "status": "COMPLETED",
                "upload_id": "upl_abc123"
              }
            ],
            "stats": {
              "avg_file_size_bytes": 12483047,
              "total_size_bytes": 524288000,
              "total_uploads": 42,
              "unique_buckets": 3,
              "uploads_by_status": {
                "COMPLETED": 35,
                "FAILED": 2,
                "PENDING": 5
              }
            }
          }
        ]
      },
      "LogicalOperator-Input": {
        "properties": {
          "AND": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/LogicalOperator-Input"
                    },
                    {
                      "$ref": "#/components/schemas/FilterCondition"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "And",
            "description": "Logical AND operation - all conditions must be true",
            "example": [
              {
                "field": "name",
                "operator": "eq",
                "value": "John"
              },
              {
                "field": "age",
                "operator": "gte",
                "value": 30
              }
            ]
          },
          "OR": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/LogicalOperator-Input"
                    },
                    {
                      "$ref": "#/components/schemas/FilterCondition"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Or",
            "description": "Logical OR operation - at least one condition must be true",
            "example": [
              {
                "field": "status",
                "operator": "eq",
                "value": "active"
              },
              {
                "field": "role",
                "operator": "eq",
                "value": "admin"
              }
            ]
          },
          "NOT": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/LogicalOperator-Input"
                    },
                    {
                      "$ref": "#/components/schemas/FilterCondition"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Not",
            "description": "Logical NOT operation - all conditions must be false",
            "example": [
              {
                "field": "department",
                "operator": "eq",
                "value": "HR"
              },
              {
                "field": "location",
                "operator": "eq",
                "value": "remote"
              }
            ]
          },
          "case_sensitive": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Case Sensitive",
            "description": "Whether to perform case-sensitive matching",
            "default": false,
            "example": true
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "LogicalOperator",
        "description": "Represents a logical operation (AND, OR, NOT) on filter conditions.\n\nAllows nesting with a defined depth limit.\n\nAlso supports shorthand syntax where field names can be passed directly\nas key-value pairs for equality filtering (e.g., {\"metadata.title\": \"value\"})."
      },
      "LogicalOperator-Output": {
        "properties": {
          "AND": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/LogicalOperator-Output"
                    },
                    {
                      "$ref": "#/components/schemas/FilterCondition"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "And",
            "description": "Logical AND operation - all conditions must be true",
            "example": [
              {
                "field": "name",
                "operator": "eq",
                "value": "John"
              },
              {
                "field": "age",
                "operator": "gte",
                "value": 30
              }
            ]
          },
          "OR": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/LogicalOperator-Output"
                    },
                    {
                      "$ref": "#/components/schemas/FilterCondition"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Or",
            "description": "Logical OR operation - at least one condition must be true",
            "example": [
              {
                "field": "status",
                "operator": "eq",
                "value": "active"
              },
              {
                "field": "role",
                "operator": "eq",
                "value": "admin"
              }
            ]
          },
          "NOT": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/LogicalOperator-Output"
                    },
                    {
                      "$ref": "#/components/schemas/FilterCondition"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Not",
            "description": "Logical NOT operation - all conditions must be false",
            "example": [
              {
                "field": "department",
                "operator": "eq",
                "value": "HR"
              },
              {
                "field": "location",
                "operator": "eq",
                "value": "remote"
              }
            ]
          },
          "case_sensitive": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Case Sensitive",
            "description": "Whether to perform case-sensitive matching",
            "default": false,
            "example": true
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "LogicalOperator",
        "description": "Represents a logical operation (AND, OR, NOT) on filter conditions.\n\nAllows nesting with a defined depth limit.\n\nAlso supports shorthand syntax where field names can be passed directly\nas key-value pairs for equality filtering (e.g., {\"metadata.title\": \"value\"})."
      },
      "MeanShiftParams": {
        "properties": {
          "bandwidth": {
            "anyOf": [
              {
                "type": "number",
                "exclusiveMinimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Bandwidth",
            "description": "Bandwidth used in the RBF kernel. If None, estimated using sklearn.cluster.estimate_bandwidth"
          },
          "seeds": {
            "anyOf": [
              {
                "items": {
                  "items": {
                    "type": "number"
                  },
                  "type": "array"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Seeds",
            "description": "Seeds used to initialize kernels. If None, all points are used as seeds"
          },
          "bin_seeding": {
            "type": "boolean",
            "title": "Bin Seeding",
            "description": "If true, initial kernel locations are discretized into a grid to speed up algorithm",
            "default": false
          },
          "min_bin_freq": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Min Bin Freq",
            "description": "Minimum number of seeds within a bin for the bin to be considered",
            "default": 1
          },
          "cluster_all": {
            "type": "boolean",
            "title": "Cluster All",
            "description": "If true, all points are clustered, even orphans. If false, orphans are given label -1",
            "default": true
          },
          "n_jobs": {
            "type": "integer",
            "title": "N Jobs",
            "description": "Number of parallel jobs to run (-1 means using all processors)",
            "default": 1
          },
          "max_iter": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Max Iter",
            "description": "Maximum number of iterations per seed point before the algorithm stops",
            "default": 300
          }
        },
        "type": "object",
        "title": "MeanShiftParams",
        "description": "Parameters for Mean Shift clustering algorithm."
      },
      "MultiDenseVector": {
        "properties": {},
        "additionalProperties": true,
        "type": "object",
        "title": "MultiDenseVector",
        "description": "Multi-dimensional dense vector representation with flexible key naming.\n\nAccepts a single key-value pair where the key can be any string\nand the value must be a list of lists of floats.\nUseful for late interaction models and other multi-dimensional embeddings.\n\nExample:\n```json\n{\n    \"embeddings\": [\n        [0.1, 0.2, 0.3],\n        [0.4, 0.5, 0.6],\n        [0.7, 0.8, 0.9]\n    ]\n}\n```\nor\n```json\n{\n    \"multi_vectors\": [\n        [0.1, 0.2, 0.3],\n        [0.4, 0.5, 0.6],\n        [0.7, 0.8, 0.9]\n    ]\n}\n```"
      },
      "MultiVectorIndex": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "vectors": {
            "additionalProperties": {
              "$ref": "#/components/schemas/VectorIndex"
            },
            "type": "object",
            "title": "Vectors"
          }
        },
        "type": "object",
        "required": [
          "name",
          "description",
          "vectors"
        ],
        "title": "MultiVectorIndex",
        "description": "Configuration for multi-vector indexes."
      },
      "NamedDenseVectors": {
        "additionalProperties": {
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "type": "object",
        "title": "NamedDenseVectors",
        "description": "Root model mapping vector names \u2192 dense float lists.\n\nAccepts JSON like:\n```json\n{\n    \"vector_a\": [0.1, 0.2, 0.3],\n    \"vector_b\": [0.4, 0.5, 0.6]\n}\n```"
      },
      "NamespaceInfrastructure": {
        "properties": {
          "ray_cluster_id": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^ray_[a-zA-Z0-9_]{3,64}$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ray Cluster Id",
            "description": "Dedicated Ray cluster identifier for this namespace.",
            "examples": [
              "ray_shared",
              "ray_prod_gpu_cluster",
              null
            ]
          },
          "ray_head_node_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ray Head Node Url",
            "description": "Ray head node address for job submission (ray://host:port).",
            "examples": [
              "ray://shared-cluster:10001",
              "ray://gpu-cluster-head:10001"
            ]
          },
          "ray_dashboard_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ray Dashboard Url",
            "description": "Ray dashboard URL for monitoring (http://host:8265).",
            "examples": [
              "http://ray-dashboard-prod:8265"
            ]
          },
          "qdrant_collection": {
            "type": "string",
            "maxLength": 128,
            "minLength": 3,
            "title": "Qdrant Collection",
            "description": "Qdrant collection backing this namespace's vector data.",
            "examples": [
              "ns_production",
              "ns_ml_inference"
            ]
          },
          "compute_tier": {
            "$ref": "#/components/schemas/ComputeTier",
            "description": "Compute tier controlling isolation and performance characteristics.",
            "default": "shared",
            "examples": [
              "shared",
              "dedicated_cpu",
              "dedicated_gpu"
            ]
          },
          "max_concurrent_jobs": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Max Concurrent Jobs",
            "description": "Maximum concurrent Ray jobs allowed for the namespace.",
            "default": 10,
            "examples": [
              10,
              50,
              20
            ]
          },
          "autoscaling_enabled": {
            "type": "boolean",
            "title": "Autoscaling Enabled",
            "description": "Toggle autoscaling for dedicated clusters (ignored for shared tier).",
            "default": true
          },
          "min_workers": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 0.0,
            "title": "Min Workers",
            "description": "Lower bound for Ray workers when autoscaling is enabled.",
            "default": 1
          },
          "max_workers": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Max Workers",
            "description": "Upper bound for Ray workers when autoscaling is enabled.",
            "default": 10
          },
          "gpu_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gpu Type",
            "description": "GPU type for dedicated GPU clusters (e.g. A100, T4).",
            "examples": [
              "A100",
              "T4",
              null
            ]
          },
          "gpus_per_worker": {
            "type": "integer",
            "maximum": 8.0,
            "minimum": 0.0,
            "title": "Gpus Per Worker",
            "description": "Number of GPUs allocated to each Ray worker when using GPUs.",
            "default": 1
          }
        },
        "type": "object",
        "required": [
          "qdrant_collection"
        ],
        "title": "NamespaceInfrastructure",
        "description": "Infrastructure configuration associated with a namespace.",
        "examples": [
          {
            "autoscaling_enabled": false,
            "compute_tier": "shared",
            "description": "Shared development namespace",
            "max_concurrent_jobs": 10,
            "qdrant_collection": "ns_dev",
            "ray_head_node_url": "ray://shared-cluster:10001"
          },
          {
            "autoscaling_enabled": true,
            "compute_tier": "dedicated_cpu",
            "description": "Dedicated production CPU cluster",
            "max_concurrent_jobs": 50,
            "max_workers": 20,
            "min_workers": 3,
            "qdrant_collection": "ns_production",
            "ray_cluster_id": "ray_prod_cluster",
            "ray_dashboard_url": "http://prod-dashboard:8265",
            "ray_head_node_url": "ray://prod-head:10001"
          }
        ]
      },
      "NamespaceListStats": {
        "properties": {
          "total_feature_extractors": {
            "type": "integer",
            "title": "Total Feature Extractors",
            "description": "Total number of feature extractors across all namespaces",
            "default": 0
          },
          "total_payload_indexes": {
            "type": "integer",
            "title": "Total Payload Indexes",
            "description": "Total number of payload indexes across all namespaces",
            "default": 0
          },
          "total_documents": {
            "type": "integer",
            "title": "Total Documents",
            "description": "Total number of documents across all namespaces",
            "default": 0
          },
          "avg_feature_extractors_per_namespace": {
            "type": "number",
            "title": "Avg Feature Extractors Per Namespace",
            "description": "Average number of feature extractors per namespace",
            "default": 0.0
          },
          "avg_payload_indexes_per_namespace": {
            "type": "number",
            "title": "Avg Payload Indexes Per Namespace",
            "description": "Average number of payload indexes per namespace",
            "default": 0.0
          },
          "avg_documents_per_namespace": {
            "type": "number",
            "title": "Avg Documents Per Namespace",
            "description": "Average number of documents per namespace",
            "default": 0.0
          }
        },
        "type": "object",
        "title": "NamespaceListStats",
        "description": "Aggregate statistics for a list of namespaces."
      },
      "NamespaceModel": {
        "properties": {
          "namespace_id": {
            "type": "string",
            "title": "Namespace Id",
            "description": "Unique identifier for the namespace"
          },
          "namespace_name": {
            "type": "string",
            "title": "Namespace Name",
            "description": "Name of the namespace",
            "example": "spotify_playlists_dev"
          },
          "infrastructure": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/NamespaceInfrastructure"
              },
              {
                "type": "null"
              }
            ],
            "description": "Infrastructure configuration for the namespace (Ray, Qdrant)."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the namespace"
          },
          "feature_extractors": {
            "items": {
              "$ref": "#/components/schemas/BaseFeatureExtractorModel-Output"
            },
            "type": "array",
            "title": "Feature Extractors",
            "description": "List of feature extractors configured for this namespace"
          },
          "payload_indexes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/PayloadIndexConfig-Output"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Payload Indexes",
            "description": "Custom payload indexes configured for this namespace"
          },
          "document_count": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Document Count",
            "description": "Total number of documents in this namespace (from Qdrant collection)"
          },
          "created_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created At",
            "description": "When the namespace was created"
          },
          "updated_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Updated At",
            "description": "When the namespace was last updated"
          }
        },
        "type": "object",
        "required": [
          "namespace_name"
        ],
        "title": "NamespaceModel",
        "description": "Namespace model."
      },
      "NamespaceOperation": {
        "type": "string",
        "enum": [
          "read_data",
          "write_data",
          "delete_data",
          "execute_retriever",
          "create_retriever",
          "delete_retriever",
          "execute_job",
          "cancel_job",
          "create_cluster",
          "delete_cluster",
          "modify_cluster",
          "modify_infrastructure",
          "manage_permissions"
        ],
        "title": "NamespaceOperation",
        "description": "Granular operations that can be scoped inside a namespace.\n\nThese operations are used to define fine-grained permissions for API keys and users\nwithin specific namespaces. Operations can be granted individually or in combination\nto implement least-privilege access control.\n\nData operations:\n    - READ_DATA: View and search documents, retrieve objects from buckets\n    - WRITE_DATA: Create and update documents, upload objects to buckets\n    - DELETE_DATA: Remove documents and objects permanently\n\nRetrieval operations:\n    - EXECUTE_RETRIEVER: Run search queries using configured retrievers\n    - CREATE_RETRIEVER: Define new retrieval pipelines with custom stages\n    - DELETE_RETRIEVER: Remove retrieval pipeline configurations\n\nJob execution:\n    - EXECUTE_JOB: Trigger ingestion pipelines and batch processing jobs\n    - CANCEL_JOB: Abort running jobs before completion\n\nCluster management (Ray infrastructure):\n    - CREATE_CLUSTER: Provision new Ray compute clusters\n    - DELETE_CLUSTER: Tear down existing compute clusters\n    - MODIFY_CLUSTER: Scale or reconfigure running clusters\n\nInfrastructure configuration:\n    - MODIFY_INFRASTRUCTURE: Change namespace settings, storage connections\n    - MANAGE_PERMISSIONS: Grant and revoke user access within the namespace\n\nExamples:\n    - Read-only access: [READ_DATA, EXECUTE_RETRIEVER]\n    - Data engineer access: [READ_DATA, WRITE_DATA, EXECUTE_JOB]\n    - Full namespace admin: All operations granted"
      },
      "NamespacePermissions": {
        "properties": {
          "namespace_id": {
            "type": "string",
            "pattern": "^ns_[a-zA-Z0-9_]+$",
            "title": "Namespace Id",
            "description": "Namespace this permission applies to (e.g. 'ns_production').",
            "examples": [
              "ns_production",
              "ns_dev",
              "ns_customer_acme"
            ]
          },
          "role": {
            "$ref": "#/components/schemas/NamespaceRole",
            "description": "User's baseline role inside the namespace.",
            "default": "member"
          },
          "operations": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/NamespaceOperation"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Operations",
            "description": "Optional explicit operations granted within the namespace.When omitted, the role's defaults apply."
          },
          "granted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Granted At",
            "description": "UTC timestamp when this namespace access was granted."
          },
          "granted_by": {
            "anyOf": [
              {
                "type": "string",
                "pattern": "^usr_[a-zA-Z0-9]{15}$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Granted By",
            "description": "User identifier that granted this namespace permission.",
            "examples": [
              "usr_a1b2c3d4e5f6g7"
            ]
          }
        },
        "type": "object",
        "required": [
          "namespace_id"
        ],
        "title": "NamespacePermissions",
        "description": "Optional namespace-level permissions applied to a user."
      },
      "NamespaceRole": {
        "type": "string",
        "enum": [
          "owner",
          "admin",
          "member",
          "viewer"
        ],
        "title": "NamespaceRole",
        "description": "Role assigned to a user when scoped to a namespace.\n\nNamespace roles define the default permissions a user has within a specific namespace.\nThese roles inherit from organization roles but provide namespace-level isolation.\n\nRole hierarchy (most to least privileged):\n    OWNER: Full control over the namespace including deletion.\n        - Can perform all operations within the namespace\n        - Can manage all users and their namespace permissions\n        - Can delete the namespace entirely\n        - Can modify namespace infrastructure settings\n        - Typically assigned to the user who created the namespace\n\n    ADMIN: Administrative access without deletion capability.\n        - Can perform all data and retrieval operations\n        - Can manage namespace-level user permissions (except owner)\n        - Can create/modify/delete clusters and infrastructure\n        - Cannot delete the namespace itself\n        - Best for: Team leads, namespace administrators\n\n    MEMBER: Standard user access for day-to-day operations.\n        - Can create, read, update, and delete data within the namespace\n        - Can execute retrievers and trigger jobs\n        - Can create retrievers and manage their own resources\n        - Cannot manage user permissions or infrastructure settings\n        - Best for: Data engineers, developers, analysts\n\n    VIEWER: Read-only access for monitoring and analytics.\n        - Can view all data and execute retrievers\n        - Cannot create, modify, or delete any resources\n        - Cannot trigger ingestion jobs or processing pipelines\n        - Best for: Business users, auditors, observers\n\nExamples:\n    - Assign OWNER to namespace creator\n    - Assign ADMIN to team leads managing shared namespaces\n    - Assign MEMBER to developers and data engineers\n    - Assign VIEWER to analysts and business stakeholders"
      },
      "NoReduction": {
        "properties": {
          "method": {
            "type": "string",
            "const": "none",
            "title": "Method",
            "default": "none"
          }
        },
        "type": "object",
        "title": "NoReduction"
      },
      "NotificationChannel": {
        "type": "string",
        "enum": [
          "email",
          "slack",
          "webhook",
          "sms"
        ],
        "title": "NotificationChannel",
        "description": "Enum for notification delivery channels."
      },
      "NotificationContentType": {
        "type": "string",
        "enum": [
          "plain_text",
          "html",
          "markdown",
          "json"
        ],
        "title": "NotificationContentType",
        "description": "Enum for content formats."
      },
      "OPTICSParams": {
        "properties": {
          "min_samples": {
            "type": "integer",
            "minimum": 2.0,
            "title": "Min Samples",
            "description": "Number of samples in a neighborhood for a point to be considered a core point",
            "default": 5
          },
          "max_eps": {
            "anyOf": [
              {
                "type": "number",
                "exclusiveMinimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Eps",
            "description": "Maximum distance between two samples. Default (None) means no maximum distance"
          },
          "metric": {
            "type": "string",
            "title": "Metric",
            "description": "Metric to use for distance computation",
            "default": "minkowski"
          },
          "p": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "P",
            "description": "Parameter for the Minkowski metric",
            "default": 2
          },
          "metric_params": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metric Params",
            "description": "Additional keyword arguments for the metric function"
          },
          "cluster_method": {
            "type": "string",
            "title": "Cluster Method",
            "description": "Method to extract clusters ('xi' or 'dbscan')",
            "default": "xi"
          },
          "eps": {
            "anyOf": [
              {
                "type": "number",
                "exclusiveMinimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Eps",
            "description": "Maximum distance for DBSCAN cluster extraction method"
          },
          "xi": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Xi",
            "description": "Minimum steepness on the reachability plot for cluster boundary (xi method)",
            "default": 0.05
          },
          "predecessor_correction": {
            "type": "boolean",
            "title": "Predecessor Correction",
            "description": "Correct clusters based on predecessors (xi method)",
            "default": true
          },
          "min_cluster_size": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Min Cluster Size",
            "description": "Minimum number of samples in a cluster. Can be a fraction if < 1.0"
          },
          "algorithm": {
            "type": "string",
            "title": "Algorithm",
            "description": "Algorithm to compute pointwise distances ('auto', 'ball_tree', 'kd_tree', 'brute')",
            "default": "auto"
          },
          "leaf_size": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Leaf Size",
            "description": "Leaf size passed to BallTree or KDTree",
            "default": 30
          },
          "n_jobs": {
            "type": "integer",
            "title": "N Jobs",
            "description": "Number of parallel jobs to run (-1 means using all processors)",
            "default": 1
          }
        },
        "type": "object",
        "title": "OPTICSParams",
        "description": "Parameters for OPTICS clustering algorithm."
      },
      "ObjectAggregationRequest": {
        "properties": {
          "group_by": {
            "items": {
              "$ref": "#/components/schemas/GroupByField"
            },
            "type": "array",
            "minItems": 1,
            "title": "Group By",
            "description": "Fields to group results by. REQUIRED, at least one field. Can include field transformations (date_trunc, date_part). Results will have one row per unique combination of group_by values."
          },
          "aggregations": {
            "items": {
              "$ref": "#/components/schemas/AggregationOperation"
            },
            "type": "array",
            "minItems": 1,
            "title": "Aggregations",
            "description": "Aggregation operations to perform. REQUIRED, at least one operation. Each operation produces a calculated field in results. Can combine multiple functions (COUNT, SUM, AVG, etc.)."
          },
          "filters": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Filters",
            "description": "Pre-aggregation filters to apply to source data. OPTIONAL, filters data before grouping. Uses same syntax as standard query filters. Applied before GROUP BY.",
            "examples": [
              {
                "metadata.status": "active"
              },
              {
                "created_at": {
                  "$gte": "2024-01-01"
                },
                "metadata.type": "video"
              }
            ]
          },
          "having": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/HavingCondition"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Having",
            "description": "Post-aggregation filters to apply to results. OPTIONAL, filters groups after aggregation. Uses aggregation aliases as field names. Applied after GROUP BY and aggregation calculations."
          },
          "unwind": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Unwind",
            "description": "Array field to unwind before aggregation. OPTIONAL, creates one document per array element. Useful for aggregating over array contents. Example: 'blobs' to analyze each blob separately.",
            "examples": [
              "blobs",
              "metadata.tags",
              "metadata.categories"
            ]
          },
          "range_buckets": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/RangeBucket"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Range Buckets",
            "description": "Range-based bucketing for numeric fields. OPTIONAL, creates histogram-style buckets. Groups numeric values into defined ranges. Applied during grouping stage."
          },
          "sort_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sort By",
            "description": "Field to sort results by. OPTIONAL, can be group_by field or aggregation alias. Defaults to no specific order. Use with sort_direction to control order.",
            "examples": [
              "total_count",
              "avg_duration",
              "category"
            ]
          },
          "sort_direction": {
            "type": "string",
            "title": "Sort Direction",
            "description": "Sort direction. OPTIONAL, defaults to 'desc' (descending). Valid values: 'asc' (ascending), 'desc' (descending). Used with sort_by field.",
            "default": "desc",
            "examples": [
              "asc",
              "desc"
            ]
          },
          "limit": {
            "anyOf": [
              {
                "type": "integer",
                "exclusiveMinimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Limit",
            "description": "Maximum number of results to return. OPTIONAL, no limit if not specified. Applied after sorting. Useful for 'top N' queries.",
            "examples": [
              10,
              50,
              100
            ]
          }
        },
        "type": "object",
        "required": [
          "group_by",
          "aggregations"
        ],
        "title": "ObjectAggregationRequest",
        "description": "Aggregation request for bucket objects.\n\nExtends the base AggregationRequest with object-specific context.\nInherits all fields from AggregationRequest.\n\nRequirements:\n    - group_by: REQUIRED, fields to group by\n    - aggregations: REQUIRED, aggregation operations to perform\n    - All other fields from AggregationRequest are available\n\nExamples:\n    - Count objects by status\n    - Daily upload statistics\n    - Category-based analytics with filtering",
        "examples": [
          {
            "aggregations": [
              {
                "alias": "total",
                "function": "count"
              }
            ],
            "description": "Count objects by status",
            "group_by": [
              {
                "alias": "status",
                "field": "status"
              }
            ],
            "sort_by": "total",
            "sort_direction": "desc"
          },
          {
            "aggregations": [
              {
                "alias": "uploads",
                "function": "count"
              },
              {
                "alias": "unique_users",
                "distinct_field": "metadata.user_id",
                "function": "count_distinct"
              }
            ],
            "description": "Daily upload statistics",
            "group_by": [
              {
                "alias": "date",
                "date_trunc": "day",
                "field": "created_at"
              }
            ],
            "sort_by": "date",
            "sort_direction": "asc"
          },
          {
            "aggregations": [
              {
                "alias": "count",
                "function": "count"
              },
              {
                "alias": "total_size",
                "field": "metadata.size",
                "function": "sum"
              },
              {
                "alias": "avg_size",
                "field": "metadata.size",
                "function": "avg"
              }
            ],
            "description": "Content type distribution with size stats",
            "group_by": [
              {
                "alias": "type",
                "field": "content_type"
              }
            ],
            "having": [
              {
                "field": "count",
                "operator": "gte",
                "value": 5
              }
            ],
            "sort_by": "total_size",
            "sort_direction": "desc"
          }
        ]
      },
      "ObjectAggregationResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/AggregationResult"
            },
            "type": "array",
            "title": "Results",
            "description": "List of aggregation results, one per group."
          },
          "total_groups": {
            "type": "integer",
            "title": "Total Groups",
            "description": "Total number of unique groups returned."
          },
          "query_info": {
            "additionalProperties": true,
            "type": "object",
            "title": "Query Info",
            "description": "Additional information about the query execution. May include pipeline stages, execution time, etc."
          }
        },
        "type": "object",
        "required": [
          "results",
          "total_groups"
        ],
        "title": "ObjectAggregationResponse",
        "description": "Response containing object aggregation results.\n\nReturns aggregated statistics grouped by specified fields.",
        "examples": [
          {
            "query_info": {
              "execution_time_ms": 45,
              "pipeline_stages": 5
            },
            "results": [
              {
                "group": {
                  "status": "completed"
                },
                "metrics": {
                  "total": 1523
                }
              },
              {
                "group": {
                  "status": "pending"
                },
                "metrics": {
                  "total": 87
                }
              }
            ],
            "total_groups": 2
          }
        ]
      },
      "ObjectListStats": {
        "properties": {
          "total_objects": {
            "type": "integer",
            "title": "Total Objects",
            "description": "Total number of objects in the result",
            "default": 0
          },
          "total_blobs": {
            "type": "integer",
            "title": "Total Blobs",
            "description": "Total number of blobs across all objects",
            "default": 0
          },
          "avg_blobs_per_object": {
            "type": "number",
            "title": "Avg Blobs Per Object",
            "description": "Average number of blobs per object",
            "default": 0.0
          },
          "objects_by_status": {
            "additionalProperties": true,
            "type": "object",
            "title": "Objects By Status",
            "description": "Count of objects grouped by status"
          }
        },
        "type": "object",
        "title": "ObjectListStats",
        "description": "Aggregate statistics for a list of objects."
      },
      "ObjectResponse": {
        "properties": {
          "object_id": {
            "type": "string",
            "title": "Object Id",
            "description": "Unique identifier for the object"
          },
          "bucket_id": {
            "type": "string",
            "title": "Bucket Id",
            "description": "ID of the bucket this object belongs to"
          },
          "key_prefix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Key Prefix",
            "description": "Storage key/path of the object, this will be used to retrieve the object from the storage. It is similar to a file path. If not provided, it will be placed in the root of the bucket."
          },
          "content_hash": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Content Hash",
            "description": "SHA256 hash of the object's content, used for de-duplication."
          },
          "blobs": {
            "items": {
              "$ref": "#/components/schemas/BlobModel"
            },
            "type": "array",
            "title": "Blobs",
            "description": "List of blobs contained in this object"
          },
          "source_details": {
            "items": {
              "$ref": "#/components/schemas/SourceDetails"
            },
            "type": "array",
            "title": "Source Details",
            "description": "Lineage/source details for this object; used for downstream references."
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "The current status of the object.",
            "default": "DRAFT"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "The error message if the object failed to process.",
            "examples": [
              "Failed to process object: Object not found"
            ]
          },
          "skip_duplicates": {
            "type": "boolean",
            "title": "Skip Duplicates",
            "description": "Skip duplicate blobs, if a blob with the same hash already exists, it will be skipped.",
            "default": false
          },
          "created_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created At",
            "description": "Timestamp when the object was created. Automatically populated by the system."
          },
          "updated_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Updated At",
            "description": "Timestamp when the object was last updated. Automatically populated by the system."
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "bucket_id"
        ],
        "title": "ObjectResponse",
        "description": "Response model for bucket objects.",
        "examples": [
          {
            "blobs": [
              {
                "blob_id": "blob_1",
                "data": {
                  "num_pages": 5,
                  "title": "Service Agreement 2024"
                },
                "key_prefix": "/contract-2024/content.pdf",
                "metadata": {
                  "author": "John Doe",
                  "department": "Legal"
                },
                "property": "content",
                "type": "PDF"
              }
            ],
            "bucket_id": "bkt_9xy8z7",
            "content_hash": "28a9f5e8...",
            "created_at": "2024-10-21T10:30:00Z",
            "key_prefix": "/contract-2024",
            "metadata": {
              "category": "contracts",
              "year": 2024
            },
            "object_id": "obj_123abc456def",
            "skip_duplicates": false,
            "status": "DRAFT",
            "updated_at": "2024-10-21T10:30:00Z"
          }
        ]
      },
      "OffsetPaginationParams": {
        "properties": {
          "method": {
            "$ref": "#/components/schemas/PaginationMethod",
            "description": "Constant identifying offset pagination (REQUIRED).",
            "default": "offset"
          },
          "page_size": {
            "type": "integer",
            "maximum": 500.0,
            "minimum": 1.0,
            "title": "Page Size",
            "description": "Number of documents per page (REQUIRED).",
            "default": 10
          },
          "page_number": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Page Number",
            "description": "1-based page index requested by caller (REQUIRED).",
            "default": 1
          }
        },
        "type": "object",
        "title": "OffsetPaginationParams",
        "description": "Offset-based pagination using page number sizing."
      },
      "OrganizationAdminUpdateRequest": {
        "properties": {
          "account_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AccountTier"
              },
              {
                "type": "null"
              }
            ],
            "description": "Update organization billing tier."
          },
          "rate_limits": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BaseRateLimits"
              },
              {
                "type": "null"
              }
            ],
            "description": "Override rate limits for the organization."
          }
        },
        "type": "object",
        "title": "OrganizationAdminUpdateRequest",
        "description": "Admin-only update payload for organization."
      },
      "OrganizationModel": {
        "properties": {
          "internal_id": {
            "type": "string",
            "title": "Internal Id",
            "description": "Internal organization identifier for multi-tenancy. High-entropy secret (24 chars) used exclusively for database queries and tenant isolation. This ID is immutable and never exposed in user-facing contexts. Format: int_xxxxxxxxxxxxxxxxxxxxx. USAGE: Database scoping, service initialization, provider configuration.",
            "examples": [
              "int_abc123def456ghi789jkl012mno345pqr678"
            ]
          },
          "organization_id": {
            "type": "string",
            "title": "Organization Id",
            "description": "Public organization identifier exposed in APIs and user-facing contexts. Lower-entropy ID (15 chars) safe for logs, error messages, and API responses. This ID can be changed for rebranding without affecting backend operations. Format: org_xxxxxxxxxxxxx. USAGE: API responses, error messages, logs, support tickets, analytics.",
            "examples": [
              "org_demo123",
              "org_acme"
            ]
          },
          "organization_name": {
            "type": "string",
            "title": "Organization Name",
            "description": "Display name of the organization."
          },
          "account_type": {
            "$ref": "#/components/schemas/AccountTier",
            "description": "Billing tier determining available features and limits.",
            "default": "free"
          },
          "credit_count": {
            "type": "integer",
            "title": "Credit Count",
            "description": "Remaining credits for metered usage.",
            "default": 1000
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Custom metadata applied to the organization."
          },
          "billing_email": {
            "anyOf": [
              {
                "type": "string",
                "format": "email"
              },
              {
                "type": "null"
              }
            ],
            "title": "Billing Email",
            "description": "Email address for invoices and billing notifications."
          },
          "rate_limits": {
            "$ref": "#/components/schemas/BaseRateLimits",
            "description": "Effective rate-limit configuration for the organization."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "UTC timestamp when the organization was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "UTC timestamp of the most recent organization update."
          },
          "users": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Users",
            "description": "Deprecated nested user documents (maintained for backwards compatibility during migration)."
          }
        },
        "type": "object",
        "required": [
          "organization_name"
        ],
        "title": "OrganizationModel",
        "description": "Organization document representing a tenant in the multi-tenant system.\n\nMulti-Tenancy Architecture:\n    Organizations are the root tenant in Mixpeek's multi-tenant architecture.\n    Each organization has dual identifiers optimized for different purposes:\n\n    - internal_id: Backend tenant isolation (database queries, scoping)\n    - organization_id: Frontend/user-facing identifier (APIs, logs, support)\n\nID Usage Patterns:\n    Database Queries:\n        \u2705 service = CollectionService(internal_id=org.internal_id)\n        \u274c service = CollectionService(internal_id=org.organization_id)  # Wrong!\n\n    Error Messages:\n        \u2705 raise NotFoundError(details={\"organization_id\": org.organization_id})\n        \u274c raise NotFoundError(details={\"internal_id\": org.internal_id})  # Don't expose!\n\n    Logging:\n        \u2705 logger.info(f\"Action for org {org.organization_id}\", extra={\"internal_id\": org.internal_id})\n        \u274c logger.info(f\"Action for org {org.internal_id}\")  # Not user-friendly!\n\nSecurity Model:\n    - internal_id is HIGH-ENTROPY (24 chars) and treated as a secret\n    - organization_id is LOWER-ENTROPY (15 chars) and safe to expose\n    - Never expose internal_id in API responses or user-facing messages",
        "examples": [
          {
            "account_type": "pro",
            "billing_email": "billing@acme.com",
            "created_at": "2025-01-01T00:00:00Z",
            "credit_count": 250000,
            "internal_id": "int_x1y2z3",
            "metadata": {
              "region": "us-east-1"
            },
            "organization_id": "org_demo123",
            "organization_name": "Acme Corporation",
            "updated_at": "2025-01-01T00:00:00Z"
          }
        ]
      },
      "OrganizationModelResponse": {
        "properties": {
          "internal_id": {
            "type": "string",
            "title": "Internal Id"
          },
          "organization_id": {
            "type": "string",
            "title": "Organization Id"
          },
          "organization_name": {
            "type": "string",
            "title": "Organization Name"
          },
          "account_type": {
            "$ref": "#/components/schemas/AccountTier"
          },
          "credit_count": {
            "type": "integer",
            "title": "Credit Count"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata"
          },
          "billing_email": {
            "anyOf": [
              {
                "type": "string",
                "format": "email"
              },
              {
                "type": "null"
              }
            ],
            "title": "Billing Email"
          },
          "rate_limits": {
            "$ref": "#/components/schemas/BaseRateLimits"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          },
          "users": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Users"
          }
        },
        "type": "object",
        "required": [
          "internal_id",
          "organization_id",
          "organization_name",
          "account_type",
          "credit_count",
          "rate_limits",
          "created_at",
          "updated_at"
        ],
        "title": "OrganizationModelResponse",
        "description": "Response model for organization endpoints.",
        "examples": [
          {
            "account_type": "pro",
            "created_at": "2025-01-01T00:00:00Z",
            "credit_count": 250000,
            "internal_id": "int_x1y2z3",
            "organization_id": "org_demo123",
            "organization_name": "Acme Corporation"
          }
        ]
      },
      "OrganizationUpdateRequest": {
        "properties": {
          "organization_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Organization Name",
            "description": "Updated display name for the organization."
          },
          "billing_email": {
            "anyOf": [
              {
                "type": "string",
                "format": "email"
              },
              {
                "type": "null"
              }
            ],
            "title": "Billing Email",
            "description": "Updated billing contact email."
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Replace metadata with provided dictionary when set."
          },
          "rate_limits": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/BaseRateLimits"
              },
              {
                "type": "null"
              }
            ],
            "description": "Override the computed rate limits for the organization."
          }
        },
        "type": "object",
        "title": "OrganizationUpdateRequest",
        "description": "Partial update payload for organization metadata."
      },
      "PaginationMetadata": {
        "properties": {
          "total": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total",
            "description": "Total number of records"
          },
          "limit": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Limit",
            "description": "Requested page size"
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Offset applied to query"
          },
          "has_next": {
            "type": "boolean",
            "title": "Has Next",
            "description": "Whether additional pages exist"
          }
        },
        "type": "object",
        "required": [
          "total",
          "limit",
          "offset",
          "has_next"
        ],
        "title": "PaginationMetadata",
        "description": "Pagination metadata envelope."
      },
      "PaginationMethod": {
        "type": "string",
        "enum": [
          "offset",
          "cursor",
          "scroll",
          "keyset"
        ],
        "title": "PaginationMethod",
        "description": "Supported pagination strategies for pipeline execution."
      },
      "PaginationResponse": {
        "properties": {
          "total": {
            "type": "integer",
            "title": "Total"
          },
          "page": {
            "type": "integer",
            "title": "Page"
          },
          "page_size": {
            "type": "integer",
            "title": "Page Size"
          },
          "total_pages": {
            "type": "integer",
            "title": "Total Pages"
          },
          "next_page": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Page"
          },
          "previous_page": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Previous Page"
          }
        },
        "type": "object",
        "required": [
          "total",
          "page",
          "page_size",
          "total_pages"
        ],
        "title": "PaginationResponse",
        "description": "PaginationResponse."
      },
      "ParameterConfig": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ParameterType",
            "description": "The type of the parameter (e.g., 'fixed')."
          },
          "value": {
            "title": "Value",
            "description": "The value of the parameter."
          }
        },
        "type": "object",
        "required": [
          "type",
          "value"
        ],
        "title": "ParameterConfig",
        "description": "A typed value for a feature extractor parameter."
      },
      "ParameterType": {
        "type": "string",
        "enum": [
          "fixed",
          "dynamic"
        ],
        "title": "ParameterType",
        "description": "The type of a feature extractor parameter.\n\n- 'fixed': The value is provided directly.\n- 'dynamic': The value is resolved from the input data via mapping."
      },
      "PatchBatchRequest": {
        "properties": {
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Additional user-defined metadata for the batch."
          }
        },
        "type": "object",
        "title": "PatchBatchRequest",
        "description": "Request model for partially updating a batch (PATCH operation)."
      },
      "PatchClusterRequest": {
        "properties": {
          "cluster_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cluster Name",
            "description": "Updated name for the cluster"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Updated description for the cluster"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Updated metadata for the cluster"
          }
        },
        "type": "object",
        "title": "PatchClusterRequest",
        "description": "Request model for partially updating a cluster (PATCH operation)."
      },
      "PatchDocumentRequest": {
        "properties": {
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Updated metadata for the document."
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "PatchDocumentRequest",
        "description": "Request model for partially updating a document (PATCH operation)."
      },
      "PatchNamespaceRequest": {
        "properties": {
          "namespace_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Namespace Name",
            "description": "Updated name for the namespace",
            "example": "spotify_playlists_prod"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Updated description for the namespace"
          },
          "payload_indexes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/PayloadIndexConfig-Input"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Payload Indexes",
            "description": "Updated list of custom payload indexes for this namespace."
          }
        },
        "type": "object",
        "title": "PatchNamespaceRequest",
        "description": "Request schema for partially updating a namespace (PATCH operation)."
      },
      "PatchObjectRequest": {
        "properties": {
          "key_prefix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Key Prefix",
            "description": "Updated storage key/path prefix of the object"
          },
          "skip_duplicates": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Skip Duplicates",
            "description": "Skip duplicate blobs"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "PatchObjectRequest",
        "description": "Request model for partially updating a bucket object (PATCH operation).\n\nTask 10: Use extra='allow' to accept any user-defined fields at root level.\nNo nested metadata dict - all fields are flat."
      },
      "PatchRetrieverRequest": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Updated pipeline name. OPTIONAL - only provide if you want to rename the pipeline.",
            "examples": [
              "product_search_v2",
              "customer_lookup_enhanced"
            ]
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Updated human-readable description. OPTIONAL - only provide if you want to update the description.",
            "examples": [
              "Enhanced version with better caching",
              "Updated for Q4 2025"
            ]
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Updated tags for organization and filtering. OPTIONAL - replaces existing tags if provided.",
            "examples": [
              [
                "production",
                "v2"
              ],
              [
                "experimental",
                "ml-enhanced"
              ]
            ]
          }
        },
        "type": "object",
        "title": "PatchRetrieverRequest",
        "description": "Request to update a retriever's metadata.\n\n**IMPORTANT: Partial Updates with Controlled Mutability**\n\nThis endpoint allows updating ONLY metadata fields. Core pipeline logic is immutable\nto ensure consistency for dependent resources (taxonomies, cached results, etc.).\n\n**\u2705 Fields You CAN Update (Metadata Only):**\n- `name`: Rename the retriever\n- `description`: Update documentation\n- `tags`: Update organization tags\n\n**\u274c Fields You CANNOT Update (Immutable Core Logic):**\n- `input_schema`: Input field definitions (breaks dependent taxonomies)\n- `stages`: Pipeline stages and configurations (changes matching behavior)\n- `collection_ids`: Target collections (changes data sources)\n\n**Behavior:**\n- All fields are OPTIONAL - provide only what you want to update\n- Version number automatically increments on each update\n- Empty updates (no fields provided) will be rejected with 400 error\n- For structural changes, create a new retriever version instead\n\n**Why This Design?**\n- Taxonomies reference retrievers by ID and expect consistent behavior\n- Cached results remain valid after metadata-only changes\n- Version tracking enables auditing and rollback",
        "examples": [
          {
            "description": "Update only the name",
            "name": "product_search_v2"
          },
          {
            "description": "Enhanced with better caching",
            "tags": [
              "production",
              "cached"
            ]
          },
          {
            "description": "Latest version with improved performance",
            "name": "customer_lookup_v3",
            "tags": [
              "production",
              "optimized",
              "v3"
            ]
          }
        ]
      },
      "PatchRetrieverResponse": {
        "properties": {
          "retriever": {
            "$ref": "#/components/schemas/PipelineConfig",
            "description": "Updated retriever configuration."
          }
        },
        "type": "object",
        "required": [
          "retriever"
        ],
        "title": "PatchRetrieverResponse",
        "description": "Response after updating a retriever."
      },
      "PatchTaxonomyRequest": {
        "properties": {
          "taxonomy_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Taxonomy Name",
            "description": "Updated name for the taxonomy"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Updated description for the taxonomy"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Updated metadata for the taxonomy"
          }
        },
        "type": "object",
        "title": "PatchTaxonomyRequest",
        "description": "Request model for partially updating a taxonomy (PATCH operation)."
      },
      "PayloadIndexConfig-Input": {
        "properties": {
          "field_name": {
            "type": "string",
            "title": "Field Name"
          },
          "type": {
            "$ref": "#/components/schemas/PayloadSchemaType"
          },
          "field_schema": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TextIndexParams"
              },
              {
                "$ref": "#/components/schemas/IntegerIndexParams"
              },
              {
                "$ref": "#/components/schemas/KeywordIndexParams"
              },
              {
                "$ref": "#/components/schemas/FloatIndexParams"
              },
              {
                "$ref": "#/components/schemas/GeoIndexParams"
              },
              {
                "$ref": "#/components/schemas/DatetimeIndexParams"
              },
              {
                "$ref": "#/components/schemas/UuidIndexParams"
              },
              {
                "$ref": "#/components/schemas/BoolIndexParams"
              },
              {
                "type": "null"
              }
            ],
            "title": "Field Schema"
          }
        },
        "type": "object",
        "required": [
          "field_name",
          "type"
        ],
        "title": "PayloadIndexConfig",
        "description": "Configuration for a payload index."
      },
      "PayloadIndexConfig-Output": {
        "properties": {
          "field_name": {
            "type": "string",
            "title": "Field Name"
          },
          "type": {
            "$ref": "#/components/schemas/PayloadSchemaType"
          },
          "field_schema": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TextIndexParams"
              },
              {
                "$ref": "#/components/schemas/IntegerIndexParams"
              },
              {
                "$ref": "#/components/schemas/KeywordIndexParams"
              },
              {
                "$ref": "#/components/schemas/FloatIndexParams"
              },
              {
                "$ref": "#/components/schemas/GeoIndexParams"
              },
              {
                "$ref": "#/components/schemas/DatetimeIndexParams"
              },
              {
                "$ref": "#/components/schemas/UuidIndexParams"
              },
              {
                "$ref": "#/components/schemas/BoolIndexParams"
              },
              {
                "type": "null"
              }
            ],
            "title": "Field Schema"
          }
        },
        "type": "object",
        "required": [
          "field_name",
          "type"
        ],
        "title": "PayloadIndexConfig",
        "description": "Configuration for a payload index."
      },
      "PayloadSchemaType": {
        "type": "string",
        "enum": [
          "keyword",
          "integer",
          "float",
          "bool",
          "geo",
          "datetime",
          "text",
          "uuid"
        ],
        "title": "PayloadSchemaType",
        "description": "Payload schema type."
      },
      "Permission": {
        "type": "string",
        "enum": [
          "read",
          "write",
          "delete",
          "admin"
        ],
        "title": "Permission",
        "description": "Simplified API key permissions.\n\nThis four-value enum replaces the legacy 16-permission model. Keep usage\nsimple: prefer the least privileged option that satisfies the workflow.\n\nHierarchy (strongest -> weakest): ADMIN > DELETE > WRITE > READ."
      },
      "PipelineConfig": {
        "properties": {
          "pipeline_id": {
            "type": "string",
            "title": "Pipeline Id",
            "description": "Stable pipeline identifier (REQUIRED)."
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "title": "Name",
            "description": "Unique pipeline name within namespace (REQUIRED)."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Detailed description of pipeline behaviour (OPTIONAL)."
          },
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Collection Ids",
            "description": "Collections queried by the pipeline (REQUIRED)."
          },
          "stages": {
            "items": {
              "$ref": "#/components/schemas/PipelineStageConfig"
            },
            "type": "array",
            "minItems": 1,
            "title": "Stages",
            "description": "Ordered list of stage configurations (REQUIRED)."
          },
          "input_schema": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Output"
            },
            "type": "object",
            "title": "Input Schema",
            "description": "JSON Schema describing expected user inputs (REQUIRED). Properties must use BucketSchemaField for consistency with ingestion schemas."
          },
          "budget_limits": {
            "$ref": "#/components/schemas/BudgetLimits",
            "description": "Execution budget limits for the pipeline (OPTIONAL)."
          },
          "feature_dependencies": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/FeatureAddress"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Feature Dependencies",
            "description": "Feature addresses required by stages (OPTIONAL, aids validation)."
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Arbitrary tags to help organise pipelines (OPTIONAL)."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp in UTC (REQUIRED)."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Last update timestamp in UTC (REQUIRED)."
          },
          "created_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created By",
            "description": "Identifier of the user who created the pipeline (OPTIONAL)."
          },
          "updated_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Updated By",
            "description": "Identifier of the user who last updated the pipeline (OPTIONAL)."
          }
        },
        "type": "object",
        "required": [
          "name",
          "collection_ids",
          "stages"
        ],
        "title": "PipelineConfig",
        "description": "Full pipeline definition persisted in MongoDB.",
        "examples": [
          {
            "budget_limits": {
              "max_credits": 100,
              "max_time_ms": 60000
            },
            "collection_ids": [
              "col_marketing_ads"
            ],
            "input_schema": {
              "query_text": {
                "description": "Full-text query",
                "type": "string"
              }
            },
            "name": "executive_ads_search",
            "pipeline_id": "pipe_abc123",
            "stages": [
              {
                "config": {
                  "parameters": {
                    "field": "metadata.spend",
                    "operator": "gt",
                    "value": 1000
                  },
                  "stage_name": "attribute_filter",
                  "version": "v1"
                },
                "name": "filter_high_spend",
                "stage_type": "filter"
              }
            ]
          }
        ]
      },
      "PipelineExecutionStatistics": {
        "properties": {
          "stages": {
            "additionalProperties": {
              "$ref": "#/components/schemas/StageStatistics"
            },
            "type": "object",
            "title": "Stages",
            "description": "Per-stage statistics keyed by stage instance name (REQUIRED)."
          },
          "total_time_ms": {
            "type": "number",
            "minimum": 0.0,
            "title": "Total Time Ms",
            "description": "Total pipeline execution time in milliseconds (REQUIRED).",
            "default": 0.0
          },
          "credits_used": {
            "type": "number",
            "minimum": 0.0,
            "title": "Credits Used",
            "description": "Total credits consumed across all stages (OPTIONAL in MVP).",
            "default": 0.0
          }
        },
        "type": "object",
        "title": "PipelineExecutionStatistics",
        "description": "Aggregated execution statistics for an entire pipeline run."
      },
      "PipelineExecutionSummary": {
        "properties": {
          "execution_id": {
            "type": "string",
            "title": "Execution Id",
            "description": "Execution identifier"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Execution status"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp"
          },
          "completed_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completed At",
            "description": "Completion timestamp when available"
          },
          "duration_ms": {
            "type": "number",
            "minimum": 0.0,
            "title": "Duration Ms",
            "description": "Total execution time in ms"
          },
          "credits_used": {
            "type": "number",
            "minimum": 0.0,
            "title": "Credits Used",
            "description": "Credits consumed"
          },
          "total_processed": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Processed",
            "description": "Documents processed across stages"
          },
          "total_returned": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Returned",
            "description": "Documents returned to caller"
          },
          "cache_hit_rate": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Cache Hit Rate",
            "description": "Average cache hit rate for stages"
          },
          "inputs_hash": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inputs Hash",
            "description": "Stable hash of pipeline inputs for dedupe"
          },
          "query_summary": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query Summary",
            "description": "Representative snippet of query inputs"
          }
        },
        "type": "object",
        "required": [
          "execution_id",
          "status",
          "created_at",
          "duration_ms",
          "credits_used",
          "total_processed",
          "total_returned"
        ],
        "title": "PipelineExecutionSummary",
        "description": "Summary document used for execution history listings."
      },
      "PipelineStageConfig": {
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "title": "Name",
            "description": "Human-readable stage instance name (REQUIRED)."
          },
          "stage_type": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StageType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Functional category of the stage. Optional for creation requests; auto-inferred from `stage_id` when omitted."
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "Stage implementation parameters (REQUIRED). Must include `stage_id` key referencing a registered retriever stage. Supports template expressions resolved at execution time. Provide stage-specific configuration under `parameters`."
          },
          "batch_size": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Batch Size",
            "description": "Optional templated batch size expression evaluated per execution. Defaults to stage-specific value when omitted."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "User-facing description of the stage (OPTIONAL)."
          }
        },
        "type": "object",
        "required": [
          "name",
          "config"
        ],
        "title": "PipelineStageConfig",
        "description": "Configuration for a single stage within a pipeline.",
        "examples": [
          {
            "config": {
              "parameters": {
                "feature_uri": "mixpeek://text_extractor@v1/embedding",
                "query_text": "{{INPUT.query_text}}",
                "top_k": 100
              },
              "stage_id": "hybrid_search"
            },
            "name": "semantic_search",
            "stage_type": "search"
          }
        ]
      },
      "PresignedURLModel": {
        "properties": {
          "key_name": {
            "type": "string",
            "title": "Key Name",
            "description": "Logical name or filename, e.g., 'thumb.jpg'"
          },
          "object_key": {
            "type": "string",
            "title": "Object Key",
            "description": "Full S3 object key"
          },
          "presigned_url": {
            "type": "string",
            "minLength": 1,
            "format": "uri",
            "title": "Presigned Url",
            "description": "Time-limited HTTPS URL"
          }
        },
        "type": "object",
        "required": [
          "key_name",
          "object_key",
          "presigned_url"
        ],
        "title": "PresignedURLModel",
        "description": "Typed presigned URL entry for a related S3 object."
      },
      "RangeBucket": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "Numeric field to create buckets for. REQUIRED, must be a numeric field. Supports dot notation for nested fields. Values will be grouped into ranges defined by boundaries.",
            "examples": [
              "metadata.duration",
              "metadata.views",
              "metadata.file_size"
            ]
          },
          "boundaries": {
            "items": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                }
              ]
            },
            "type": "array",
            "minItems": 1,
            "title": "Boundaries",
            "description": "List of boundary values defining bucket ranges. REQUIRED, must be sorted in ascending order. Creates N+1 buckets for N boundaries: [0, 10, 20] creates: <0, 0-10, 10-20, >20. Values on boundaries go into the lower bucket.",
            "examples": [
              [
                0,
                60,
                300,
                600
              ],
              [
                0,
                100,
                1000,
                10000
              ]
            ]
          },
          "default_bucket": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Default Bucket",
            "description": "Name for values outside defined boundaries. OPTIONAL, defaults to 'other'. Used for values below min or above max boundary.",
            "examples": [
              "other",
              "outliers",
              "unknown"
            ]
          }
        },
        "type": "object",
        "required": [
          "field",
          "boundaries"
        ],
        "title": "RangeBucket",
        "description": "Configuration for range-based bucketing.\n\nGroups numeric values into ranges/buckets for histogram-style analysis.\n\nRequirements:\n    - field: REQUIRED, numeric field to bucket\n    - boundaries: REQUIRED, list of boundary values defining buckets\n    - default_bucket: OPTIONAL, name for values outside boundaries\n\nExamples:\n    - Video duration buckets: [0, 60, 300, 600] creates: 0-60s, 60-300s, 300-600s, 600+s\n    - View count buckets: [0, 100, 1000, 10000] creates: 0-100, 100-1K, 1K-10K, 10K+ views",
        "examples": [
          {
            "boundaries": [
              0,
              60,
              300,
              600
            ],
            "default_bucket": "over_600s",
            "description": "Duration buckets (0-60s, 60-300s, 300-600s, 600+s)",
            "field": "metadata.duration"
          },
          {
            "boundaries": [
              0,
              100,
              1000,
              10000
            ],
            "default_bucket": "viral",
            "description": "View count buckets",
            "field": "metadata.views"
          }
        ]
      },
      "ResourceScope": {
        "properties": {
          "resource_type": {
            "$ref": "#/components/schemas/ResourceType",
            "description": "Resource type this scope governs. Use ResourceType enum values to scope a key to namespaces, collections, clusters, etc."
          },
          "resource_id": {
            "type": "string",
            "maxLength": 100,
            "minLength": 1,
            "title": "Resource Id",
            "description": "Identifier or pattern for the resource. Accepts a literal ID (e.g. 'ns_production') or wildcard forms such as '*' or 'ns_customer_*'."
          },
          "operations": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/NamespaceOperation"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Operations",
            "description": "Subset of operations allowed within the scope. When omitted the key may perform any operation permitted by its Permission list."
          }
        },
        "type": "object",
        "required": [
          "resource_type",
          "resource_id"
        ],
        "title": "ResourceScope",
        "description": "Fine-grained restriction applied to an API key.",
        "examples": [
          {
            "description": "Full namespace access (data + infrastructure)",
            "resource_id": "ns_production",
            "resource_type": "namespace"
          },
          {
            "description": "Analytics-only access in namespace",
            "operations": [
              "read_data",
              "execute_retriever"
            ],
            "resource_id": "ns_customer_123",
            "resource_type": "namespace"
          },
          {
            "description": "Specific collection only",
            "resource_id": "col_products",
            "resource_type": "collection"
          }
        ]
      },
      "ResourceType": {
        "type": "string",
        "enum": [
          "organization",
          "user",
          "api_key",
          "namespace",
          "collection",
          "bucket",
          "retriever",
          "cluster",
          "storage_connection"
        ],
        "title": "ResourceType",
        "description": "Resource surfaces supported by scoped API keys and audit events.\n\nThese resource types can be used in:\n- API key scopes to restrict access to specific resources\n- Audit logs to identify what type of resource was affected\n- Permission systems to grant/deny access to resource categories\n\nResource hierarchy:\n    ORGANIZATION -> USER, API_KEY, STORAGE_CONNECTION\n    NAMESPACE -> COLLECTION, BUCKET, RETRIEVER, CLUSTER\n\nResource types:\n    - ORGANIZATION: Top-level tenant entity\n    - USER: Organization member with authentication credentials\n    - API_KEY: Authentication token for programmatic access\n    - NAMESPACE: Isolated environment for data and compute resources\n    - COLLECTION: Vector database collection for searchable documents\n    - BUCKET: Object storage container for raw files\n    - RETRIEVER: Configured search/retrieval pipeline\n    - CLUSTER: Ray compute cluster for distributed processing\n    - STORAGE_CONNECTION: External storage provider integration"
      },
      "RetrieverModel-Input": {
        "properties": {
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "Unique identifier for the retriever"
          },
          "retriever_name": {
            "type": "string",
            "title": "Retriever Name",
            "description": "Name of the retriever"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the retriever"
          },
          "input_schema": {
            "$ref": "#/components/schemas/RetrieverSchema",
            "description": "Input schema for the retriever"
          },
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Collection Ids",
            "description": "List of collection IDs"
          },
          "stages": {
            "items": {
              "$ref": "#/components/schemas/StageInstanceConfig"
            },
            "type": "array",
            "title": "Stages",
            "description": "List of stage configurations"
          },
          "cache_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CacheConfig"
              },
              {
                "type": "null"
              }
            ],
            "description": "Cache configuration for this retriever. If not provided, caching is disabled."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "When the retriever was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "When the retriever was last modified"
          },
          "last_executed_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Executed At",
            "description": "When the retriever was last executed"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the retriever is enabled (can be toggled on/off)",
            "default": true
          },
          "status": {
            "$ref": "#/components/schemas/RetrieverStatus",
            "description": "Current operational status",
            "default": "active"
          },
          "usage_stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UsageStatistics"
              },
              {
                "type": "null"
              }
            ],
            "description": "Usage and performance statistics"
          },
          "collections": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CollectionDetail"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Collections",
            "description": "Expanded collection details with names and metadata"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Custom key-value metadata"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for organization and filtering"
          },
          "created_by": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CreatorInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Information about who created this retriever"
          },
          "updated_by": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/CreatorInfo"
              },
              {
                "type": "null"
              }
            ],
            "description": "Information about who last updated this retriever"
          },
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "Version number (increments on each update)",
            "default": 1
          },
          "revision_history": {
            "items": {
              "$ref": "#/components/schemas/RevisionHistoryEntry"
            },
            "type": "array",
            "title": "Revision History",
            "description": "History of changes (optional, last N changes)"
          },
          "health": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HealthCheck"
              },
              {
                "type": "null"
              }
            ],
            "description": "Health status and diagnostics"
          }
        },
        "type": "object",
        "required": [
          "retriever_name",
          "input_schema",
          "collection_ids",
          "stages"
        ],
        "title": "RetrieverModel",
        "description": "Retriever model."
      },
      "RetrieverModel-Output": {
        "properties": {
          "pipeline_id": {
            "type": "string",
            "title": "Pipeline Id",
            "description": "Stable pipeline identifier (REQUIRED)."
          },
          "name": {
            "type": "string",
            "minLength": 1,
            "title": "Name",
            "description": "Unique pipeline name within namespace (REQUIRED)."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Detailed description of pipeline behaviour (OPTIONAL)."
          },
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Collection Ids",
            "description": "Collections queried by the pipeline (REQUIRED)."
          },
          "stages": {
            "items": {
              "$ref": "#/components/schemas/PipelineStageConfig"
            },
            "type": "array",
            "minItems": 1,
            "title": "Stages",
            "description": "Ordered list of stage configurations (REQUIRED)."
          },
          "input_schema": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Output"
            },
            "type": "object",
            "title": "Input Schema",
            "description": "JSON Schema describing expected user inputs (REQUIRED). Properties must use BucketSchemaField for consistency with ingestion schemas."
          },
          "budget_limits": {
            "$ref": "#/components/schemas/BudgetLimits",
            "description": "Execution budget limits for the pipeline (OPTIONAL)."
          },
          "feature_dependencies": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/FeatureAddress"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Feature Dependencies",
            "description": "Feature addresses required by stages (OPTIONAL, aids validation)."
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Arbitrary tags to help organise pipelines (OPTIONAL)."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp in UTC (REQUIRED)."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Last update timestamp in UTC (REQUIRED)."
          },
          "created_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created By",
            "description": "Identifier of the user who created the pipeline (OPTIONAL)."
          },
          "updated_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Updated By",
            "description": "Identifier of the user who last updated the pipeline (OPTIONAL)."
          }
        },
        "type": "object",
        "required": [
          "name",
          "collection_ids",
          "stages"
        ],
        "title": "RetrieverModel",
        "description": "Retriever configuration model exposed via API.",
        "examples": [
          {
            "budget_limits": {
              "max_credits": 100,
              "max_time_ms": 60000
            },
            "collection_ids": [
              "col_marketing_ads"
            ],
            "input_schema": {
              "query_text": {
                "description": "Full-text query",
                "type": "string"
              }
            },
            "name": "executive_ads_search",
            "pipeline_id": "pipe_abc123",
            "stages": [
              {
                "config": {
                  "parameters": {
                    "field": "metadata.spend",
                    "operator": "gt",
                    "value": 1000
                  },
                  "stage_name": "attribute_filter",
                  "version": "v1"
                },
                "name": "filter_high_spend",
                "stage_type": "filter"
              }
            ]
          }
        ]
      },
      "RetrieverPerformanceResponse": {
        "properties": {
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "Retriever identifier",
            "examples": [
              "ret_abc123"
            ]
          },
          "time_range": {
            "$ref": "#/components/schemas/TimeRange",
            "description": "Time range of the data"
          },
          "metrics": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Metrics",
            "description": "Time-series performance metrics"
          },
          "summary": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Summary",
            "description": "Aggregated summary statistics"
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "time_range",
          "metrics"
        ],
        "title": "RetrieverPerformanceResponse",
        "description": "Retriever performance metrics response.",
        "examples": [
          {
            "metrics": [
              {
                "avg_latency_ms": 145.3,
                "avg_results": 10.5,
                "p95_latency_ms": 287.5,
                "p99_latency_ms": 456.2,
                "query_count": 245,
                "time_bucket": "2025-10-28T00:00:00Z"
              }
            ],
            "retriever_id": "ret_abc123",
            "summary": {
              "avg_latency_ms": 152.8,
              "p95_latency_ms": 295.2,
              "p99_latency_ms": 502.1,
              "total_queries": 5234
            },
            "time_range": {
              "end": "2025-10-29T00:00:00Z",
              "start": "2025-10-28T00:00:00Z"
            }
          }
        ]
      },
      "RetrieverSchema": {
        "properties": {
          "properties": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Input"
            },
            "type": "object",
            "title": "Properties"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "properties"
        ],
        "title": "RetrieverSchema",
        "description": "Schema definition for retriever inputs."
      },
      "RetrieverSignal": {
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Event timestamp"
          },
          "execution_id": {
            "type": "string",
            "title": "Execution Id",
            "description": "Execution identifier"
          },
          "signal_type": {
            "type": "string",
            "title": "Signal Type",
            "description": "Type of signal",
            "examples": [
              "cache_hit",
              "rerank_scores",
              "filter_reduction"
            ]
          },
          "signal_data": {
            "additionalProperties": true,
            "type": "object",
            "title": "Signal Data",
            "description": "Signal-specific data"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Additional metadata"
          }
        },
        "type": "object",
        "required": [
          "timestamp",
          "execution_id",
          "signal_type",
          "signal_data"
        ],
        "title": "RetrieverSignal",
        "description": "Single retriever signal event."
      },
      "RetrieverStageDefinition": {
        "properties": {
          "stage_id": {
            "type": "string",
            "title": "Stage Id",
            "description": "The unique identifier of the stage."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "A description of what the stage does."
          },
          "category": {
            "type": "string",
            "title": "Category",
            "description": "Category of the stage (search, reduce, rank, external, enrich, transform, compose)."
          },
          "icon": {
            "type": "string",
            "title": "Icon",
            "description": "Lucide-react icon name for frontend rendering."
          },
          "parameter_schema": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parameter Schema",
            "description": "The schema for the parameters this stage accepts."
          }
        },
        "type": "object",
        "required": [
          "stage_id",
          "description",
          "category",
          "icon"
        ],
        "title": "RetrieverStageDefinition",
        "description": "Public definition of a retriever stage.",
        "examples": [
          {
            "category": "search",
            "description": "Performs semantic similarity search using dense vector embeddings",
            "icon": "brain-circuit",
            "parameter_schema": {
              "properties": {
                "feature_address": {
                  "type": "string"
                },
                "limit": {
                  "default": 10,
                  "minimum": 1,
                  "type": "integer"
                },
                "min_score": {
                  "maximum": 1.0,
                  "minimum": 0.0,
                  "type": "number"
                }
              },
              "required": [
                "feature_address"
              ],
              "type": "object"
            },
            "stage_id": "semantic_search"
          }
        ]
      },
      "RetrieverStatus": {
        "type": "string",
        "enum": [
          "active",
          "draft",
          "disabled",
          "error"
        ],
        "title": "RetrieverStatus",
        "description": "Status of a retriever."
      },
      "RevisionHistoryEntry": {
        "properties": {
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "Version number"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "When this version was created"
          },
          "updated_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Updated By",
            "description": "User who made the change"
          },
          "changes": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Changes",
            "description": "Description of changes made"
          }
        },
        "type": "object",
        "required": [
          "version",
          "updated_at"
        ],
        "title": "RevisionHistoryEntry",
        "description": "A single entry in the revision history."
      },
      "S3AccessKeyCredentials": {
        "properties": {
          "type": {
            "type": "string",
            "const": "access_key",
            "title": "Type",
            "default": "access_key"
          },
          "access_key_id": {
            "type": "string",
            "maxLength": 128,
            "minLength": 16,
            "title": "Access Key Id",
            "description": "REQUIRED. AWS access key ID for authentication. Format: 20-character alphanumeric string starting with 'AKIA' (long-term) or 'ASIA' (temporary). Obtain from: AWS Console > IAM > Users > Security Credentials",
            "examples": [
              "AKIAIOSFODNN7EXAMPLE",
              "ASIAIOSFODNN7EXAMPLE"
            ]
          },
          "secret_access_key": {
            "type": "string",
            "minLength": 40,
            "title": "Secret Access Key",
            "description": "REQUIRED. AWS secret access key for authentication. SECURITY: This field is encrypted at rest. Never log or expose this value. Format: 40-character base64-encoded string. Obtain from: AWS Console when creating/viewing access key (shown only once)"
          },
          "session_token": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Session Token",
            "description": "NOT REQUIRED. Temporary session token for AWS STS credentials. REQUIRED when using temporary security credentials from AWS STS. NOT REQUIRED for long-term IAM user access keys. SECURITY: Encrypted at rest. Automatically expires after session duration. Format: Base64-encoded string, typically several hundred characters. Use case: Enhanced security with automatic credential rotation"
          }
        },
        "type": "object",
        "required": [
          "access_key_id",
          "secret_access_key"
        ],
        "title": "S3AccessKeyCredentials",
        "description": "AWS S3 access key and secret credentials.\n\nAccess keys provide programmatic access to S3 buckets using long-lived credentials.\nThis authentication method is straightforward but less secure than IAM role assumption.\n\nPrerequisites:\n    - IAM user or role with S3 access permissions\n    - Access key and secret key generated in AWS Console\n    - Appropriate bucket policies or IAM policies configured\n\nSecurity Considerations:\n    - Access keys are long-lived and don't automatically expire\n    - secret_access_key is encrypted at rest but should be rotated regularly\n    - Consider using IAM role assumption (S3RoleCredentials) for production\n    - Never commit access keys to version control\n\nUse Cases:\n    - Quick prototyping and development\n    - Testing S3 integrations\n    - Temporary credentials with session_token for enhanced security\n    - Accessing S3-compatible services (MinIO, DigitalOcean Spaces)\n\nRecommended Alternative:\n    For production deployments, use S3RoleCredentials with IAM role assumption\n    instead of access keys for better security and credential management."
      },
      "S3Config": {
        "properties": {
          "provider_type": {
            "type": "string",
            "const": "s3",
            "title": "Provider Type",
            "default": "s3"
          },
          "credentials": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/S3AccessKeyCredentials"
              },
              {
                "$ref": "#/components/schemas/S3RoleCredentials"
              }
            ],
            "title": "Credentials",
            "description": "REQUIRED. AWS authentication credentials configuration. Choose 'iam_role' for production deployments (recommended) or 'access_key' for development, testing, or S3-compatible services. The 'type' field determines which credential mechanism is used.",
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "access_key": "#/components/schemas/S3AccessKeyCredentials",
                "iam_role": "#/components/schemas/S3RoleCredentials"
              }
            }
          },
          "region": {
            "type": "string",
            "title": "Region",
            "description": "REQUIRED. AWS region where the S3 bucket is located. Must match the bucket's actual region to avoid routing errors. For S3-compatible services, use their documented region value or 'us-east-1' as a default if regions are not applicable. Format: AWS region code (e.g., us-east-1, eu-west-1)",
            "examples": [
              "us-east-1",
              "us-west-2",
              "eu-west-1",
              "ap-southeast-1",
              "ca-central-1"
            ]
          },
          "endpoint_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Endpoint Url",
            "description": "NOT REQUIRED for AWS S3 (uses default AWS endpoints). REQUIRED for S3-compatible services to specify custom endpoint URL. Must be a valid HTTPS or HTTP URL without trailing slash. Examples: - MinIO: https://minio.example.com - DigitalOcean Spaces: https://nyc3.digitaloceanspaces.com - Wasabi: https://s3.wasabisys.com",
            "examples": [
              "https://s3.wasabisys.com",
              "https://nyc3.digitaloceanspaces.com",
              "https://minio.company.com",
              "http://localhost:9000"
            ]
          },
          "use_ssl": {
            "type": "boolean",
            "title": "Use Ssl",
            "description": "Whether to use TLS/SSL encryption for connections to S3. RECOMMENDED: Always True for production environments. Set to False only for local development with unencrypted endpoints. Default: True",
            "default": true
          },
          "verify_ssl": {
            "type": "boolean",
            "title": "Verify Ssl",
            "description": "Whether to verify TLS/SSL certificates when connecting. RECOMMENDED: Always True for production to prevent MITM attacks. Set to False only for development with self-signed certificates. Requires use_ssl=True to have any effect. Default: True",
            "default": true
          }
        },
        "type": "object",
        "required": [
          "credentials",
          "region"
        ],
        "title": "S3Config",
        "description": "Amazon S3 and S3-compatible storage provider configuration.\n\nThis configuration enables Mixpeek to connect to Amazon S3 or S3-compatible\nstorage services (MinIO, DigitalOcean Spaces, Wasabi, Backblaze B2, etc.)\nfor automated object ingestion and synchronization.\n\nAuthentication Methods:\n    1. IAM Role Assumption (RECOMMENDED for production):\n        - Most secure option with automatic credential rotation\n        - No long-lived credentials shared\n        - Ideal for customer-owned S3 buckets\n\n    2. Access Keys:\n        - Simpler setup for development and testing\n        - Works with S3-compatible services\n        - Requires manual credential rotation\n\nRequirements:\n    - Valid AWS credentials or IAM role configuration\n    - S3 bucket with appropriate permissions (s3:GetObject, s3:ListBucket)\n    - Network connectivity to S3 endpoint\n    - Correct region configuration\n\nSupported Services:\n    - Amazon S3 (all regions)\n    - MinIO (self-hosted or cloud)\n    - DigitalOcean Spaces\n    - Wasabi Cloud Storage\n    - Backblaze B2\n    - Any S3-compatible storage with compatible API\n\nUse Cases:\n    - Ingest videos from data lakes\n    - Sync images from marketing asset buckets\n    - Process documents from archive storage\n    - Monitor and index uploaded files\n    - Backup and disaster recovery workflows",
        "examples": [
          {
            "credentials": {
              "external_id": "mixpeek-org_abc123",
              "role_arn": "arn:aws:iam::123456789012:role/mixpeek-storage-sync-role",
              "type": "iam_role"
            },
            "description": "Production AWS S3 with IAM role (recommended)",
            "provider_type": "s3",
            "region": "us-east-1",
            "use_ssl": true,
            "verify_ssl": true
          },
          {
            "credentials": {
              "access_key_id": "AKIAIOSFODNN7EXAMPLE",
              "secret_access_key": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
              "type": "access_key"
            },
            "description": "Development AWS S3 with access keys",
            "provider_type": "s3",
            "region": "us-west-2",
            "use_ssl": true,
            "verify_ssl": true
          },
          {
            "credentials": {
              "access_key_id": "minioadmin",
              "secret_access_key": "minioadmin",
              "type": "access_key"
            },
            "description": "MinIO self-hosted S3-compatible storage",
            "endpoint_url": "https://minio.company.com",
            "provider_type": "s3",
            "region": "us-east-1",
            "use_ssl": true,
            "verify_ssl": true
          },
          {
            "credentials": {
              "access_key_id": "DO00EXAMPLE",
              "secret_access_key": "secretkeyexample123",
              "type": "access_key"
            },
            "description": "DigitalOcean Spaces",
            "endpoint_url": "https://nyc3.digitaloceanspaces.com",
            "provider_type": "s3",
            "region": "nyc3",
            "use_ssl": true,
            "verify_ssl": true
          },
          {
            "credentials": {
              "access_key_id": "minioadmin",
              "secret_access_key": "minioadmin",
              "type": "access_key"
            },
            "description": "Local development MinIO without SSL",
            "endpoint_url": "http://localhost:9000",
            "provider_type": "s3",
            "region": "us-east-1",
            "use_ssl": false,
            "verify_ssl": false
          }
        ]
      },
      "S3RoleCredentials": {
        "properties": {
          "type": {
            "type": "string",
            "const": "iam_role",
            "title": "Type",
            "default": "iam_role"
          },
          "role_arn": {
            "type": "string",
            "pattern": "^arn:aws:iam::\\d{12}:role/[\\w+=,.@-]+$",
            "title": "Role Arn",
            "description": "REQUIRED. Amazon Resource Name (ARN) of the IAM role to assume. This role must exist in the customer's AWS account and have a trust relationship configured to allow Mixpeek to assume it. Format: arn:aws:iam::{account-id}:role/{role-name} Example trust policy should allow principal: arn:aws:iam::{mixpeek-account}:root Recommended role name: mixpeek-storage-sync-role",
            "examples": [
              "arn:aws:iam::123456789012:role/mixpeek-storage-sync-role",
              "arn:aws:iam::999888777666:role/external-ingestion-access"
            ]
          },
          "external_id": {
            "type": "string",
            "maxLength": 128,
            "minLength": 8,
            "title": "External Id",
            "description": "REQUIRED. External ID for secure role assumption (prevents confused deputy attacks). This value should be unique to your organization and kept confidential. Mixpeek provides this value during connection setup. Must match the ExternalId condition in the role's trust policy. Format: Recommended pattern is mixpeek-{organization_id} Security: Include this in the trust policy Condition statement",
            "examples": [
              "mixpeek-org_abc123def456ghi",
              "mixpeek-customer-enterprise-xyz"
            ]
          }
        },
        "type": "object",
        "required": [
          "role_arn",
          "external_id"
        ],
        "title": "S3RoleCredentials",
        "description": "AWS S3 IAM role assumption credentials (RECOMMENDED for production).\n\nIAM role assumption provides secure, temporary credentials for accessing customer\nS3 buckets without sharing long-lived access keys. This is the recommended\nauthentication method for production deployments.\n\nHow It Works:\n    1. Customer creates an IAM role in their AWS account\n    2. Role trust policy allows Mixpeek AWS account to assume the role\n    3. External ID provides additional security against confused deputy attacks\n    4. Mixpeek assumes the role and receives temporary credentials (auto-renewed)\n    5. Temporary credentials are used to access the customer's S3 bucket\n\nPrerequisites:\n    1. Create IAM role in customer AWS account\n    2. Attach policy granting s3:GetObject, s3:ListBucket permissions\n    3. Configure trust relationship to allow Mixpeek account\n    4. Use organization-specific external_id for security\n    5. Share role ARN with Mixpeek\n\nSecurity Advantages:\n    - No long-lived credentials shared with third parties\n    - Temporary credentials automatically rotate (1-hour sessions by default)\n    - Customer retains full control and can revoke access anytime\n    - External ID prevents confused deputy attacks\n    - Audit trail in CloudTrail for all access\n\nUse Cases:\n    - Production deployments accessing customer S3 buckets\n    - Enterprise integrations requiring strong security\n    - Multi-tenant environments with customer-owned storage\n    - Compliance-sensitive workloads (HIPAA, SOC 2, etc.)",
        "examples": [
          {
            "description": "Production role assumption with external ID",
            "external_id": "mixpeek-org_abc123def456ghi",
            "role_arn": "arn:aws:iam::123456789012:role/mixpeek-storage-sync-role",
            "type": "iam_role"
          }
        ],
        "trust_policy_example": {
          "Statement": [
            {
              "Action": "sts:AssumeRole",
              "Condition": {
                "StringEquals": {
                  "sts:ExternalId": "mixpeek-org_abc123def456ghi"
                }
              },
              "Effect": "Allow",
              "Principal": {
                "AWS": "arn:aws:iam::{mixpeek-account-id}:root"
              }
            }
          ],
          "Version": "2012-10-17"
        }
      },
      "ScrollPaginationParams": {
        "properties": {
          "method": {
            "$ref": "#/components/schemas/PaginationMethod",
            "description": "Constant identifying scroll pagination (REQUIRED).",
            "default": "scroll"
          },
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Number of documents to fetch in this scroll page (REQUIRED).",
            "default": 100
          },
          "scroll_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Scroll Id",
            "description": "Server-issued identifier linking scroll session (OPTIONAL)."
          },
          "scroll_ttl": {
            "type": "integer",
            "maximum": 3600.0,
            "minimum": 60.0,
            "title": "Scroll Ttl",
            "description": "Seconds to keep scroll context alive (REQUIRED, defaults to 5 minutes).",
            "default": 300
          }
        },
        "type": "object",
        "title": "ScrollPaginationParams",
        "description": "Scroll-style pagination maintaining server-side context for TTL."
      },
      "SearchInteraction": {
        "properties": {
          "feature_id": {
            "type": "string",
            "title": "Feature Id",
            "description": "ID of the document/feature that was interacted with. REQUIRED. This should be the document_id returned in retriever results. Used to track which specific items users engage with.",
            "examples": [
              "doc_abc123",
              "prod_xyz789",
              "feat_12345"
            ]
          },
          "interaction_type": {
            "items": {
              "$ref": "#/components/schemas/InteractionType"
            },
            "type": "array",
            "minItems": 1,
            "title": "Interaction Type",
            "description": "List of interaction types that occurred. REQUIRED. Multiple types can be recorded simultaneously (e.g., VIEW + CLICK + LONG_VIEW for a result the user engaged with). Use the InteractionType enum values.",
            "examples": [
              [
                "click"
              ],
              [
                "positive_feedback",
                "click",
                "long_view"
              ],
              [
                "negative_feedback"
              ],
              [
                "purchase",
                "click"
              ]
            ]
          },
          "position": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Position",
            "description": "Position in search results where interaction occurred (0-indexed). NOT REQUIRED. Critical for Learning to Rank - helps identify position bias. E.g., position=0 means first result, position=9 means 10th result. Higher engagement at lower positions suggests higher quality.",
            "examples": [
              0,
              1,
              5,
              15
            ]
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Additional context about the interaction. NOT REQUIRED. Can include device, duration, viewport info, etc. Use this to enrich interaction data with application-specific context.",
            "examples": [
              {
                "device": "mobile",
                "duration_ms": 5000,
                "page": "search_results",
                "viewport_position": 0.75
              },
              {
                "interaction_reason": "not_relevant",
                "page_number": 2,
                "results_count": 50,
                "search_latency_ms": 150
              }
            ]
          },
          "user_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Id",
            "description": "Customer's authenticated user identifier. NOT REQUIRED. Persists across sessions for long-term tracking. Enables personalization and user-specific metrics. Use your application's user ID format.",
            "examples": [
              "user_abc123",
              "customer_456",
              "usr_xyz789"
            ]
          },
          "session_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Session Id",
            "description": "Temporary identifier for a single search session. NOT REQUIRED. Typically 30min-1hr duration. Tracks anonymous and authenticated users within a session. Use to group related queries and understand search journeys.",
            "examples": [
              "sess_abc123",
              "session_xyz789_1234567890"
            ]
          }
        },
        "type": "object",
        "required": [
          "feature_id",
          "interaction_type"
        ],
        "title": "SearchInteraction",
        "description": "Records a user interaction with a search result.\n\nThis model captures user behavior signals that can be used to improve retrieval quality.\nEach interaction represents a user action (click, view, feedback) on a specific document\nreturned by a retriever.\n\nUse Cases:\n    - Track which search results users actually click on\n    - Collect explicit feedback (thumbs up/down) on result quality\n    - Monitor engagement metrics (time spent viewing, sharing)\n    - Identify problematic queries (zero results, immediate refinements)\n    - Power Learning to Rank models with real user behavior\n\nRequirements:\n    - feature_id: REQUIRED - The document/feature that was interacted with\n    - interaction_type: REQUIRED - Type(s) of interaction that occurred\n    - position: OPTIONAL - Where in results list the interaction occurred\n    - metadata: OPTIONAL - Additional context about the interaction\n    - user_id: OPTIONAL - For personalization and user-specific metrics\n    - session_id: OPTIONAL - For tracking multi-query sessions\n\nRelated Concepts:\n    - Retrievers: Interactions measure retriever performance\n    - Evaluations: Interactions provide real-world complement to offline evaluation\n    - Learning to Rank: Interactions train ranking models",
        "examples": [
          {
            "description": "Simple click interaction",
            "feature_id": "doc_abc123",
            "interaction_type": [
              "click"
            ],
            "position": 2
          },
          {
            "description": "Engaged view with metadata",
            "feature_id": "prod_xyz789",
            "interaction_type": [
              "view",
              "click",
              "long_view"
            ],
            "metadata": {
              "device": "mobile",
              "duration_ms": 12000,
              "viewport_position": 0.85
            },
            "position": 0,
            "session_id": "sess_abc",
            "user_id": "user_123"
          },
          {
            "description": "Negative feedback",
            "feature_id": "doc_bad456",
            "interaction_type": [
              "negative_feedback",
              "return_to_results"
            ],
            "metadata": {
              "interaction_reason": "not_relevant"
            },
            "position": 5,
            "session_id": "sess_xyz"
          },
          {
            "description": "Purchase conversion",
            "feature_id": "prod_789",
            "interaction_type": [
              "purchase"
            ],
            "position": 1,
            "session_id": "sess_purchase_001",
            "user_id": "user_456"
          }
        ]
      },
      "SingleLineageEntry": {
        "properties": {
          "source_config": {
            "$ref": "#/components/schemas/SourceConfig",
            "description": "Configuration of the source for this lineage entry"
          },
          "feature_extractor": {
            "$ref": "#/components/schemas/FeatureExtractorConfig-Output",
            "description": "Single feature extractor applied at this stage"
          },
          "output_schema": {
            "$ref": "#/components/schemas/BucketSchema-Output",
            "description": "Output schema produced by this processing stage"
          }
        },
        "type": "object",
        "required": [
          "source_config",
          "feature_extractor",
          "output_schema"
        ],
        "title": "SingleLineageEntry",
        "description": "Single entry in the lineage chain of a collection.\n\nEach lineage entry represents one processing stage with one feature extractor."
      },
      "SlackConfig": {
        "properties": {
          "webhook_url": {
            "type": "string",
            "title": "Webhook Url",
            "description": "Slack webhook URL"
          },
          "channel": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Channel",
            "description": "Slack channel to send to"
          },
          "username": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Username",
            "description": "Username to use for the message"
          },
          "icon_emoji": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Icon Emoji",
            "description": "Emoji to use as the icon"
          },
          "icon_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Icon Url",
            "description": "URL to an image to use as the icon"
          },
          "blocks_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Blocks Template",
            "description": "Template for Slack blocks"
          }
        },
        "type": "object",
        "required": [
          "webhook_url"
        ],
        "title": "SlackConfig",
        "description": "Configuration for Slack notifications."
      },
      "SmsConfig": {
        "properties": {
          "phone_numbers": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Phone Numbers",
            "description": "Phone numbers to send to"
          },
          "message_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message Template",
            "description": "Template for SMS message"
          }
        },
        "type": "object",
        "required": [
          "phone_numbers"
        ],
        "title": "SmsConfig",
        "description": "Configuration for SMS notifications."
      },
      "SortDirection": {
        "type": "string",
        "enum": [
          "asc",
          "desc"
        ],
        "title": "SortDirection",
        "description": "Sort direction options."
      },
      "SortOption": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "Field to sort by, supports dot notation for nested fields",
            "example": "created_at"
          },
          "direction": {
            "$ref": "#/components/schemas/SortDirection",
            "description": "Sort direction",
            "default": "asc",
            "example": "desc"
          }
        },
        "type": "object",
        "required": [
          "field"
        ],
        "title": "SortOption",
        "description": "Specifies how to sort query results.\n\nAttributes:\n    field: Field to sort by\n    direction: Sort direction (ascending or descending)"
      },
      "SourceCollection-Input": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "The ID of the source collection for the taxonomy."
          },
          "enrichment_fields": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EnrichmentField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enrichment Fields",
            "description": "Fields to copy from matched taxonomy node when enriching (append/replace semantics). If omitted, the full payload is copied."
          }
        },
        "type": "object",
        "required": [
          "collection_id"
        ],
        "title": "SourceCollection",
        "description": "A source collection for a flat taxonomy.",
        "examples": [
          {
            "collection_id": "col_products_v1",
            "enrichment_fields": [
              {
                "field_path": "metadata.tags",
                "merge_mode": "append"
              }
            ],
            "input_mappings": [
              {
                "input_key": "image_vector",
                "path": "features.clip_vit_l_14",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_clip_v1"
          }
        ]
      },
      "SourceCollection-Output": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "The ID of the source collection for the taxonomy."
          },
          "enrichment_fields": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/EnrichmentField"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enrichment Fields",
            "description": "Fields to copy from matched taxonomy node when enriching (append/replace semantics). If omitted, the full payload is copied."
          }
        },
        "type": "object",
        "required": [
          "collection_id"
        ],
        "title": "SourceCollection",
        "description": "A source collection for a flat taxonomy.",
        "examples": [
          {
            "collection_id": "col_products_v1",
            "enrichment_fields": [
              {
                "field_path": "metadata.tags",
                "merge_mode": "append"
              }
            ],
            "input_mappings": [
              {
                "input_key": "image_vector",
                "path": "features.clip_vit_l_14",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_clip_v1"
          }
        ]
      },
      "SourceConfig": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/SourceType",
            "description": "REQUIRED. Type of source for this collection. 'bucket': Process objects from one or more buckets (first-stage processing). 'collection': Process documents from another collection (downstream processing). Use 'bucket' for initial data ingestion, 'collection' for decomposition trees.",
            "examples": [
              "bucket",
              "collection"
            ]
          },
          "bucket_ids": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Bucket Ids",
            "description": "List of bucket IDs when type='bucket'. REQUIRED when type='bucket'. NOT ALLOWED when type='collection'. Can specify one or more buckets to process. Single bucket: Use array with one element ['bkt_id']. Multiple buckets: All buckets MUST have compatible schemas. Schema compatibility validated at collection creation. Compatible schemas have: 1) Same field names, 2) Same field types, 3) Same required status. Documents will include root_bucket_id to track which bucket they came from. Use cases: multi-region data, multi-team consolidation, environment aggregation.",
            "examples": [
              [
                "bkt_marketing_videos"
              ],
              [
                "bkt_us_products",
                "bkt_eu_products",
                "bkt_asia_products"
              ],
              [
                "bkt_staging_data",
                "bkt_production_data"
              ]
            ]
          },
          "collection_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Collection Id",
            "description": "Collection ID when type='collection'. REQUIRED when type='collection'. NOT ALLOWED when type='bucket'. The collection will process documents from this upstream collection. The upstream collection's output_schema becomes this collection's input_schema. This enables decomposition trees (multi-stage pipelines). Example: Process frames collection \u2192 create scenes collection.",
            "examples": [
              "col_video_frames",
              "col_book_chapters",
              "col_product_images"
            ]
          }
        },
        "type": "object",
        "required": [
          "type"
        ],
        "title": "SourceConfig",
        "description": "Configuration for collection source (bucket(s) or collection).\n\nCollections can process data from two types of sources:\n\n1. **Bucket Source**: Process raw objects from one or more buckets (first-stage processing)\n   - Use this to create your initial collections from uploaded data\n   - Can specify multiple buckets to consolidate data from different sources\n   - All buckets must have compatible schemas (validated at creation)\n   - Example: Videos from multiple regions \u2192 Frame extraction collection\n\n2. **Collection Source**: Process documents from another collection (decomposition trees)\n   - Use this to create multi-stage processing pipelines\n   - Example: Frames collection \u2192 Scene detection collection\n\nMulti-Bucket Requirements:\n- All buckets must have compatible schemas (same fields, types, and required status)\n- Schema compatibility is validated when the collection is created\n- Documents track which specific bucket they came from via root_bucket_id\n- Useful for consolidating data from multiple regions, teams, or environments\n\nThe source determines:\n- What data the feature extractor receives as input\n- The input_schema available for input_mappings and field_passthrough\n- The lineage tracking in output documents\n\nExamples:\n    Single bucket: {\"type\": \"bucket\", \"bucket_ids\": [\"bkt_products\"]}\n    Multi-bucket: {\"type\": \"bucket\", \"bucket_ids\": [\"bkt_us\", \"bkt_eu\", \"bkt_asia\"]}\n    Collection: {\"type\": \"collection\", \"collection_id\": \"col_frames\"}",
        "examples": [
          {
            "bucket_ids": [
              "bkt_marketing_videos"
            ],
            "description": "Single bucket source",
            "type": "bucket"
          },
          {
            "bucket_ids": [
              "bkt_us_products",
              "bkt_eu_products",
              "bkt_asia_products"
            ],
            "description": "Multi-bucket source (region consolidation)",
            "type": "bucket"
          },
          {
            "bucket_ids": [
              "bkt_marketing_assets",
              "bkt_sales_assets",
              "bkt_support_assets"
            ],
            "description": "Multi-bucket source (team consolidation)",
            "type": "bucket"
          },
          {
            "collection_id": "col_video_frames",
            "description": "Collection source (decomposition tree)",
            "type": "collection"
          }
        ]
      },
      "SourceDetails": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/SourceType",
            "description": "Immediate origin type from which this entity was derived."
          },
          "source_id": {
            "type": "string",
            "title": "Source Id",
            "description": "Identifier of the immediate source entity (e.g., bucket_id, collection_id, taxonomy_id)."
          }
        },
        "type": "object",
        "required": [
          "type",
          "source_id"
        ],
        "title": "SourceDetails",
        "description": "Generic source details for any Qdrant point/document.\n\nKeep this intentionally minimal so specialized models (e.g., DocumentSourceDetails)\ncan extend it with domain-specific fields."
      },
      "SourceType": {
        "type": "string",
        "enum": [
          "bucket",
          "collection",
          "taxonomy",
          "cluster"
        ],
        "title": "SourceType",
        "description": "Generic source types for any Qdrant point/document."
      },
      "SparseVector": {
        "properties": {
          "indices": {
            "items": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                }
              ]
            },
            "type": "array",
            "title": "Indices",
            "description": "Indices of non-zero elements"
          },
          "values": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Values",
            "description": "Values of non-zero elements"
          }
        },
        "type": "object",
        "required": [
          "indices",
          "values"
        ],
        "title": "SparseVector",
        "description": "Sparse vector representation with indices and values.\n\nOnly non-zero elements are stored for efficiency.\n\nExample:\n```json\n{\n    \"indices\": [0, 2, 4],\n    \"values\": [0.1, 0.3, 0.5]\n}\n```"
      },
      "SpectralParams": {
        "properties": {
          "n_clusters": {
            "type": "integer",
            "minimum": 2.0,
            "title": "N Clusters",
            "description": "Number of clusters to form",
            "default": 8
          },
          "eigen_solver": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Eigen Solver",
            "description": "The eigenvalue decomposition strategy ('arpack', 'lobpcg', 'amg', or None)"
          },
          "n_components": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "N Components",
            "description": "Number of eigenvectors to use for spectral embedding"
          },
          "random_state": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Random State",
            "description": "Random seed for reproducibility",
            "default": 42
          },
          "n_init": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Init",
            "description": "Number of times k-means will run with different centroid seeds",
            "default": 10
          },
          "gamma": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Gamma",
            "description": "Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels",
            "default": 1.0
          },
          "affinity": {
            "type": "string",
            "title": "Affinity",
            "description": "How to construct the affinity matrix ('nearest_neighbors', 'rbf', 'precomputed', 'precomputed_nearest_neighbors')",
            "default": "rbf"
          },
          "n_neighbors": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Neighbors",
            "description": "Number of neighbors to use when constructing the affinity matrix using nearest neighbors",
            "default": 10
          },
          "eigen_tol": {
            "type": "number",
            "minimum": 0.0,
            "title": "Eigen Tol",
            "description": "Stopping criterion for eigendecomposition",
            "default": 0.0
          },
          "assign_labels": {
            "type": "string",
            "title": "Assign Labels",
            "description": "Strategy to assign labels in the embedding space ('kmeans' or 'discretize')",
            "default": "kmeans"
          },
          "degree": {
            "type": "number",
            "title": "Degree",
            "description": "Degree of the polynomial kernel. Ignored by other kernels",
            "default": 3
          },
          "coef0": {
            "type": "number",
            "title": "Coef0",
            "description": "Zero coefficient for polynomial and sigmoid kernels",
            "default": 1
          },
          "kernel_params": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Kernel Params",
            "description": "Parameters for the kernel function"
          },
          "n_jobs": {
            "type": "integer",
            "title": "N Jobs",
            "description": "Number of parallel jobs to run (-1 means using all processors)",
            "default": 1
          },
          "verbose": {
            "type": "boolean",
            "title": "Verbose",
            "description": "Verbosity mode",
            "default": false
          }
        },
        "type": "object",
        "title": "SpectralParams",
        "description": "Parameters for Spectral clustering algorithm."
      },
      "StageBreakdownResponse": {
        "properties": {
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "Retriever identifier"
          },
          "stages": {
            "items": {
              "$ref": "#/components/schemas/StagePerformanceMetrics"
            },
            "type": "array",
            "title": "Stages",
            "description": "Stage metrics"
          },
          "total_latency_ms": {
            "type": "number",
            "title": "Total Latency Ms",
            "description": "Total pipeline latency"
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "stages",
          "total_latency_ms"
        ],
        "title": "StageBreakdownResponse",
        "description": "Stage breakdown response.",
        "examples": [
          {
            "retriever_id": "ret_abc123",
            "stages": [
              {
                "avg_documents_in": 0,
                "avg_documents_out": 100,
                "avg_latency_ms": 45.3,
                "execution_count": 1234,
                "p95_latency_ms": 89.2,
                "stage_name": "knn_search",
                "stage_type": "vector_search"
              },
              {
                "avg_documents_in": 100,
                "avg_documents_out": 10,
                "avg_latency_ms": 102.5,
                "execution_count": 1234,
                "p95_latency_ms": 198.7,
                "stage_name": "rerank",
                "stage_type": "reranking"
              }
            ],
            "total_latency_ms": 147.8
          }
        ]
      },
      "StageInstanceConfig": {
        "properties": {
          "stage_name": {
            "type": "string",
            "title": "Stage Name"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "parameters": {
            "additionalProperties": true,
            "type": "object",
            "title": "Parameters"
          },
          "pre_filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filters to apply to the documents *before* this stage is executed.These filters are combined with any global retriever filters."
          },
          "post_filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Input"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filters to apply to the documents *after* this stage is executed.These filters are applied to the results of this stage before passing to the next."
          },
          "stats": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/StagePerformance"
              },
              {
                "type": "null"
              }
            ],
            "description": "Performance statistics for this stage"
          }
        },
        "type": "object",
        "required": [
          "stage_name",
          "version",
          "parameters"
        ],
        "title": "StageInstanceConfig",
        "description": "User-provided configuration for a stage instance in a retriever pipeline.\n\nThis model is used when creating a retriever to define the specific\nparameters for each stage."
      },
      "StagePerformance": {
        "properties": {
          "avg_execution_ms": {
            "type": "number",
            "title": "Avg Execution Ms",
            "description": "Average execution time in milliseconds",
            "default": 0.0
          },
          "execution_count": {
            "type": "integer",
            "title": "Execution Count",
            "description": "Number of times executed",
            "default": 0
          },
          "error_count": {
            "type": "integer",
            "title": "Error Count",
            "description": "Number of errors encountered",
            "default": 0
          },
          "last_executed_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Executed At",
            "description": "Last time this stage was executed"
          }
        },
        "type": "object",
        "title": "StagePerformance",
        "description": "Performance statistics for a retriever stage."
      },
      "StagePerformanceMetrics": {
        "properties": {
          "stage_name": {
            "type": "string",
            "title": "Stage Name",
            "description": "Name of the stage"
          },
          "stage_type": {
            "type": "string",
            "title": "Stage Type",
            "description": "Type of the stage"
          },
          "execution_count": {
            "type": "integer",
            "title": "Execution Count",
            "description": "Number of executions"
          },
          "avg_latency_ms": {
            "type": "number",
            "title": "Avg Latency Ms",
            "description": "Average latency"
          },
          "p95_latency_ms": {
            "type": "number",
            "title": "P95 Latency Ms",
            "description": "P95 latency"
          },
          "avg_documents_in": {
            "type": "number",
            "title": "Avg Documents In",
            "description": "Average documents input"
          },
          "avg_documents_out": {
            "type": "number",
            "title": "Avg Documents Out",
            "description": "Average documents output"
          }
        },
        "type": "object",
        "required": [
          "stage_name",
          "stage_type",
          "execution_count",
          "avg_latency_ms",
          "p95_latency_ms",
          "avg_documents_in",
          "avg_documents_out"
        ],
        "title": "StagePerformanceMetrics",
        "description": "Stage-level performance metrics."
      },
      "StageStatistics": {
        "properties": {
          "input_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Input Count",
            "description": "Number of documents received by the stage (REQUIRED)."
          },
          "output_count": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Output Count",
            "description": "Number of documents emitted by the stage (REQUIRED)."
          },
          "duration_ms": {
            "type": "number",
            "minimum": 0.0,
            "title": "Duration Ms",
            "description": "Wall-clock duration in milliseconds (REQUIRED)."
          },
          "efficiency": {
            "type": "number",
            "minimum": 0.0,
            "title": "Efficiency",
            "description": "Output/Input ratio. 0 when input_count is 0 (REQUIRED)."
          },
          "cache_hit": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cache Hit",
            "description": "Indicates whether the result originated from stage cache (OPTIONAL)."
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Stage-specific error message if execution failed but pipeline continued (OPTIONAL)."
          },
          "llm_calls": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Llm Calls",
            "description": "Number of LLM invocations performed by the stage (OPTIONAL)."
          },
          "tokens_used": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Tokens Used",
            "description": "Total tokens consumed by the stage (OPTIONAL, only for LLM stages)."
          }
        },
        "type": "object",
        "required": [
          "input_count",
          "output_count",
          "duration_ms",
          "efficiency"
        ],
        "title": "StageStatistics",
        "description": "Execution metrics for a single stage in a pipeline run.",
        "examples": [
          {
            "cache_hit": false,
            "duration_ms": 123.4,
            "efficiency": 0.05,
            "input_count": 5000,
            "output_count": 250
          }
        ]
      },
      "StageType": {
        "type": "string",
        "enum": [
          "filter",
          "sort",
          "reduce",
          "apply"
        ],
        "title": "StageType",
        "description": "Categorisation of stage behaviour within a linear retrieval pipeline.\n\nThese functional categories describe how stages transform the document stream:\n\n- FILTER: N \u2192 \u2264N documents (subset, same schema)\n- SORT: N \u2192 N documents (same docs, different order, same schema)\n- REDUCE: N \u2192 1 document (aggregation, new schema)\n- APPLY: N \u2192 N or N*M documents (enrichment/expansion, expanded/new schema)"
      },
      "StorageConnectionCreateRequest": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name"
          },
          "provider_type": {
            "$ref": "#/components/schemas/StorageProvider"
          },
          "provider_config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Provider Config"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 500
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata"
          },
          "test_before_save": {
            "type": "boolean",
            "title": "Test Before Save",
            "description": "Validate credentials before persisting",
            "default": true
          }
        },
        "type": "object",
        "required": [
          "name",
          "provider_type",
          "provider_config"
        ],
        "title": "StorageConnectionCreateRequest",
        "description": "Request payload for creating a storage connection."
      },
      "StorageConnectionListResponse": {
        "properties": {
          "connections": {
            "items": {
              "$ref": "#/components/schemas/StorageConnectionModel"
            },
            "type": "array",
            "title": "Connections"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count"
          }
        },
        "type": "object",
        "required": [
          "connections",
          "total_count"
        ],
        "title": "StorageConnectionListResponse",
        "description": "Response envelope for list endpoint."
      },
      "StorageConnectionModel": {
        "properties": {
          "connection_id": {
            "type": "string",
            "pattern": "^conn_[a-zA-Z0-9]{14,16}$",
            "title": "Connection Id",
            "description": "Unique identifier for the storage connection. Auto-generated with 'conn_' prefix followed by secure random token. Format: conn_{15-character alphanumeric}. Used for API operations and audit trails.",
            "examples": [
              "conn_abc123def456ghi",
              "conn_xyz789uvw012qrs"
            ]
          },
          "internal_id": {
            "type": "string",
            "pattern": "^int_[a-zA-Z0-9]{24}$",
            "title": "Internal Id",
            "description": "REQUIRED. Organization internal identifier for multi-tenancy scoping. All connection operations are scoped to this organization. Format: int_{24-character secure token}.",
            "examples": [
              "int_org123abc456def789xyz012"
            ]
          },
          "provider_type": {
            "$ref": "#/components/schemas/StorageProvider",
            "description": "REQUIRED. Storage provider implementation to use. Determines which client adapter is loaded for sync operations. Must be one of: google_drive, s3. See StorageProvider enum for full list."
          },
          "provider_config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/GoogleDriveConfig"
              },
              {
                "$ref": "#/components/schemas/S3Config"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "title": "Provider Config",
            "description": "REQUIRED. Provider-specific configuration payload including credentials. Type depends on provider_type (GoogleDriveConfig, S3Config, etc.). SECURITY: Sensitive credential fields are encrypted at rest via MongoDB client-side field level encryption (CSFLE). Credentials never appear in API responses or logs. See provider_configs.py for detailed schemas."
          },
          "name": {
            "type": "string",
            "maxLength": 100,
            "minLength": 1,
            "title": "Name",
            "description": "REQUIRED. Human-readable connection name for identification. Displayed in dashboards, sync logs, and API responses. Must be unique within the organization for clarity. Format: 1-100 characters, descriptive of the connection's purpose.",
            "examples": [
              "Marketing Google Drive",
              "Production S3 Bucket",
              "Customer Assets Archive"
            ]
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 500
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "NOT REQUIRED. Optional description explaining the connection's purpose and scope. Helpful for team collaboration and documentation. Format: Up to 500 characters.",
            "examples": [
              "Shared drive for marketing team assets and campaign materials",
              "Production S3 bucket containing customer-uploaded videos"
            ]
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Operational status of the connection. ACTIVE: Connection is healthy and ready for use in sync operations. SUSPENDED: Temporarily disabled by user, credentials preserved but sync paused. FAILED: Health checks failing, credentials may be invalid or expired. ARCHIVED: Permanently retired, cannot be reactivated. Status transitions automatically based on health checks and user actions.",
            "default": "ACTIVE"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Quick boolean flag for filtering active connections in queries. True when status is ACTIVE, False for SUSPENDED/FAILED/ARCHIVED. Maintained automatically when status changes. Use for efficient filtering: db.connections.find({'is_active': True})",
            "default": true
          },
          "last_used_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Used At",
            "description": "NOT REQUIRED. UTC timestamp of the most recent successful sync operation. Updated automatically after each successful file sync/list operation. None if connection has never been used. Useful for identifying stale connections and usage analytics."
          },
          "last_error": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 1000
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Error",
            "description": "NOT REQUIRED. Most recent error message from failed health check or sync. Populated when authentication fails, network errors occur, or permissions denied. None when connection is healthy. Format: Error message truncated to 1000 characters. Used for diagnostics and troubleshooting.",
            "examples": [
              "Authentication failed: Invalid credentials",
              "Permission denied: Unable to access shared drive",
              "Network timeout: Failed to connect to storage.googleapis.com"
            ]
          },
          "consecutive_failures": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Consecutive Failures",
            "description": "Counter tracking consecutive failed health checks or sync attempts. Incremented on each failure, reset to 0 on success. Used to implement automatic connection suspension. Auto-suspend after 5 consecutive failures to prevent account lockout. Range: 0 to infinity (typically 0-10).",
            "default": 0
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "UTC timestamp when the connection was created. Auto-generated using shared.utilities.helpers.current_time(). Immutable after creation. Format: ISO 8601 datetime."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "UTC timestamp of the most recent update to the connection. Updated automatically on any field modification. Tracks configuration changes, status updates, and credential refreshes. Format: ISO 8601 datetime."
          },
          "created_by_user_id": {
            "type": "string",
            "pattern": "^usr_[a-zA-Z0-9]{15}$",
            "title": "Created By User Id",
            "description": "REQUIRED. User identifier of the user who created this connection. Used for audit trails and permission checks. Format: usr_{15-character alphanumeric}. Immutable after creation.",
            "examples": [
              "usr_abc123def456ghi",
              "usr_admin123abc456"
            ]
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Arbitrary key-value metadata provided by the user. Useful for tagging, categorization, and custom annotations. NOT REQUIRED - defaults to empty dictionary. Common uses: team tags, cost center codes, project identifiers.",
            "examples": [
              {
                "cost_center": "CC-1234",
                "team": "marketing"
              },
              {
                "environment": "production",
                "project": "q4-campaign"
              },
              {
                "tags": [
                  "customer-facing",
                  "high-priority"
                ]
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "internal_id",
          "provider_type",
          "provider_config",
          "name",
          "created_by_user_id"
        ],
        "title": "StorageConnectionModel",
        "description": "Canonical representation of an external storage provider connection.\n\nStorage connections enable Mixpeek to access external cloud storage providers\n(Google Drive, S3, etc.) for automated file ingestion and synchronization.\nEach connection represents a configured integration with credentials, health\nmonitoring, and usage tracking.\n\nLifecycle States:\n    - ACTIVE: Connection is healthy and ready for sync operations\n    - SUSPENDED: Temporarily disabled by user (credentials preserved)\n    - FAILED: Health checks failing (may need credential refresh)\n    - ARCHIVED: Permanently retired (cannot be reactivated)\n\nSecurity:\n    - Sensitive credential fields are encrypted at rest using MongoDB\n      client-side field level encryption (CSFLE)\n    - Credentials never appear in API responses or logs\n    - Failed authentication attempts are logged in last_error\n    - Consecutive failures trigger automatic suspension\n\nUse Cases:\n    - Connect to team Google Drive for document ingestion\n    - Sync files from customer S3 buckets\n    - Monitor and process uploaded media files\n    - Schedule periodic sync operations\n\nHealth Monitoring:\n    - Automatic health checks validate connectivity and credentials\n    - consecutive_failures tracks authentication/network issues\n    - Auto-disable after 5 consecutive failures to prevent lockout\n    - last_error stores diagnostic information for debugging",
        "examples": [
          {
            "connection_id": "conn_abc123def456ghi",
            "created_by_user_id": "usr_admin123abc456",
            "description": "Team drive for marketing assets",
            "internal_id": "int_org123",
            "is_active": true,
            "metadata": {
              "team": "marketing"
            },
            "name": "Marketing Google Drive",
            "provider_config": {
              "credentials": {
                "client_email": "sync@project.iam.gserviceaccount.com",
                "type": "service_account"
              },
              "provider_type": "google_drive",
              "shared_drive_id": "0AH-Xabc123"
            },
            "provider_type": "google_drive",
            "status": "active"
          },
          {
            "connection_id": "conn_xyz789uvw012qrs",
            "created_by_user_id": "usr_admin123abc456",
            "internal_id": "int_org123",
            "is_active": true,
            "name": "Production S3 Bucket",
            "provider_config": {
              "credentials": {
                "access_key_id": "AKIA..."
              },
              "provider_type": "s3",
              "region": "us-east-1"
            },
            "provider_type": "s3",
            "status": "active"
          }
        ]
      },
      "StorageConnectionTestResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success"
          },
          "message": {
            "type": "string",
            "title": "Message"
          },
          "details": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Details"
          }
        },
        "type": "object",
        "required": [
          "success",
          "message"
        ],
        "title": "StorageConnectionTestResponse",
        "description": "Result payload for test endpoint."
      },
      "StorageConnectionUpdateRequest": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 100,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 500
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata"
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TaskStatusEnum"
              },
              {
                "type": "null"
              }
            ]
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active"
          },
          "provider_config": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Provider Config"
          }
        },
        "type": "object",
        "title": "StorageConnectionUpdateRequest",
        "description": "Patch payload for storage connections."
      },
      "StorageProvider": {
        "type": "string",
        "enum": [
          "google_drive",
          "s3"
        ],
        "title": "StorageProvider",
        "description": "Supported external storage providers for ingestion and sync.\n\nMixpeek can connect to external storage providers to automatically\ningest objects and keep them synchronized with your namespaces.\n\nProviders:\n    GOOGLE_DRIVE: Google Drive and Google Workspace shared drives.\n        - Authentication: Service account or OAuth2\n        - Features: Shared drive support, real-time sync, metadata preservation\n        - Use cases: Marketing assets, team documents, knowledge bases\n        - Limitations: Rate limits apply (10,000 requests/100 seconds per user)\n\n    S3: Amazon S3 and S3-compatible storage (MinIO, DigitalOcean Spaces, etc).\n        - Authentication: Access keys or IAM role assumption\n        - Features: Bucket notifications, prefix filtering, versioning support\n        - Use cases: Data lakes, video archives, ML datasets, backups\n        - Limitations: IAM role assumption preferred over access keys\n\nConnection Requirements:\n    - Valid credentials with read access to target files/buckets\n    - Network connectivity from Mixpeek infrastructure\n    - Appropriate IAM policies or share permissions configured\n\nExamples:\n    - Use GOOGLE_DRIVE for syncing team marketing materials\n    - Use S3 for ingesting video archives from data lakes\n    - Use S3 with IAM role for secure production deployments"
      },
      "StorageStatistics": {
        "properties": {
          "total_size_bytes": {
            "type": "integer",
            "title": "Total Size Bytes",
            "description": "Total size of all objects/blobs in the bucket in bytes",
            "default": 0
          },
          "avg_size_bytes": {
            "type": "integer",
            "title": "Avg Size Bytes",
            "description": "Average object size in bytes",
            "default": 0
          },
          "max_size_bytes": {
            "type": "integer",
            "title": "Max Size Bytes",
            "description": "Size of the largest object in bytes",
            "default": 0
          },
          "min_size_bytes": {
            "type": "integer",
            "title": "Min Size Bytes",
            "description": "Size of the smallest object in bytes",
            "default": 0
          }
        },
        "type": "object",
        "title": "StorageStatistics",
        "description": "Statistics about object storage in a bucket."
      },
      "SubmitBatchRequest": {
        "properties": {
          "include_processing_history": {
            "type": "boolean",
            "title": "Include Processing History",
            "description": "OPTIONAL (defaults to True). Controls whether processing operations are tracked in document internal_metadata.processing_history. When True: Each enrichment operation (taxonomy application, clustering, etc.) adds an audit trail entry. When False: Documents are enriched without processing history tracking, resulting in cleaner metadata. Use True for: Debugging, audit requirements, lineage tracking, understanding document transformations. Use False for: Production workloads where metadata size matters, simplified document structure. Processing history entries include: operation type, timestamp, and IDs of applied resources (taxonomies, clusters, etc.).",
            "default": true,
            "examples": [
              true,
              false
            ]
          }
        },
        "type": "object",
        "title": "SubmitBatchRequest",
        "description": "Request model for submitting a batch for processing.\n\nThis model allows configuration of processing behavior for the batch,\nsuch as whether to track processing history in document metadata.\n\nUse Cases:\n    - Submit batch with full audit trail (include_processing_history=True)\n    - Submit batch without processing history for cleaner metadata (include_processing_history=False)\n    - Default behavior includes processing history for debugging and lineage tracking\n\nRequirements:\n    - include_processing_history: OPTIONAL, defaults to True",
        "examples": [
          {
            "description": "Submit batch with processing history (default)",
            "include_processing_history": true
          },
          {
            "description": "Submit batch without processing history",
            "include_processing_history": false
          },
          {
            "description": "Submit batch with default settings (includes processing history)"
          }
        ]
      },
      "SyncConfigurationModel": {
        "properties": {
          "sync_config_id": {
            "type": "string",
            "pattern": "^sync_[a-zA-Z0-9]{14,16}$",
            "title": "Sync Config Id",
            "description": "Unique identifier for the sync configuration."
          },
          "bucket_id": {
            "type": "string",
            "title": "Bucket Id",
            "description": "Target bucket identifier (e.g. 'bkt_marketing_assets')."
          },
          "connection_id": {
            "type": "string",
            "title": "Connection Id",
            "description": "Storage connection identifier (e.g. 'conn_abc123')."
          },
          "internal_id": {
            "type": "string",
            "title": "Internal Id",
            "description": "Organization internal identifier (multi-tenancy scope)."
          },
          "namespace_id": {
            "type": "string",
            "title": "Namespace Id",
            "description": "Namespace identifier owning the bucket."
          },
          "source_path": {
            "type": "string",
            "title": "Source Path",
            "description": "Source path in the external storage provider."
          },
          "file_filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FileFilters"
              },
              {
                "type": "null"
              }
            ],
            "description": "Optional filter rules limiting which files are synced."
          },
          "sync_mode": {
            "$ref": "#/components/schemas/SyncMode",
            "description": "Sync mode controlling lifecycle (initial_only or continuous).",
            "default": "continuous"
          },
          "polling_interval_seconds": {
            "type": "integer",
            "maximum": 900.0,
            "minimum": 30.0,
            "title": "Polling Interval Seconds",
            "description": "Polling interval in seconds (continuous mode).",
            "default": 300
          },
          "batch_size": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Batch Size",
            "description": "Number of files processed per sync batch.",
            "default": 50
          },
          "create_object_on_confirm": {
            "type": "boolean",
            "title": "Create Object On Confirm",
            "description": "Whether objects should be created immediately after confirmation.",
            "default": true
          },
          "skip_duplicates": {
            "type": "boolean",
            "title": "Skip Duplicates",
            "description": "Skip files whose hashes already exist in the bucket.",
            "default": true
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Current lifecycle status for the sync configuration. PENDING: Not yet started. ACTIVE: Currently running/polling. SUSPENDED: Temporarily paused. COMPLETED: Initial sync completed (for initial_only mode). FAILED: Sync encountered errors.",
            "default": "PENDING"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Convenience flag used for filtering active syncs.",
            "default": true
          },
          "total_files_discovered": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Files Discovered",
            "default": 0
          },
          "total_files_synced": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Files Synced",
            "default": 0
          },
          "total_files_failed": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Files Failed",
            "default": 0
          },
          "total_bytes_synced": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Total Bytes Synced",
            "default": 0
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At"
          },
          "last_sync_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Sync At"
          },
          "next_sync_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Sync At"
          },
          "created_by_user_id": {
            "type": "string",
            "title": "Created By User Id",
            "description": "User identifier that created the sync configuration."
          },
          "last_error": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 1000
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Error",
            "description": "Most recent error message if sync attempts failed."
          },
          "consecutive_failures": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Consecutive Failures",
            "default": 0
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Arbitrary metadata supplied by the user."
          }
        },
        "type": "object",
        "required": [
          "bucket_id",
          "connection_id",
          "internal_id",
          "namespace_id",
          "source_path",
          "created_by_user_id"
        ],
        "title": "SyncConfigurationModel",
        "description": "Bucket-scoped configuration describing how to sync external files."
      },
      "SyncCreateRequest": {
        "properties": {
          "connection_id": {
            "type": "string",
            "title": "Connection Id",
            "description": "Storage connection identifier"
          },
          "source_path": {
            "type": "string",
            "title": "Source Path",
            "description": "Source path within the storage provider"
          },
          "sync_mode": {
            "$ref": "#/components/schemas/SyncMode",
            "default": "continuous"
          },
          "file_filters": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Filters"
          },
          "polling_interval_seconds": {
            "type": "integer",
            "maximum": 900.0,
            "minimum": 30.0,
            "title": "Polling Interval Seconds",
            "default": 300
          },
          "batch_size": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Batch Size",
            "default": 50
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata"
          }
        },
        "type": "object",
        "required": [
          "connection_id",
          "source_path"
        ],
        "title": "SyncCreateRequest",
        "description": "Request payload for creating a bucket sync configuration."
      },
      "SyncListResponse": {
        "properties": {
          "syncs": {
            "items": {
              "$ref": "#/components/schemas/SyncConfigurationModel"
            },
            "type": "array",
            "title": "Syncs"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count"
          }
        },
        "type": "object",
        "required": [
          "syncs",
          "total_count"
        ],
        "title": "SyncListResponse",
        "description": "Envelope for listing sync configurations."
      },
      "SyncMode": {
        "type": "string",
        "enum": [
          "initial_only",
          "continuous"
        ],
        "title": "SyncMode",
        "description": "Supported sync modes for external storage ingestion."
      },
      "SyncUpdateRequest": {
        "properties": {
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata"
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TaskStatusEnum"
              },
              {
                "type": "null"
              }
            ]
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active"
          },
          "polling_interval_seconds": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 900.0,
                "minimum": 30.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Polling Interval Seconds"
          },
          "batch_size": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 100.0,
                "minimum": 1.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Batch Size"
          }
        },
        "type": "object",
        "title": "SyncUpdateRequest",
        "description": "Patch payload for sync configuration updates."
      },
      "TSNEParams": {
        "properties": {
          "method": {
            "type": "string",
            "const": "tsne",
            "title": "Method",
            "default": "tsne"
          },
          "n_components": {
            "type": "integer",
            "maximum": 256.0,
            "minimum": 2.0,
            "title": "N Components",
            "default": 2
          },
          "random_state": {
            "type": "integer",
            "title": "Random State",
            "default": 42
          },
          "perplexity": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Perplexity",
            "default": 30.0
          },
          "learning_rate": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Learning Rate",
            "default": 200.0
          }
        },
        "type": "object",
        "title": "TSNEParams"
      },
      "TaskResponse": {
        "properties": {
          "task_id": {
            "type": "string",
            "title": "Task Id",
            "description": "Unique identifier for the task. REQUIRED. Used to poll task status via GET /v1/tasks/{task_id}. This ID is also stored on parent resources (batches, clusters, etc.) for cross-referencing. Format: UUID v4 or custom string identifier.",
            "examples": [
              "task_abc123def456",
              "550e8400-e29b-41d4-a716-446655440000"
            ]
          },
          "task_type": {
            "$ref": "#/components/schemas/TaskType",
            "description": "Type of operation this task represents. REQUIRED. Identifies the specific async operation being performed. Used for filtering and categorizing tasks. Common types: api_buckets_batches_process, engine_cluster_build, api_taxonomies_execute. See TaskType enum for complete list of supported operations.",
            "examples": [
              "api_buckets_batches_process",
              "engine_cluster_build",
              "api_taxonomies_execute"
            ]
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Current status of the task. REQUIRED. Indicates the current state of the async operation. Terminal statuses (COMPLETED, FAILED, CANCELED) indicate the task has finished and will not change. Active statuses (PENDING, IN_PROGRESS, PROCESSING) indicate the task is still running and should be polled. Use this field to determine when to stop polling.",
            "examples": [
              "PENDING",
              "PROCESSING",
              "COMPLETED",
              "FAILED"
            ]
          },
          "inputs": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "additionalProperties": true,
                      "type": "object"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inputs",
            "description": "Input parameters or data used to start the task. OPTIONAL. May include IDs, configuration objects, or file references. Useful for debugging and understanding what data the task processed. Format: List of strings (IDs) or objects (configuration). Example: ['batch_id_123'] or [{'bucket_id': 'bkt_abc', 'config': {...}}]",
            "examples": [
              [
                "batch_xyz789"
              ],
              [
                "obj_123",
                "obj_456",
                "obj_789"
              ],
              [
                {
                  "bucket_id": "bkt_abc",
                  "collection_ids": [
                    "col_1",
                    "col_2"
                  ]
                }
              ]
            ]
          },
          "outputs": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "additionalProperties": true,
                      "type": "object"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Outputs",
            "description": "Output results produced by the task. OPTIONAL. Populated when task completes successfully. May include processed file IDs, result metrics, or status summaries. Check this field after task reaches COMPLETED status to get results. Format: List of strings (output IDs) or objects (result data).",
            "examples": [
              [
                "document_123",
                "document_456"
              ],
              [
                {
                  "failed_count": 2,
                  "processed_count": 100,
                  "success_rate": 0.98
                }
              ],
              [
                {
                  "cluster_id": "cl_abc123",
                  "num_clusters": 5
                }
              ]
            ]
          },
          "additional_data": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Additional Data",
            "description": "Additional metadata and context for the task. OPTIONAL. Contains job IDs, error details, progress info, and other task-specific metadata. Common fields: - 'error': Error message if task failed - 'job_id': Ray job ID for engine tasks - 'bucket_id', 'batch_id', 'cluster_id': Parent resource IDs - 'from_mongodb': True if retrieved from MongoDB fallback (not Redis) Use this field for debugging and detailed task information.",
            "examples": [
              {
                "batch_id": "batch_xyz789",
                "bucket_id": "bkt_products",
                "job_id": "ray_job_123"
              },
              {
                "error": "Failed to process object: Invalid file format",
                "job_id": "123"
              },
              {
                "cluster_id": "cl_abc",
                "collection_ids": [
                  "col_1"
                ],
                "from_mongodb": true
              }
            ]
          },
          "error_message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error Message",
            "description": "Flattened error message for convenient error handling. OPTIONAL. Automatically populated from additional_data['error'] when the task has FAILED status. This is a convenience field - the full error details are always available in additional_data['error']. Use this field for displaying errors to users or logging. Will be None if task has not failed or if no error details are available.",
            "examples": [
              "Failed to process batch: Object not found",
              "Invalid file format: Expected PDF, got PNG",
              "Clustering failed: Insufficient data points",
              null
            ]
          }
        },
        "type": "object",
        "required": [
          "task_id",
          "task_type",
          "status"
        ],
        "title": "TaskResponse",
        "description": "Task response model returned by the API.\n\nExtends TaskModel with additional convenience fields for API responses.\nThis is the model returned when you GET /v1/tasks/{task_id}.\n\nAdditional Fields:\n    error_message: Convenience field that surfaces errors from additional_data\n                  for easier error handling in client code.\n\nInheritance:\n    Inherits all fields and documentation from TaskModel, including:\n    - task_id: Unique identifier\n    - task_type: Operation type\n    - status: Current status\n    - inputs: Input parameters\n    - outputs: Output results\n    - additional_data: Metadata and context\n\nStorage Architecture:\n    Same as TaskModel - stored in Redis (24hr TTL) with MongoDB fallback.\n\nUsage:\n    This model is automatically returned by task API endpoints. You don't\n    need to construct it manually - just call GET /v1/tasks/{task_id}.\n\nError Handling:\n    Check the error_message field for a user-friendly error string, or\n    additional_data['error'] for the full error details.\n\nExample Response:\n    {\n        \"task_id\": \"task_abc123\",\n        \"task_type\": \"api_buckets_batches_process\",\n        \"status\": \"FAILED\",\n        \"inputs\": [\"batch_xyz\"],\n        \"outputs\": null,\n        \"additional_data\": {\n            \"error\": \"Failed to process batch: Object not found\",\n            \"batch_id\": \"batch_xyz\"\n        },\n        \"error_message\": \"Failed to process batch: Object not found\"\n    }",
        "examples": [
          {
            "additional_data": {
              "batch_id": "batch_xyz789",
              "bucket_id": "bkt_products",
              "job_id": "ray_job_123"
            },
            "description": "Batch processing task in progress",
            "inputs": [
              "batch_xyz789"
            ],
            "status": "PROCESSING",
            "task_id": "task_abc123def456",
            "task_type": "api_buckets_batches_process"
          },
          {
            "additional_data": {
              "cluster_id": "cl_abc123",
              "job_id": "ray_job_456"
            },
            "description": "Completed clustering task with results",
            "inputs": [
              {
                "collection_ids": [
                  "col_products"
                ],
                "config": {
                  "algorithm": "kmeans",
                  "k": 5
                }
              }
            ],
            "outputs": [
              {
                "cluster_id": "cl_abc123",
                "num_clusters": 5,
                "silhouette_score": 0.78
              }
            ],
            "status": "COMPLETED",
            "task_id": "task_cluster_789",
            "task_type": "engine_cluster_build"
          },
          {
            "additional_data": {
              "bucket_id": "bkt_test",
              "error": "Invalid file format: Expected PDF, got PNG",
              "object_id": "obj_123"
            },
            "description": "Failed object creation task with error",
            "inputs": [
              {
                "bucket_id": "bkt_test",
                "object_id": "obj_123"
              }
            ],
            "status": "FAILED",
            "task_id": "task_failed_123",
            "task_type": "api_buckets_objects_create"
          },
          {
            "additional_data": {
              "batch_id": "batch_old_123",
              "from_mongodb": true,
              "note": "Retrieved from persistent storage after 24hr Redis expiry"
            },
            "description": "Task retrieved from MongoDB fallback (Redis expired)",
            "inputs": [
              "batch_old_123"
            ],
            "outputs": [
              "Processed 500 objects"
            ],
            "status": "COMPLETED",
            "task_id": "task_old_789",
            "task_type": "api_buckets_batches_process"
          }
        ]
      },
      "TaskStatusEnum": {
        "type": "string",
        "enum": [
          "PENDING",
          "IN_PROGRESS",
          "PROCESSING",
          "COMPLETED",
          "FAILED",
          "CANCELED",
          "UNKNOWN",
          "SKIPPED",
          "DRAFT",
          "ACTIVE",
          "ARCHIVED",
          "SUSPENDED"
        ],
        "title": "TaskStatusEnum",
        "description": "Enumeration of task statuses for tracking asynchronous operations.\n\nTask statuses indicate the current state of asynchronous operations like\nbatch processing, object ingestion, clustering, and taxonomy execution.\n\nStatus Categories:\n    Operation Statuses: Track progress of async operations\n    Lifecycle Statuses: Track entity state (buckets, collections, namespaces)\n\nValues:\n    PENDING: Task is queued but has not started processing yet\n    IN_PROGRESS: Task is currently being executed\n    PROCESSING: Task is actively processing data (similar to IN_PROGRESS)\n    COMPLETED: Task finished successfully with no errors\n    FAILED: Task encountered an error and could not complete\n    CANCELED: Task was manually canceled by a user or system\n    UNKNOWN: Task status could not be determined\n    SKIPPED: Task was intentionally skipped\n    DRAFT: Task is in draft state and not yet submitted\n\n    ACTIVE: Entity is active and operational (for buckets, collections, etc.)\n    ARCHIVED: Entity has been archived\n    SUSPENDED: Entity has been temporarily suspended\n\nTerminal Statuses:\n    COMPLETED, FAILED, CANCELED are terminal statuses. Once a task reaches\n    these states, it will not transition to another state.\n\nPolling Guidance:\n    - Poll tasks in PENDING, IN_PROGRESS, or PROCESSING states\n    - Stop polling when task reaches COMPLETED, FAILED, or CANCELED\n    - Use exponential backoff (1s \u2192 30s) when polling"
      },
      "TaskType": {
        "type": "string",
        "enum": [
          "api_namespaces_create",
          "api_buckets_objects_create",
          "api_buckets_delete",
          "api_buckets_batches_process",
          "api_buckets_batches_submit",
          "api_buckets_uploads_create",
          "api_buckets_uploads_confirm",
          "api_buckets_uploads_batch_confirm",
          "api_taxonomies_create",
          "api_taxonomies_execute",
          "api_taxonomies_materialize",
          "engine_feature_extractor_run",
          "engine_inference_run",
          "engine_object_processing",
          "engine_cluster_build",
          "thumbnail",
          "materialize"
        ],
        "title": "TaskType",
        "description": "Types of asynchronous tasks that can be performed in the system.\n\nTask types identify the specific operation being performed. This helps with\ntracking, debugging, and filtering tasks by operation type.\n\nCategories:\n    API Tasks: User-initiated operations via API endpoints\n    Engine Tasks: Background processing tasks\n    Inference Tasks: Specialized inference operations\n\nAPI Task Types:\n    API_NAMESPACES_CREATE: Creating a new namespace\n    API_BUCKETS_OBJECTS_CREATE: Creating objects in a bucket\n    API_BUCKETS_DELETE: Deleting a bucket and its contents\n    API_BUCKETS_BATCHES_PROCESS: Processing a batch of objects\n    API_BUCKETS_BATCHES_SUBMIT: Submitting a batch for processing\n    API_BUCKETS_UPLOADS_CREATE: Creating an upload session\n    API_BUCKETS_UPLOADS_CONFIRM: Confirming an upload completion\n    API_BUCKETS_UPLOADS_BATCH_CONFIRM: Confirming batch upload completion\n    API_TAXONOMIES_CREATE: Creating a new taxonomy\n    API_TAXONOMIES_EXECUTE: Executing taxonomy classification\n    API_TAXONOMIES_MATERIALIZE: Materializing taxonomy results\n\nEngine Task Types:\n    ENGINE_FEATURE_EXTRACTOR_RUN: Running feature extraction on data\n    ENGINE_INFERENCE_RUN: Running inference operations\n    ENGINE_OBJECT_PROCESSING: Processing object data\n    ENGINE_CLUSTER_BUILD: Building clusters from data\n\nInference Task Types:\n    THUMBNAIL: Generating thumbnails\n    MATERIALIZE: Materializing processed data\n\nUsage:\n    Task types are automatically assigned when tasks are created. You can\n    filter tasks by type when listing or searching for specific operations."
      },
      "TaxonomyApplicationConfig": {
        "properties": {
          "taxonomy_id": {
            "type": "string",
            "title": "Taxonomy Id",
            "description": "ID of the `TaxonomyModel` to execute."
          },
          "execution_mode": {
            "$ref": "#/components/schemas/TaxonomyExecutionMode",
            "description": "'on_demand' executes at query time; 'materialize' materialises during ingestion.",
            "default": "on_demand"
          },
          "target_collection_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Target Collection Id",
            "description": "Optional collection to persist results into when `execution_mode` is 'materialize'. If omitted, the source collection is updated in-place."
          },
          "scroll_filters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/LogicalOperator-Output"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional filters applied when scrolling the source collection before enrichment."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "taxonomy_id"
        ],
        "title": "TaxonomyApplicationConfig",
        "description": "Configuration block that attaches a taxonomy to a collection.",
        "examples": [
          {
            "execution_mode": "on_demand",
            "taxonomy_id": "tax_abc123"
          },
          {
            "execution_mode": "materialize",
            "target_collection_id": "col_enriched_v1",
            "taxonomy_id": "tax_abc123"
          }
        ]
      },
      "TaxonomyExecutionMode": {
        "type": "string",
        "enum": [
          "on_demand",
          "materialize"
        ],
        "title": "TaxonomyExecutionMode",
        "description": "How a taxonomy should be executed when attached to a collection."
      },
      "TaxonomyListStats": {
        "properties": {
          "total_taxonomies": {
            "type": "integer",
            "title": "Total Taxonomies",
            "description": "Total number of taxonomies in the result",
            "default": 0
          },
          "flat_taxonomies": {
            "type": "integer",
            "title": "Flat Taxonomies",
            "description": "Number of flat taxonomies",
            "default": 0
          },
          "hierarchical_taxonomies": {
            "type": "integer",
            "title": "Hierarchical Taxonomies",
            "description": "Number of hierarchical taxonomies",
            "default": 0
          },
          "taxonomies_with_retrievers": {
            "type": "integer",
            "title": "Taxonomies With Retrievers",
            "description": "Number of taxonomies with retriever configured",
            "default": 0
          }
        },
        "type": "object",
        "title": "TaxonomyListStats",
        "description": "Aggregate statistics for a list of taxonomies."
      },
      "TaxonomyModel": {
        "properties": {
          "taxonomy_id": {
            "type": "string",
            "title": "Taxonomy Id",
            "description": "Unique identifier for the taxonomy"
          },
          "version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Version",
            "description": "Monotonic version number of the taxonomy configuration",
            "default": 1
          },
          "taxonomy_name": {
            "type": "string",
            "title": "Taxonomy Name",
            "description": "A unique name for the taxonomy within the namespace."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Optional human-readable description."
          },
          "retriever_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Retriever Id",
            "description": "Optional taxonomy-level retriever (prefer per-layer)."
          },
          "input_mappings": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input Mappings",
            "description": "Optional taxonomy-level inputs (prefer per-layer)."
          },
          "config": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/FlatTaxonomyConfig-Input"
              },
              {
                "$ref": "#/components/schemas/HierarchicalTaxonomyConfig-Input"
              }
            ],
            "title": "Config",
            "description": "Configuration specific to the taxonomy type.",
            "discriminator": {
              "propertyName": "taxonomy_type",
              "mapping": {
                "flat": "#/components/schemas/FlatTaxonomyConfig-Input",
                "hierarchical": "#/components/schemas/HierarchicalTaxonomyConfig-Input"
              }
            }
          },
          "ready": {
            "type": "boolean",
            "title": "Ready",
            "description": "Whether the taxonomy is ready for use. False for async inference (cluster/LLM) that needs processing. True for flat/explicit hierarchies.",
            "default": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp for this taxonomy record"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional user-defined metadata for the taxonomy"
          }
        },
        "type": "object",
        "required": [
          "taxonomy_name",
          "config"
        ],
        "title": "TaxonomyModel",
        "description": "Primary Pydantic model representing a taxonomy definition.",
        "examples": [
          {
            "config": {
              "default_input_mappings": [
                {
                  "input_key": "image_vector",
                  "path": "features.clip_vit_l_14",
                  "source_type": "vector"
                }
              ],
              "default_retriever_id": "ret_clip_v1",
              "source_collection": {
                "collection_id": "col_products_v1"
              },
              "taxonomy_type": "flat"
            },
            "namespace_id": "ns_123",
            "taxonomy_name": "product_tags",
            "taxonomy_type": "flat"
          },
          {
            "config": {
              "build_mode": "explicit",
              "default_input_mappings": [
                {
                  "input_key": "face_vec",
                  "path": "features.face",
                  "source_type": "vector"
                }
              ],
              "default_retriever_id": "ret_face_v1",
              "hierarchical_nodes": [
                {
                  "collection_id": "col_employees_v1"
                },
                {
                  "collection_id": "col_executives_v1",
                  "parent_collection_id": "col_employees_v1"
                }
              ],
              "taxonomy_type": "hierarchical"
            },
            "namespace_id": "ns_123",
            "taxonomy_name": "org_hierarchy",
            "taxonomy_type": "hierarchical"
          }
        ]
      },
      "TaxonomyResponse": {
        "properties": {
          "taxonomy_id": {
            "type": "string",
            "title": "Taxonomy Id",
            "description": "Unique identifier for the taxonomy"
          },
          "version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Version",
            "description": "Monotonic version number of the taxonomy configuration",
            "default": 1
          },
          "taxonomy_name": {
            "type": "string",
            "title": "Taxonomy Name",
            "description": "A unique name for the taxonomy within the namespace."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Optional human-readable description."
          },
          "retriever_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Retriever Id",
            "description": "Optional taxonomy-level retriever (prefer per-layer)."
          },
          "input_mappings": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Input Mappings",
            "description": "Optional taxonomy-level inputs (prefer per-layer)."
          },
          "config": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/FlatTaxonomyConfig-Output"
              },
              {
                "$ref": "#/components/schemas/HierarchicalTaxonomyConfig-Output"
              }
            ],
            "title": "Config",
            "description": "Configuration specific to the taxonomy type.",
            "discriminator": {
              "propertyName": "taxonomy_type",
              "mapping": {
                "flat": "#/components/schemas/FlatTaxonomyConfig-Output",
                "hierarchical": "#/components/schemas/HierarchicalTaxonomyConfig-Output"
              }
            }
          },
          "ready": {
            "type": "boolean",
            "title": "Ready",
            "description": "Whether the taxonomy is ready for use. False for async inference (cluster/LLM) that needs processing. True for flat/explicit hierarchies.",
            "default": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp for this taxonomy record"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional user-defined metadata for the taxonomy"
          }
        },
        "type": "object",
        "required": [
          "taxonomy_name",
          "config"
        ],
        "title": "TaxonomyResponse",
        "description": "Response model for a taxonomy.",
        "examples": [
          {
            "config": {
              "default_input_mappings": [
                {
                  "input_key": "image_vector",
                  "path": "features.clip_vit_l_14",
                  "source_type": "vector"
                }
              ],
              "default_retriever_id": "ret_clip_v1",
              "source_collection": {
                "collection_id": "col_products_v1"
              },
              "taxonomy_type": "flat"
            },
            "namespace_id": "ns_123",
            "taxonomy_name": "product_tags",
            "taxonomy_type": "flat"
          },
          {
            "config": {
              "build_mode": "explicit",
              "default_input_mappings": [
                {
                  "input_key": "face_vec",
                  "path": "features.face",
                  "source_type": "vector"
                }
              ],
              "default_retriever_id": "ret_face_v1",
              "hierarchical_nodes": [
                {
                  "collection_id": "col_employees_v1"
                },
                {
                  "collection_id": "col_executives_v1",
                  "parent_collection_id": "col_employees_v1"
                }
              ],
              "taxonomy_type": "hierarchical"
            },
            "namespace_id": "ns_123",
            "taxonomy_name": "org_hierarchy",
            "taxonomy_type": "hierarchical"
          }
        ]
      },
      "TextIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "text"
          },
          "tokenizer": {
            "$ref": "#/components/schemas/TokenizerType",
            "default": "word"
          },
          "min_token_len": {
            "type": "integer",
            "title": "Min Token Len",
            "default": 2
          },
          "max_token_len": {
            "type": "integer",
            "title": "Max Token Len",
            "default": 15
          },
          "lowercase": {
            "type": "boolean",
            "title": "Lowercase",
            "default": true
          }
        },
        "type": "object",
        "title": "TextIndexParams",
        "description": "Configuration for text index."
      },
      "TimeRange": {
        "properties": {
          "start": {
            "type": "string",
            "format": "date-time",
            "title": "Start",
            "description": "Start time (UTC)"
          },
          "end": {
            "type": "string",
            "format": "date-time",
            "title": "End",
            "description": "End time (UTC)"
          }
        },
        "type": "object",
        "required": [
          "start",
          "end"
        ],
        "title": "TimeRange",
        "description": "Time range for analytics queries."
      },
      "TokenizerType": {
        "type": "string",
        "enum": [
          "word",
          "whitespace",
          "prefix",
          "multilingual"
        ],
        "title": "TokenizerType",
        "description": "Tokenizer type."
      },
      "TriggerExecutionConfig": {
        "properties": {
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Collection Ids",
            "description": "Collections to cluster"
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "ClusteringConfig as dict"
          }
        },
        "type": "object",
        "required": [
          "collection_ids",
          "config"
        ],
        "title": "TriggerExecutionConfig",
        "description": "Configuration for cluster execution when trigger fires."
      },
      "TriggerExecutionHistoryItem": {
        "properties": {
          "job_id": {
            "type": "string",
            "title": "Job Id",
            "description": "Job ID"
          },
          "triggered_at": {
            "type": "string",
            "format": "date-time",
            "title": "Triggered At",
            "description": "When trigger fired"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Execution status"
          },
          "execution_time_ms": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Execution Time Ms",
            "description": "Execution time in milliseconds"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Error message if failed"
          },
          "num_clusters": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Num Clusters",
            "description": "Number of clusters created"
          },
          "num_documents": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Num Documents",
            "description": "Number of documents processed"
          }
        },
        "type": "object",
        "required": [
          "job_id",
          "triggered_at",
          "status"
        ],
        "title": "TriggerExecutionHistoryItem",
        "description": "Single execution history item."
      },
      "TriggerHistoryRequest": {
        "properties": {
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Pagination offset",
            "default": 0
          },
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Results per page",
            "default": 50
          },
          "status_filter": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Status Filter",
            "description": "Filter by execution status"
          }
        },
        "type": "object",
        "title": "TriggerHistoryRequest",
        "description": "Request for trigger execution history."
      },
      "TriggerHistoryResponse": {
        "properties": {
          "trigger_id": {
            "type": "string",
            "title": "Trigger Id",
            "description": "Trigger ID"
          },
          "executions": {
            "items": {
              "$ref": "#/components/schemas/TriggerExecutionHistoryItem"
            },
            "type": "array",
            "title": "Executions",
            "description": "Execution history"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total executions"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Current offset"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Current limit"
          }
        },
        "type": "object",
        "required": [
          "trigger_id",
          "executions",
          "total",
          "offset",
          "limit"
        ],
        "title": "TriggerHistoryResponse",
        "description": "Response for trigger execution history."
      },
      "TriggerModel": {
        "properties": {
          "trigger_id": {
            "type": "string",
            "title": "Trigger Id",
            "description": "Unique trigger ID"
          },
          "cluster_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cluster Id",
            "description": "Optional link to cluster definition"
          },
          "namespace_id": {
            "type": "string",
            "title": "Namespace Id",
            "description": "Namespace ID"
          },
          "internal_id": {
            "type": "string",
            "title": "Internal Id",
            "description": "Organization internal ID"
          },
          "execution_config": {
            "$ref": "#/components/schemas/TriggerExecutionConfig",
            "description": "Configuration for cluster execution"
          },
          "trigger_type": {
            "$ref": "#/components/schemas/TriggerType",
            "description": "Type of trigger"
          },
          "schedule_config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Schedule Config",
            "description": "Type-specific schedule configuration"
          },
          "status": {
            "$ref": "#/components/schemas/TriggerStatus",
            "description": "Current status",
            "default": "active"
          },
          "last_triggered_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Triggered At",
            "description": "Last time trigger fired"
          },
          "last_execution_job_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Execution Job Id",
            "description": "Job ID of last execution"
          },
          "next_scheduled_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Scheduled At",
            "description": "Next scheduled execution time"
          },
          "execution_count": {
            "type": "integer",
            "title": "Execution Count",
            "description": "Total executions",
            "default": 0
          },
          "consecutive_failures": {
            "type": "integer",
            "title": "Consecutive Failures",
            "description": "Consecutive execution failures",
            "default": 0
          },
          "last_execution_status": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Execution Status",
            "description": "Status of last execution"
          },
          "last_execution_error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Execution Error",
            "description": "Error from last execution"
          },
          "event_counter": {
            "type": "integer",
            "title": "Event Counter",
            "description": "Current event count since last trigger",
            "default": 0
          },
          "last_cooldown_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Cooldown At",
            "description": "Last time cooldown was applied"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Last update timestamp"
          },
          "created_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Created By",
            "description": "User who created trigger"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Trigger description"
          }
        },
        "type": "object",
        "required": [
          "namespace_id",
          "internal_id",
          "execution_config",
          "trigger_type",
          "schedule_config"
        ],
        "title": "TriggerModel",
        "description": "Model for cluster trigger."
      },
      "TriggerStatus": {
        "type": "string",
        "enum": [
          "active",
          "paused",
          "disabled",
          "failed"
        ],
        "title": "TriggerStatus",
        "description": "Status of a cluster trigger."
      },
      "TriggerType": {
        "type": "string",
        "enum": [
          "cron",
          "interval",
          "event",
          "conditional"
        ],
        "title": "TriggerType",
        "description": "Type of trigger for cluster execution."
      },
      "UMAPParams": {
        "properties": {
          "method": {
            "type": "string",
            "const": "umap",
            "title": "Method",
            "default": "umap"
          },
          "n_components": {
            "type": "integer",
            "maximum": 256.0,
            "minimum": 2.0,
            "title": "N Components",
            "default": 2
          },
          "random_state": {
            "type": "integer",
            "title": "Random State",
            "default": 42
          },
          "n_neighbors": {
            "type": "integer",
            "minimum": 2.0,
            "title": "N Neighbors",
            "default": 15
          },
          "min_dist": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Min Dist",
            "default": 0.1
          }
        },
        "type": "object",
        "title": "UMAPParams"
      },
      "UpdateNamespaceRequest": {
        "properties": {
          "namespace_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Namespace Name",
            "description": "Name of the namespace to update",
            "example": "spotify_playlists_dev"
          },
          "payload_indexes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/PayloadIndexConfig-Input"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Payload Indexes",
            "description": "Updated list of payload index configurations",
            "example": [
              {
                "field_name": "metadata.title",
                "field_schema": {
                  "lowercase": true,
                  "max_token_len": 15,
                  "min_token_len": 2,
                  "tokenizer": "word",
                  "type": "text"
                },
                "type": "text"
              },
              {
                "field_name": "metadata.description",
                "field_schema": {
                  "is_tenant": false,
                  "type": "keyword"
                },
                "type": "keyword"
              }
            ]
          }
        },
        "type": "object",
        "title": "UpdateNamespaceRequest",
        "description": "Request schema for updating a namespace's payload indexes."
      },
      "UpdateObjectRequest": {
        "properties": {
          "key_prefix": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Key Prefix",
            "description": "Updated storage key/path prefix of the object, this will be used to retrieve the object from the storage. It's at the root of the object."
          },
          "blobs": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/CreateBlobRequest"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Blobs",
            "description": "List of new or updated blobs for this object"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Updated metadata for the object, this will be merged with existing metadata."
          },
          "skip_duplicates": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Skip Duplicates",
            "description": "Skip duplicate blobs, if a blob with the same hash already exists, it will be skipped."
          }
        },
        "type": "object",
        "title": "UpdateObjectRequest",
        "description": "Request model for updating an existing bucket object."
      },
      "UpdateTriggerRequest": {
        "properties": {
          "schedule_config": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Schedule Config",
            "description": "Updated schedule configuration"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Updated description"
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TriggerStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Updated status"
          }
        },
        "type": "object",
        "title": "UpdateTriggerRequest",
        "description": "Request to update an existing trigger."
      },
      "UploadListStats": {
        "properties": {
          "total_uploads": {
            "type": "integer",
            "title": "Total Uploads",
            "description": "Total number of uploads in the result set"
          },
          "total_size_bytes": {
            "type": "integer",
            "title": "Total Size Bytes",
            "description": "Total size of all files in bytes"
          },
          "uploads_by_status": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Uploads By Status",
            "description": "Count of uploads grouped by status",
            "examples": [
              {
                "COMPLETED": 35,
                "FAILED": 2,
                "PENDING": 5
              }
            ]
          },
          "avg_file_size_bytes": {
            "type": "number",
            "title": "Avg File Size Bytes",
            "description": "Average file size across all uploads"
          },
          "unique_buckets": {
            "type": "integer",
            "title": "Unique Buckets",
            "description": "Number of unique buckets in the result set"
          }
        },
        "type": "object",
        "required": [
          "total_uploads",
          "total_size_bytes",
          "uploads_by_status",
          "avg_file_size_bytes",
          "unique_buckets"
        ],
        "title": "UploadListStats",
        "description": "Aggregate statistics for a list of uploads."
      },
      "UploadResponse": {
        "properties": {
          "upload_id": {
            "type": "string",
            "title": "Upload Id",
            "description": "Unique identifier for this upload. Auto-generated. \n\nUse this ID to:   - Check status: GET /v1/uploads/{upload_id}   - Confirm upload: POST /v1/uploads/{upload_id}/confirm   - Cancel upload: DELETE /v1/uploads/{upload_id}   - Reference in object creation: POST /v1/buckets/{bucket_id}/objects with 'upload_id' in blobs \n\n\u26a0\ufe0f  ADVANCED: Reference upload_id in object creation to:   - Combine multiple uploads into one object   - Upload files in parallel, create object later   - Reuse same upload across multiple objects \n\nExample:   POST /v1/buckets/{id}/objects {     'blobs': [{'property': 'video', 'type': 'VIDEO', 'upload_id': 'upl_abc123'}]   } \n\nFormat: 'upl_' followed by 12 random characters.",
            "examples": [
              "upl_a1b2c3d4e5f6",
              "upl_x9y8z7w6v5u4"
            ]
          },
          "bucket_id": {
            "type": "string",
            "title": "Bucket Id",
            "description": "Target bucket ID where object will be created",
            "examples": [
              "bkt_abc123"
            ]
          },
          "filename": {
            "type": "string",
            "title": "Filename",
            "description": "Name of the file to upload",
            "examples": [
              "product_video.mp4"
            ]
          },
          "content_type": {
            "type": "string",
            "title": "Content Type",
            "description": "MIME type enforced by the presigned URL",
            "examples": [
              "video/mp4"
            ]
          },
          "file_size_bytes": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Size Bytes",
            "description": "Expected file size in bytes if provided in request. Will be validated during confirmation.",
            "examples": [
              10485760
            ]
          },
          "presigned_url": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 2083,
                "minLength": 1,
                "format": "uri"
              },
              {
                "type": "null"
              }
            ],
            "title": "Presigned Url",
            "description": "Time-limited HTTPS URL for uploading directly to S3. Use HTTP PUT with the file content to upload:   curl -X PUT '{presigned_url}' -H 'Content-Type: {content_type}' --upload-file {filename} The URL includes authentication and expires after presigned_url_expiration seconds. After successful upload, S3 returns an ETag header - save this for confirmation. NOTE: This will be null if is_duplicate=true (duplicate found, no upload needed)."
          },
          "presigned_url_expiration": {
            "type": "integer",
            "title": "Presigned Url Expiration",
            "description": "How long the presigned URL is valid, in seconds",
            "examples": [
              3600
            ]
          },
          "s3_key": {
            "type": "string",
            "title": "S3 Key",
            "description": "Full S3 object key where the file will be stored. Format: {internal_id}/{namespace_id}/api_buckets_uploads_create/{upload_id}/{filename}. Used internally for verification and object creation.",
            "examples": [
              "int_xyz/ns_abc/api_buckets_uploads_create/upl_123/video.mp4"
            ]
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Current upload status. After creation, always PENDING. Possible statuses: PENDING \u2192 IN_PROGRESS \u2192 PROCESSING \u2192 COMPLETED/FAILED/CANCELED",
            "examples": [
              "PENDING"
            ]
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Custom metadata for tracking"
          },
          "create_object_on_confirm": {
            "type": "boolean",
            "title": "Create Object On Confirm",
            "description": "Whether bucket object will be auto-created on confirmation"
          },
          "object_metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Metadata",
            "description": "Metadata for the bucket object (if create_object_on_confirm=true)"
          },
          "blob_property": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Blob Property",
            "description": "Property name for the blob in bucket object"
          },
          "blob_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Blob Type",
            "description": "Type of blob (IMAGE, VIDEO, etc.)"
          },
          "file_hash": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "File Hash",
            "description": "SHA256 hash of the file content. Set during confirmation from S3 metadata or provided in request. Used for duplicate detection.",
            "examples": [
              "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
            ]
          },
          "skip_duplicates": {
            "type": "boolean",
            "title": "Skip Duplicates",
            "description": "Whether duplicate detection was enabled for this upload",
            "default": true
          },
          "is_duplicate": {
            "type": "boolean",
            "title": "Is Duplicate",
            "description": "Whether this upload was identified as a duplicate of an existing file. If true:   - duplicate_of_upload_id contains the original upload   - presigned_url will be null (no upload needed)   - You can use the original upload's S3 object. This saves bandwidth and storage costs.",
            "default": false
          },
          "duplicate_of_upload_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Duplicate Of Upload Id",
            "description": "If skip_duplicates=true and duplicate found, this is the original upload_id. The response will reference the existing upload instead of creating a new one.",
            "examples": [
              "upl_original123"
            ]
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Human-readable message about the upload. Provided when is_duplicate=true or other special conditions. Example: 'File already exists with the same content hash. No upload needed - returning existing upload.'"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "When this upload record was created (ISO 8601 format)",
            "examples": [
              "2024-01-15T10:30:00Z"
            ]
          },
          "expires_at": {
            "type": "string",
            "format": "date-time",
            "title": "Expires At",
            "description": "When the presigned URL expires (ISO 8601 format). After this time:   - The presigned URL cannot be used   - Upload status will be marked as FAILED if not completed   - The upload record will be auto-deleted 30 days later (MongoDB TTL)",
            "examples": [
              "2024-01-15T11:30:00Z"
            ]
          },
          "completed_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Completed At",
            "description": "When the upload was completed and verified (ISO 8601 format)",
            "examples": [
              "2024-01-15T10:35:00Z"
            ]
          },
          "verified_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Verified At",
            "description": "When S3 object existence was verified (ISO 8601 format)",
            "examples": [
              "2024-01-15T10:35:00Z"
            ]
          },
          "etag": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Etag",
            "description": "S3 ETag from the uploaded object (set during confirmation)",
            "examples": [
              "d41d8cd98f00b204e9800998ecf8427e"
            ]
          },
          "object_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Object Id",
            "description": "Created bucket object ID (if create_object_on_confirm was true)",
            "examples": [
              "obj_a1b2c3d4e5f6"
            ]
          },
          "task_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Task Id",
            "description": "Celery task ID for async confirmation (if processed asynchronously)",
            "examples": [
              "task_abc123"
            ]
          }
        },
        "type": "object",
        "required": [
          "upload_id",
          "bucket_id",
          "filename",
          "content_type",
          "presigned_url_expiration",
          "s3_key",
          "status",
          "create_object_on_confirm",
          "created_at",
          "expires_at"
        ],
        "title": "UploadResponse",
        "description": "Response containing presigned URL and upload tracking information.\n\nThis response includes everything needed to:\n1. Upload your file to S3 using the presigned_url\n2. Track the upload status using upload_id\n3. Confirm the upload using the confirmation endpoint\n\nThe presigned_url is time-limited and specific to this upload.\nAfter uploading to S3, call POST /v1/buckets/{bucket_id}/uploads/{upload_id}/confirm.",
        "examples": [
          {
            "blob_property": "video",
            "blob_type": "VIDEO",
            "bucket_id": "bkt_prod_videos",
            "content_type": "video/mp4",
            "create_object_on_confirm": true,
            "created_at": "2024-01-15T10:30:00Z",
            "description": "New upload ready for S3 upload",
            "expires_at": "2024-01-15T11:30:00Z",
            "file_size_bytes": 52428800,
            "filename": "product_demo.mp4",
            "is_duplicate": false,
            "object_metadata": {
              "category": "tutorials"
            },
            "presigned_url": "https://s3.amazonaws.com/bucket/key?X-Amz-Signature=...",
            "presigned_url_expiration": 3600,
            "s3_key": "int_xyz/ns_abc/api_buckets_uploads_create/upl_abc123xyz789/product_demo.mp4",
            "skip_duplicates": true,
            "status": "PENDING",
            "upload_id": "upl_abc123xyz789"
          },
          {
            "bucket_id": "bkt_prod_videos",
            "completed_at": "2024-01-10T08:25:00Z",
            "content_type": "video/mp4",
            "created_at": "2024-01-10T08:20:00Z",
            "description": "Duplicate detected - no upload needed",
            "duplicate_of_upload_id": "upl_original456",
            "file_hash": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
            "file_size_bytes": 52428800,
            "filename": "product_demo.mp4",
            "is_duplicate": true,
            "message": "File already exists with the same content hash. No upload needed - returning existing upload.",
            "object_id": "obj_existing789",
            "s3_key": "int_xyz/ns_abc/api_buckets_uploads_create/upl_original456/product_demo.mp4",
            "status": "COMPLETED",
            "upload_id": "upl_original456"
          },
          {
            "bucket_id": "bkt_media",
            "content_type": "video/mp4",
            "create_object_on_confirm": false,
            "created_at": "2024-01-15T10:30:00Z",
            "description": "Manual object creation workflow - Upload for later use",
            "expires_at": "2024-01-15T11:30:00Z",
            "filename": "video.mp4",
            "note": "Use create_object_on_confirm=false to reference upload_id manually",
            "presigned_url": "https://s3.amazonaws.com/bucket/key?X-Amz-Signature=...",
            "presigned_url_expiration": 3600,
            "s3_key": "int_xyz/ns_abc/api_buckets_uploads_create/upl_manual789/video.mp4",
            "status": "PENDING",
            "upload_id": "upl_manual789",
            "workflow": [
              "1. User uploads file to presigned_url",
              "2. POST /uploads/upl_manual789/confirm (verifies upload)",
              "3. POST /buckets/{id}/objects with upload_id reference:",
              "   {blobs: [{property: 'video', type: 'VIDEO', upload_id: 'upl_manual789'}]}"
            ]
          }
        ]
      },
      "UsageStatistics": {
        "properties": {
          "total_queries": {
            "type": "integer",
            "title": "Total Queries",
            "description": "Total number of queries executed",
            "default": 0
          },
          "queries_last_24h": {
            "type": "integer",
            "title": "Queries Last 24H",
            "description": "Number of queries in the last 24 hours",
            "default": 0
          },
          "avg_latency_ms": {
            "type": "number",
            "title": "Avg Latency Ms",
            "description": "Average latency in milliseconds",
            "default": 0.0
          },
          "error_rate": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Error Rate",
            "description": "Error rate as a fraction (0.0 - 1.0)",
            "default": 0.0
          },
          "last_error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Error",
            "description": "Most recent error message for debugging"
          },
          "cache_hit_rate": {
            "anyOf": [
              {
                "type": "number",
                "maximum": 1.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Cache Hit Rate",
            "description": "Cache hit rate if caching is enabled (0.0 - 1.0)"
          }
        },
        "type": "object",
        "title": "UsageStatistics",
        "description": "Usage statistics for a retriever."
      },
      "UserCreateRequest": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email",
            "description": "Unique email address within the organization."
          },
          "user_name": {
            "type": "string",
            "maxLength": 100,
            "minLength": 2,
            "title": "User Name",
            "description": "Display name shown in dashboards and audit trails."
          },
          "role": {
            "$ref": "#/components/schemas/UserRole",
            "description": "Default role within the organization if omitted.",
            "default": "member"
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Custom key/value metadata stored with the user record."
          }
        },
        "type": "object",
        "required": [
          "email",
          "user_name"
        ],
        "title": "UserCreateRequest",
        "description": "Payload for creating an organization user.",
        "examples": [
          {
            "email": "alice@example.com",
            "role": "member",
            "user_name": "Alice Smith"
          },
          {
            "email": "bob@example.com",
            "metadata": {
              "department": "Engineering"
            },
            "role": "admin",
            "user_name": "Bob Johnson"
          }
        ]
      },
      "UserModel": {
        "properties": {
          "user_id": {
            "type": "string",
            "title": "User Id",
            "description": "Immutable public identifier for the user."
          },
          "internal_id": {
            "type": "string",
            "title": "Internal Id",
            "description": "Organization internal identifier used for scoping queries."
          },
          "organization_id": {
            "type": "string",
            "title": "Organization Id",
            "description": "Organization public identifier for reference in APIs."
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email",
            "description": "Unique email address for the user."
          },
          "user_name": {
            "type": "string",
            "title": "User Name",
            "description": "Display name shown in UI and logs."
          },
          "role": {
            "$ref": "#/components/schemas/UserRole",
            "description": "Organization role controlling UI access levels.",
            "default": "member"
          },
          "status": {
            "$ref": "#/components/schemas/UserStatus",
            "description": "Lifecycle status of the account.",
            "default": "active"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Arbitrary metadata stored alongside the user record."
          },
          "namespace_permissions": {
            "items": {
              "$ref": "#/components/schemas/NamespacePermissions"
            },
            "type": "array",
            "title": "Namespace Permissions",
            "description": "Namespace-level roles applied across all of the user's keys."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "UTC timestamp when the user was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "UTC timestamp of the latest update to the user."
          },
          "last_login": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Login",
            "description": "UTC timestamp of the last successful login."
          }
        },
        "type": "object",
        "required": [
          "internal_id",
          "organization_id",
          "email",
          "user_name"
        ],
        "title": "UserModel",
        "description": "Canonical user document persisted in MongoDB.",
        "examples": [
          {
            "created_at": "2025-01-01T00:00:00Z",
            "email": "alice@example.com",
            "internal_id": "int_x1y2z3",
            "metadata": {
              "department": "ML"
            },
            "organization_id": "org_demo123",
            "role": "member",
            "status": "active",
            "updated_at": "2025-01-01T00:00:00Z",
            "user_id": "usr_a1b2c3d4e5f6g7h",
            "user_name": "Alice Smith"
          }
        ]
      },
      "UserRole": {
        "type": "string",
        "enum": [
          "admin",
          "member",
          "viewer"
        ],
        "title": "UserRole",
        "description": "High-level organization role applied to users.\n\nRoles define the baseline permissions a user has within an organization:\n\n- ADMIN: Full administrative access including user management, billing,\n  and organization settings. Can create/modify/delete all resources.\n- MEMBER: Standard user access. Can create and manage their own resources\n  (namespaces, collections, clusters) but cannot manage other users or\n  organization-level settings.\n- VIEWER: Read-only access. Can view resources and execute retrievers but\n  cannot create, modify, or delete any resources."
      },
      "UserStatus": {
        "type": "string",
        "enum": [
          "active",
          "suspended",
          "pending"
        ],
        "title": "UserStatus",
        "description": "Lifecycle state of an organization user.\n\nStatus values control whether a user can authenticate and access resources:\n\n- ACTIVE: User is fully operational and can authenticate with their API keys.\n- SUSPENDED: User access is temporarily disabled. API keys will not work but\n  account data is preserved. Can be reactivated by an admin.\n- PENDING: User invitation has been created but not yet accepted. User cannot\n  authenticate until they complete the onboarding flow."
      },
      "UserUpdateRequest": {
        "properties": {
          "user_name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 100,
                "minLength": 2
              },
              {
                "type": "null"
              }
            ],
            "title": "User Name",
            "description": "Updated display name."
          },
          "role": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UserRole"
              },
              {
                "type": "null"
              }
            ],
            "description": "Updated organization role."
          },
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UserStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Lifecycle status update (active, suspended, pending)."
          },
          "metadata": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Metadata",
            "description": "Replaces metadata with the provided dictionary when set."
          }
        },
        "type": "object",
        "title": "UserUpdateRequest",
        "description": "Partial update payload for a user."
      },
      "UuidIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "uuid"
          },
          "is_tenant": {
            "type": "boolean",
            "title": "Is Tenant",
            "default": false
          }
        },
        "type": "object",
        "title": "UuidIndexParams",
        "description": "Configuration for UUID index."
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "VectorBasedConfig": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor to use for vectors"
          },
          "clustering_method": {
            "$ref": "#/components/schemas/ClusteringAlgorithm",
            "description": "Clustering algorithm to use"
          },
          "sample_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sample Size",
            "description": "Number of samples to use for clustering"
          },
          "kmeans_parameters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/KMeansParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Kmeans Parameters",
            "description": "Parameters for K-means clustering (deprecated, use algorithm_params)"
          },
          "dbscan_parameters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DBSCANParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dbscan Parameters",
            "description": "Parameters for DBSCAN clustering (deprecated, use algorithm_params)"
          },
          "hdbscan_parameters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HDBSCANParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Hdbscan Parameters",
            "description": "Parameters for HDBSCAN clustering (deprecated, use algorithm_params)"
          },
          "algorithm_params": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/KMeansParams"
              },
              {
                "$ref": "#/components/schemas/DBSCANParams"
              },
              {
                "$ref": "#/components/schemas/HDBSCANParams"
              },
              {
                "$ref": "#/components/schemas/AgglomerativeParams"
              },
              {
                "$ref": "#/components/schemas/SpectralParams"
              },
              {
                "$ref": "#/components/schemas/GaussianMixtureParams"
              },
              {
                "$ref": "#/components/schemas/MeanShiftParams"
              },
              {
                "$ref": "#/components/schemas/OPTICSParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Algorithm Params",
            "description": "Algorithm-specific parameters"
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "clustering_method"
        ],
        "title": "VectorBasedConfig",
        "description": "Configuration for vector-based clustering."
      },
      "VectorDataType": {
        "type": "string",
        "enum": [
          "float32",
          "uint8"
        ],
        "title": "VectorDataType",
        "description": "Vector data type."
      },
      "VectorIndex": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "dimensions": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Dimensions",
            "description": "Number of dimensions. Required for dense vectors, None for sparse vectors."
          },
          "type": {
            "$ref": "#/components/schemas/VectorType"
          },
          "distance": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Distance",
            "default": "cosine"
          },
          "datatype": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VectorDataType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Data type of the vector.",
            "default": "float32"
          },
          "on_disk": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "On Disk",
            "description": "If true, vectors will be stored on disk. Use for large vectors."
          },
          "supported_inputs": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/BucketSchemaFieldType"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Supported Inputs"
          },
          "inference_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inference Name",
            "description": "The path to the embedding model service to use for this vector index."
          }
        },
        "type": "object",
        "required": [
          "name",
          "description",
          "type"
        ],
        "title": "VectorIndex",
        "description": "Base configuration for vector indexes."
      },
      "VectorIndexDefinition": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "type": {
            "type": "string",
            "enum": [
              "single",
              "multi"
            ],
            "title": "Type"
          },
          "index": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VectorIndex"
              },
              {
                "$ref": "#/components/schemas/MultiVectorIndex"
              }
            ],
            "title": "Index"
          }
        },
        "type": "object",
        "required": [
          "name",
          "description",
          "type",
          "index"
        ],
        "title": "VectorIndexDefinition",
        "description": "Complete vector index definition that can be either single or multi-vector."
      },
      "VectorType": {
        "type": "string",
        "enum": [
          "dense",
          "sparse",
          "multi_dense"
        ],
        "title": "VectorType",
        "description": "Enumeration of vector types supported by the system."
      },
      "Webhook-Input": {
        "properties": {
          "webhook_id": {
            "type": "string",
            "pattern": "^wh_[a-zA-Z0-9]{10}$",
            "title": "Webhook Id",
            "description": "Unique identifier for the webhook. Auto-generated with 'wh_' prefix followed by secure random token. Format: wh_{10-character alphanumeric}. Used for API operations and event tracking.",
            "examples": [
              "wh_abc123def4",
              "wh_xyz789uvw0"
            ]
          },
          "webhook_name": {
            "type": "string",
            "maxLength": 200,
            "minLength": 1,
            "title": "Webhook Name",
            "description": "REQUIRED. Human-readable name for the webhook. Displayed in dashboards, logs, and notification metadata. Should describe the webhook's purpose or destination. Format: 1-200 characters.",
            "examples": [
              "Slack Engineering Alerts",
              "External System Integration",
              "Audit Trail Logger",
              "Production Monitoring"
            ]
          },
          "internal_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Internal Id",
            "description": "Organization internal identifier for multi-tenancy scoping. All webhook operations are scoped to this organization. Excluded from API responses for security. Format: int_{24-character secure token}."
          },
          "event_types": {
            "items": {
              "$ref": "#/components/schemas/WebhookEventType"
            },
            "type": "array",
            "minItems": 1,
            "title": "Event Types",
            "description": "REQUIRED. List of event types that trigger this webhook. When any of these events occur, notifications are sent to all channels. Must contain at least one event type. Common patterns: - ['object.created', 'object.updated'] for object lifecycle tracking - ['cluster.execution.completed', 'cluster.execution.failed'] for job monitoring - ['*'] for all events (use cautiously, high volume)",
            "examples": [
              [
                "object.created",
                "object.updated",
                "object.deleted"
              ],
              [
                "cluster.execution.completed",
                "cluster.execution.failed"
              ],
              [
                "collection.documents.written"
              ]
            ]
          },
          "channels": {
            "items": {
              "$ref": "#/components/schemas/WebhookChannel-Input"
            },
            "type": "array",
            "minItems": 1,
            "title": "Channels",
            "description": "REQUIRED. List of notification channels for event delivery. When an event occurs, notifications are sent to ALL configured channels. Must contain at least one channel. Multiple channels provide redundancy and multi-audience delivery. Example: Send to both Slack (team) and email (manager) for critical events."
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether the webhook is currently active and should send notifications. True: Events trigger notifications to channels. False: Webhook is paused, no notifications sent but config preserved. Use to temporarily disable webhooks without losing configuration. Default: True",
            "default": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "UTC timestamp when the webhook was created. Auto-generated at creation time. Immutable after creation. Format: ISO 8601 datetime."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "UTC timestamp of the most recent webhook update. Updated automatically when event_types, channels, or is_active changes. Tracks configuration modifications. Format: ISO 8601 datetime."
          }
        },
        "type": "object",
        "required": [
          "webhook_name",
          "event_types",
          "channels"
        ],
        "title": "Webhook",
        "description": "Configured webhook subscription for organization event notifications.\n\nWebhooks enable real-time notifications when events occur in the system.\nEach webhook subscribes to specific event types and delivers notifications\nvia one or more configured channels (Slack, email, HTTP, SMS).\n\nWebhook Lifecycle:\n    1. Created with event_types and channels configured\n    2. is_active=True enables notification delivery\n    3. Events matching event_types trigger notifications to all channels\n    4. is_active=False temporarily pauses notifications without deletion\n    5. Webhook can be updated to add/remove event types or channels\n    6. Permanent deletion removes the webhook configuration\n\nUse Cases:\n    - Integrate Mixpeek events with external systems via HTTP webhooks\n    - Notify teams in Slack when ingestion jobs complete\n    - Send email alerts when critical failures occur\n    - Trigger automated workflows based on state changes\n    - Maintain audit trails by forwarding events to SIEM systems\n\nBest Practices:\n    - Subscribe only to events you need (reduces noise)\n    - Use descriptive webhook_name for identification\n    - Configure multiple channels for critical events (redundancy)\n    - Set is_active=False to temporarily disable without losing config\n    - Monitor webhook delivery failures via last_error tracking",
        "examples": [
          {
            "channels": [
              {
                "channel": "slack",
                "configs": {
                  "bot_token": "xoxb-...",
                  "channel_id": "C0123456789",
                  "workspace_id": "T0123456789"
                }
              }
            ],
            "created_at": "2025-01-01T00:00:00Z",
            "description": "Slack notifications for object lifecycle",
            "event_types": [
              "object.created",
              "object.updated",
              "object.deleted"
            ],
            "is_active": true,
            "updated_at": "2025-01-01T00:00:00Z",
            "webhook_id": "wh_abc123def4",
            "webhook_name": "Engineering Slack Alerts"
          },
          {
            "channels": [
              {
                "channel": "slack",
                "configs": {
                  "bot_token": "xoxb-...",
                  "channel_id": "C0123456789",
                  "workspace_id": "T0123456789"
                }
              },
              {
                "channel": "email",
                "configs": {
                  "recipients": [
                    "oncall@example.com"
                  ],
                  "subject_template": "CRITICAL: {event_type}"
                }
              },
              {
                "channel": "sms",
                "configs": {
                  "phone_numbers": [
                    "+1234567890"
                  ],
                  "provider": "twilio"
                }
              }
            ],
            "created_at": "2025-01-01T00:00:00Z",
            "description": "Multi-channel alerts for cluster failures",
            "event_types": [
              "cluster.execution.failed",
              "trigger.execution.failed"
            ],
            "is_active": true,
            "updated_at": "2025-01-15T10:30:00Z",
            "webhook_id": "wh_xyz789uvw0",
            "webhook_name": "Production Monitoring"
          },
          {
            "channels": [
              {
                "channel": "webhook",
                "configs": {
                  "headers": {
                    "Authorization": "Bearer secret123"
                  },
                  "method": "POST",
                  "url": "https://siem.company.com/webhooks/mixpeek"
                }
              }
            ],
            "created_at": "2025-01-01T00:00:00Z",
            "description": "External system integration via HTTP webhook",
            "event_types": [
              "object.created",
              "object.updated",
              "object.deleted",
              "collection.created",
              "collection.deleted"
            ],
            "is_active": true,
            "updated_at": "2025-01-01T00:00:00Z",
            "webhook_id": "wh_int123ext4",
            "webhook_name": "SIEM Audit Trail"
          }
        ]
      },
      "Webhook-Output": {
        "properties": {
          "webhook_id": {
            "type": "string",
            "pattern": "^wh_[a-zA-Z0-9]{10}$",
            "title": "Webhook Id",
            "description": "Unique identifier for the webhook. Auto-generated with 'wh_' prefix followed by secure random token. Format: wh_{10-character alphanumeric}. Used for API operations and event tracking.",
            "examples": [
              "wh_abc123def4",
              "wh_xyz789uvw0"
            ]
          },
          "webhook_name": {
            "type": "string",
            "maxLength": 200,
            "minLength": 1,
            "title": "Webhook Name",
            "description": "REQUIRED. Human-readable name for the webhook. Displayed in dashboards, logs, and notification metadata. Should describe the webhook's purpose or destination. Format: 1-200 characters.",
            "examples": [
              "Slack Engineering Alerts",
              "External System Integration",
              "Audit Trail Logger",
              "Production Monitoring"
            ]
          },
          "event_types": {
            "items": {
              "$ref": "#/components/schemas/WebhookEventType"
            },
            "type": "array",
            "minItems": 1,
            "title": "Event Types",
            "description": "REQUIRED. List of event types that trigger this webhook. When any of these events occur, notifications are sent to all channels. Must contain at least one event type. Common patterns: - ['object.created', 'object.updated'] for object lifecycle tracking - ['cluster.execution.completed', 'cluster.execution.failed'] for job monitoring - ['*'] for all events (use cautiously, high volume)",
            "examples": [
              [
                "object.created",
                "object.updated",
                "object.deleted"
              ],
              [
                "cluster.execution.completed",
                "cluster.execution.failed"
              ],
              [
                "collection.documents.written"
              ]
            ]
          },
          "channels": {
            "items": {
              "$ref": "#/components/schemas/WebhookChannel-Output"
            },
            "type": "array",
            "minItems": 1,
            "title": "Channels",
            "description": "REQUIRED. List of notification channels for event delivery. When an event occurs, notifications are sent to ALL configured channels. Must contain at least one channel. Multiple channels provide redundancy and multi-audience delivery. Example: Send to both Slack (team) and email (manager) for critical events."
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether the webhook is currently active and should send notifications. True: Events trigger notifications to channels. False: Webhook is paused, no notifications sent but config preserved. Use to temporarily disable webhooks without losing configuration. Default: True",
            "default": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "UTC timestamp when the webhook was created. Auto-generated at creation time. Immutable after creation. Format: ISO 8601 datetime."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "UTC timestamp of the most recent webhook update. Updated automatically when event_types, channels, or is_active changes. Tracks configuration modifications. Format: ISO 8601 datetime."
          }
        },
        "type": "object",
        "required": [
          "webhook_name",
          "event_types",
          "channels"
        ],
        "title": "Webhook",
        "description": "Configured webhook subscription for organization event notifications.\n\nWebhooks enable real-time notifications when events occur in the system.\nEach webhook subscribes to specific event types and delivers notifications\nvia one or more configured channels (Slack, email, HTTP, SMS).\n\nWebhook Lifecycle:\n    1. Created with event_types and channels configured\n    2. is_active=True enables notification delivery\n    3. Events matching event_types trigger notifications to all channels\n    4. is_active=False temporarily pauses notifications without deletion\n    5. Webhook can be updated to add/remove event types or channels\n    6. Permanent deletion removes the webhook configuration\n\nUse Cases:\n    - Integrate Mixpeek events with external systems via HTTP webhooks\n    - Notify teams in Slack when ingestion jobs complete\n    - Send email alerts when critical failures occur\n    - Trigger automated workflows based on state changes\n    - Maintain audit trails by forwarding events to SIEM systems\n\nBest Practices:\n    - Subscribe only to events you need (reduces noise)\n    - Use descriptive webhook_name for identification\n    - Configure multiple channels for critical events (redundancy)\n    - Set is_active=False to temporarily disable without losing config\n    - Monitor webhook delivery failures via last_error tracking",
        "examples": [
          {
            "channels": [
              {
                "channel": "slack",
                "configs": {
                  "bot_token": "xoxb-...",
                  "channel_id": "C0123456789",
                  "workspace_id": "T0123456789"
                }
              }
            ],
            "created_at": "2025-01-01T00:00:00Z",
            "description": "Slack notifications for object lifecycle",
            "event_types": [
              "object.created",
              "object.updated",
              "object.deleted"
            ],
            "is_active": true,
            "updated_at": "2025-01-01T00:00:00Z",
            "webhook_id": "wh_abc123def4",
            "webhook_name": "Engineering Slack Alerts"
          },
          {
            "channels": [
              {
                "channel": "slack",
                "configs": {
                  "bot_token": "xoxb-...",
                  "channel_id": "C0123456789",
                  "workspace_id": "T0123456789"
                }
              },
              {
                "channel": "email",
                "configs": {
                  "recipients": [
                    "oncall@example.com"
                  ],
                  "subject_template": "CRITICAL: {event_type}"
                }
              },
              {
                "channel": "sms",
                "configs": {
                  "phone_numbers": [
                    "+1234567890"
                  ],
                  "provider": "twilio"
                }
              }
            ],
            "created_at": "2025-01-01T00:00:00Z",
            "description": "Multi-channel alerts for cluster failures",
            "event_types": [
              "cluster.execution.failed",
              "trigger.execution.failed"
            ],
            "is_active": true,
            "updated_at": "2025-01-15T10:30:00Z",
            "webhook_id": "wh_xyz789uvw0",
            "webhook_name": "Production Monitoring"
          },
          {
            "channels": [
              {
                "channel": "webhook",
                "configs": {
                  "headers": {
                    "Authorization": "Bearer secret123"
                  },
                  "method": "POST",
                  "url": "https://siem.company.com/webhooks/mixpeek"
                }
              }
            ],
            "created_at": "2025-01-01T00:00:00Z",
            "description": "External system integration via HTTP webhook",
            "event_types": [
              "object.created",
              "object.updated",
              "object.deleted",
              "collection.created",
              "collection.deleted"
            ],
            "is_active": true,
            "updated_at": "2025-01-01T00:00:00Z",
            "webhook_id": "wh_int123ext4",
            "webhook_name": "SIEM Audit Trail"
          }
        ]
      },
      "WebhookChannel-Input": {
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "REQUIRED. The notification channel type for delivery. Determines which delivery mechanism is used (email, Slack, webhook, SMS). Must match the type of the configs field."
          },
          "configs": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EmailConfig"
              },
              {
                "$ref": "#/components/schemas/SlackConfig"
              },
              {
                "$ref": "#/components/schemas/WebhookConfig"
              },
              {
                "$ref": "#/components/schemas/SmsConfig"
              }
            ],
            "title": "Configs",
            "description": "REQUIRED. Channel-specific configuration for notification delivery. Type depends on the channel field: - EmailConfig for EMAIL channel (recipients, subject template, etc.) - SlackConfig for SLACK channel (workspace, channel, bot token) - WebhookConfig for WEBHOOK channel (URL, headers, auth) - SmsConfig for SMS channel (phone numbers, provider credentials). See respective config models for detailed field requirements."
          }
        },
        "type": "object",
        "required": [
          "channel",
          "configs"
        ],
        "title": "WebhookChannel",
        "description": "Notification channel configuration for webhook delivery.\n\nDefines how and where webhook event notifications should be delivered.\nEach webhook can have multiple channels configured for redundancy or\ndifferent notification audiences.\n\nSupported Channels:\n    - EMAIL: Send notifications via email to specified recipients\n    - SLACK: Post messages to Slack channels or direct messages\n    - WEBHOOK: HTTP POST to external endpoints (standard webhooks)\n    - SMS: Send text message notifications to phone numbers\n\nUse Cases:\n    - Route critical alerts to SMS and Slack simultaneously\n    - Send audit trail events to external webhook endpoints\n    - Notify team members via email for object lifecycle events\n    - Post cluster completion status to Slack channels\n\nRequirements:\n    - Channel type must match the config type (discriminated union)\n    - Each config must have valid credentials/endpoints configured\n    - Channel configs are validated at webhook creation time",
        "examples": [
          {
            "channel": "slack",
            "configs": {
              "bot_token": "xoxb-...",
              "channel_id": "C0123456789",
              "workspace_id": "T0123456789"
            },
            "description": "Slack notification channel"
          },
          {
            "channel": "email",
            "configs": {
              "recipients": [
                "team@example.com",
                "admin@example.com"
              ],
              "subject_template": "Mixpeek Alert: {event_type}"
            },
            "description": "Email notification channel"
          },
          {
            "channel": "webhook",
            "configs": {
              "headers": {
                "Authorization": "Bearer token123"
              },
              "method": "POST",
              "url": "https://api.example.com/webhooks/mixpeek"
            },
            "description": "HTTP webhook channel"
          }
        ]
      },
      "WebhookChannel-Output": {
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "REQUIRED. The notification channel type for delivery. Determines which delivery mechanism is used (email, Slack, webhook, SMS). Must match the type of the configs field."
          },
          "configs": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EmailConfig"
              },
              {
                "$ref": "#/components/schemas/SlackConfig"
              },
              {
                "$ref": "#/components/schemas/WebhookConfig"
              },
              {
                "$ref": "#/components/schemas/SmsConfig"
              }
            ],
            "title": "Configs",
            "description": "REQUIRED. Channel-specific configuration for notification delivery. Type depends on the channel field: - EmailConfig for EMAIL channel (recipients, subject template, etc.) - SlackConfig for SLACK channel (workspace, channel, bot token) - WebhookConfig for WEBHOOK channel (URL, headers, auth) - SmsConfig for SMS channel (phone numbers, provider credentials). See respective config models for detailed field requirements."
          }
        },
        "type": "object",
        "required": [
          "channel",
          "configs"
        ],
        "title": "WebhookChannel",
        "description": "Notification channel configuration for webhook delivery.\n\nDefines how and where webhook event notifications should be delivered.\nEach webhook can have multiple channels configured for redundancy or\ndifferent notification audiences.\n\nSupported Channels:\n    - EMAIL: Send notifications via email to specified recipients\n    - SLACK: Post messages to Slack channels or direct messages\n    - WEBHOOK: HTTP POST to external endpoints (standard webhooks)\n    - SMS: Send text message notifications to phone numbers\n\nUse Cases:\n    - Route critical alerts to SMS and Slack simultaneously\n    - Send audit trail events to external webhook endpoints\n    - Notify team members via email for object lifecycle events\n    - Post cluster completion status to Slack channels\n\nRequirements:\n    - Channel type must match the config type (discriminated union)\n    - Each config must have valid credentials/endpoints configured\n    - Channel configs are validated at webhook creation time",
        "examples": [
          {
            "channel": "slack",
            "configs": {
              "bot_token": "xoxb-...",
              "channel_id": "C0123456789",
              "workspace_id": "T0123456789"
            },
            "description": "Slack notification channel"
          },
          {
            "channel": "email",
            "configs": {
              "recipients": [
                "team@example.com",
                "admin@example.com"
              ],
              "subject_template": "Mixpeek Alert: {event_type}"
            },
            "description": "Email notification channel"
          },
          {
            "channel": "webhook",
            "configs": {
              "headers": {
                "Authorization": "Bearer token123"
              },
              "method": "POST",
              "url": "https://api.example.com/webhooks/mixpeek"
            },
            "description": "HTTP webhook channel"
          }
        ]
      },
      "WebhookConfig": {
        "properties": {
          "url": {
            "type": "string",
            "title": "Url",
            "description": "The URL to which the webhook will be sent."
          },
          "headers": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Headers",
            "description": "Custom headers to include in the webhook request."
          },
          "payload_template": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Payload Template",
            "description": "A Jinja2 template for the JSON payload."
          },
          "timeout": {
            "type": "number",
            "title": "Timeout",
            "description": "Request timeout in seconds.",
            "default": 10.0
          }
        },
        "type": "object",
        "required": [
          "url"
        ],
        "title": "WebhookConfig",
        "description": "Configuration for webhook notifications."
      },
      "WebhookEventType": {
        "type": "string",
        "enum": [
          "object.created",
          "object.updated",
          "object.deleted",
          "collection.created",
          "collection.updated",
          "collection.deleted",
          "collection.documents.written",
          "cluster.created",
          "cluster.updated",
          "cluster.deleted",
          "cluster.execution.started",
          "cluster.execution.completed",
          "cluster.execution.failed",
          "trigger.created",
          "trigger.updated",
          "trigger.deleted",
          "trigger.paused",
          "trigger.resumed",
          "trigger.fired",
          "trigger.execution.completed",
          "trigger.execution.failed",
          "taxonomy.created"
        ],
        "title": "WebhookEventType",
        "description": "Webhook event types for real-time notifications.\n\nThese events are emitted when significant state changes occur in the system.\nWebhooks subscribe to specific event types and receive notifications via\nconfigured channels (email, Slack, HTTP webhooks, SMS).\n\nEvent Naming Convention:\n    {resource}.{action}[.{sub-resource}[.{sub-action}]]\n\nExamples:\n    - object.created: New object ingested\n    - collection.documents.written: Documents indexed\n    - cluster.execution.completed: Cluster job finished\n\nCache Invalidation Annotations:\n    Each event type includes a comment indicating recommended cache invalidation scope:\n    - [KEY] = Invalidate specific document/object keys\n    - [COLLECTION] = Invalidate collection-level cache\n    - [NAMESPACE] = Invalidate namespace-level cache\n\nEvent Categories:\n    - Object Lifecycle: Events for individual objects (create, update, delete)\n    - Collection Lifecycle: Events for collections (create, update, delete, documents written)\n    - Cluster Lifecycle: Events for clusters (create, update, delete, execution status)\n    - Trigger Lifecycle: Events for cluster triggers (create, update, fire, execution status)\n    - Taxonomy Lifecycle: Events for taxonomies (create, update, delete)\n\nUse Cases:\n    - Real-time sync with external systems\n    - Audit trail and compliance logging\n    - Automated workflows triggered by state changes\n    - Cache invalidation for distributed systems\n    - Notifications to team members via Slack/email"
      }
    },
    "securitySchemes": {
      "ApiKeyAuth": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "API Key",
        "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings."
      }
    },
    "parameters": {
      "XNamespace": {
        "name": "X-Namespace",
        "in": "header",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "Optional namespace for data isolation."
      },
      "IdempotencyKey": {
        "name": "Idempotency-Key",
        "in": "header",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "Provide to make POST/PUT/PATCH idempotent."
      }
    },
    "headers": {
      "X-RateLimit-Limit": {
        "schema": {
          "type": "integer"
        },
        "description": "Request limit per time window."
      },
      "X-RateLimit-Remaining": {
        "schema": {
          "type": "integer"
        },
        "description": "Remaining requests in current window."
      },
      "Retry-After": {
        "schema": {
          "type": "integer"
        },
        "description": "Seconds to wait when rate limited."
      },
      "ETag": {
        "schema": {
          "type": "string"
        },
        "description": "Entity tag of the response for caching."
      },
      "Cache-Control": {
        "schema": {
          "type": "string"
        },
        "description": "Cache control directives."
      },
      "X-Cache-Status": {
        "schema": {
          "type": "string",
          "enum": [
            "HIT",
            "MISS",
            "BYPASS"
          ]
        },
        "description": "Cache hit/miss status."
      }
    }
  },
  "security": [
    {
      "ApiKeyAuth": []
    }
  ]
}