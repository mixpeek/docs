---
title: "Architecture"
description: "How Mixpeek is wired end-to-end"
---

The Mixpeek platform is intentionally split across an API layer, an Engine layer, and a shared storage layer. This separation keeps ingestion, enrichment, and retrieval isolated while still sharing a common data model.

## System Overview

<Frame>
  <img src="/assets/mixpeek-architecture.svg" alt="Mixpeek Architecture" />
</Frame>

<CardGroup cols={3}>
  <Card title="API Layer" icon="server">
    FastAPI and Celery handle HTTP requests, validation, authorization, metadata updates, task creation, and webhook dispatch.
  </Card>
  <Card title="Engine Layer" icon="microchip">
    Ray orchestrates distributed feature extraction, inference, taxonomy materialization, clustering, and other long-running compute.
  </Card>
  <Card title="Shared Storage" icon="database">
    MongoDB, Qdrant, Redis, and S3 provide the contract between layers—no direct imports cross the API ↔ Engine boundary.
  </Card>
</CardGroup>

## Data Flow

### Ingestion (Object → Document)

<Steps>
  <Step title="Upload objects">
    Client uploads objects (`/v1/buckets/{bucket}/objects`)—metadata lands in MongoDB, blobs in S3.
  </Step>
  <Step title="Submit batch">
    Client submits a batch (`/v1/buckets/{bucket}/batches/{batch}/submit`); the API flattens manifests into per-extractor artifacts in S3 and creates tasks.
  </Step>
  <Step title="Process in Ray">
    Ray pollers pick up the batch, execute feature extractors tier-by-tier, write documents to Qdrant, and emit webhook events.
  </Step>
  <Step title="Dispatch events">
    Celery Beat processes webhook events, updates collection schemas, invalidates caches, and notifies external systems.
  </Step>
</Steps>

### Retrieval (Query → Results)

<Steps>
  <Step title="Execute retriever">
    Client calls `/v1/retrievers/{id}/execute` with structured inputs and optional filters.
  </Step>
  <Step title="Validate & plan">
    FastAPI loads the retriever definition, validates inputs, and walks the configured stage pipeline.
  </Step>
  <Step title="Invoke services">
    Stages call Ray Serve for inference, Qdrant for search, MongoDB for joins, and Redis for cache signatures.
  </Step>
  <Step title="Return results">
    Response includes results, stage metrics, cache hints (`ETag`), and budget usage.
  </Step>
</Steps>

## Communication Patterns

<Tabs>
  <Tab title="Task Queue (API → Engine)">
    MongoDB stores batch descriptors; Ray pollers submit jobs and track state on behalf of the Engine.
  </Tab>
  <Tab title="Webhook Events (Engine → API)">
    Engine writes webhook events to MongoDB. Celery Beat dispatches cache invalidation, schema updates, and external notifications.
  </Tab>
  <Tab title="Real-time Inference (API → Engine)">
    API calls Ray Serve HTTP endpoints for embeddings, reranking, generation, and audio transcription workloads.
  </Tab>
</Tabs>

## Further Reading

- [Processing → Feature Extractors](/processing/feature-extractors) for extractor catalogs and configuration patterns
- [Retrieval → Retrievers](/retrieval/retrievers) for stage pipelines, caching, and execution telemetry
- [Operations → Deployment](/operations/deployment) for local and production deployment topologies
- [Operations → Observability](/operations/observability) for metrics, logging, and tracing integrations
