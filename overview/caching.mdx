---
title: "Caching"
description: "Comprehensive caching layer for retriever results with sub-50ms cached responses"
---

<Info>
  Mixpeek's caching system provides a provider-agnostic caching layer for retriever results and LLM generations, delivering sub-50ms cached responses with webhook-driven invalidation and HTTP semantic support (ETag/304).
</Info>

## Overview

- **What's cached**: Complete retriever results, embeddings, and LLM generations
- **Performance**: Sub-50ms cached responses (80%+ compute cost reduction at 80% hit rate)
- **Backend**: Redis (provider-agnostic architecture supports future backends)
- **Invalidation**: Four-level hierarchical invalidation (KEY/COLLECTION/RETRIEVER/NAMESPACE)
- **HTTP Semantics**: Full ETag/304 support for client-side caching

<Frame>
  ```mermaid
  graph TD
    A[Client Request] --> B{Cache Enabled?}
    B -->|Yes| C{Check Redis}
    B -->|No| D[Execute Retriever]
    C -->|HIT| E[Return Cached<br/>X-Cache: HIT<br/>~0.4ms]
    C -->|MISS| D
    D --> F[Cache & Return<br/>X-Cache: MISS<br/>~1500ms]
  ```
</Frame>

## Quick Start

### Enable Caching for a Retriever

When creating or updating a retriever, add `cache_config`:

```json
{
  "retriever_name": "semantic_search",
  "collection_ids": ["col_articles"],
  "stages": [...],
  "cache_config": {
    "enabled": true,
    "ttl_seconds": 3600,
    "stage": "retrieval"
  }
}
```

### Check Cache Performance

Inspect response headers to see cache status:

```bash
curl -i https://api.mixpeek.com/v1/retrievers/ret_semantic/execute \
  -H "Authorization: Bearer $API_KEY" \
  -H "X-Namespace: ns_acme" \
  -d '{"inputs": {"text": "machine learning"}}'
```

Response headers:
```
X-Cache: HIT
ETag: "a7f3b2c1e5d4..."
Cache-Control: public, max-age=3600
```

### Use ETag for Client-Side Caching

Send the ETag back in subsequent requests:

```bash
curl -i https://api.mixpeek.com/v1/retrievers/ret_semantic/execute \
  -H "Authorization: Bearer $API_KEY" \
  -H "X-Namespace: ns_acme" \
  -H "If-None-Match: a7f3b2c1e5d4..." \
  -d '{"inputs": {"text": "machine learning"}}'
```

If content unchanged, receives `304 Not Modified` (no body, sub-10ms).

## Architecture

### Provider-Agnostic Design

The cache follows the same Protocol/Factory pattern as object storage and webhooks:

```python
# Get cache provider (currently Redis, future: Memcached, DynamoDB)
from clients.interfaces.cache import get_cache_provider

cache = get_cache_provider(namespace="ns_acme")

# Use provider-agnostic interface
cache.set("my:key", {"data": "value"}, ttl=60)
value = cache.get("my:key")
cache.delete("my:key")
```

### Cache Key Generation

Cache keys are deterministically generated from:

- **Namespace**: Tenant isolation
- **Collection**: Which collection being searched
- **Retriever ID**: Which retriever configuration
- **Query Hash**: SHA-256 of normalized query inputs
- **Index Signature**: Fingerprint of index state
- **Model Version**: Embedding model version
- **Filters/Sorts/Limits**: Query parameters

**Key structure:**
```
mixpeek:{namespace}:{collection}:{retriever_id}:{cache_key_hash}

Example:
mixpeek:ns_acme:col_articles:ret_semantic:a7f3b2c1e5d4f89a...
```

### Normalization

Ensures equivalent queries produce the same cache key:

- **Text normalization**: Case-insensitive, whitespace-trimmed
- **Filter normalization**: Order-independent sorting
- **JSON canonicalization**: Sorted keys for deterministic hashing

## Configuration

### Per-Retriever Configuration

Configure caching when creating or updating a retriever:

```json
{
  "cache_config": {
    "enabled": true,
    "ttl_seconds": 3600,
    "stage": "retrieval",
    "exclude_fields": ["pii_field"]
  }
}
```

| Field | Type | Description | Default |
|-------|------|-------------|---------|
| `enabled` | boolean | Enable caching for this retriever | `false` |
| `ttl_seconds` | integer | Time-to-live in seconds | `3600` |
| `stage` | string | Cache stage: `retrieval`, `generation`, or `full` | `retrieval` |
| `exclude_fields` | array | Fields to exclude from caching (PII protection) | `[]` |

### TTL Recommendations

| Content Type | TTL | Use Case |
|--------------|-----|----------|
| Real-time feeds | 60-300s | News, social media |
| Frequently updated | 600-1800s | Product catalogs |
| Stable content | 3600-7200s | Documentation, archives |
| Static content | 86400s (24h) | Historical data |

## Cache Invalidation

### Hierarchical Scopes

The cache supports four levels of invalidation:

| Scope | Description | Use Case | Performance |
|-------|-------------|----------|-------------|
| **KEY** | Single cache entry | Document updated | O(1) |
| **COLLECTION** | All entries for collection | Index rebuilt | O(1) via set tracking |
| **RETRIEVER** | All entries for retriever | Config changed | O(1) via set tracking |
| **NAMESPACE** | All entries for namespace | Model deployed | O(N) pattern scan |

### Webhook-Driven Invalidation

Cache invalidation is automatically triggered by webhook events:

| Event Type | Cache Scope | What Gets Invalidated |
|------------|-------------|----------------------|
| `object.updated` | KEY | Specific cache entries for that object |
| `object.deleted` | KEY | Specific cache entries for that object |
| `collection.updated` | COLLECTION | All cache entries for that collection |
| `collection.deleted` | COLLECTION | All cache entries for that collection |
| `index.rebuilt` | COLLECTION | All entries (index signature changed) |
| `embedding.regenerated` | COLLECTION | All entries (embeddings changed) |
| `retriever.updated` | RETRIEVER | All entries for that retriever |
| `retriever.deleted` | RETRIEVER | All entries for that retriever |
| `model.deployed` | NAMESPACE | All entries (model version changed) |

### O(1) Invalidation Mechanism

Uses Redis sets for efficient bulk invalidation:

```python
# On cache SET, track in sets:
collection_set = "mixpeek:cache:collections:ns_acme:col_articles:keys"
retriever_set = "mixpeek:cache:retrievers:ns_acme:ret_semantic:keys"

# On invalidation, O(1) set lookup + bulk delete:
cache_keys = redis.smembers(collection_set)  # O(N) where N = set size
redis.delete(*cache_keys)  # Single operation
```

## HTTP Semantics

### ETag Support

The cache implements standard HTTP caching semantics:

**First Request:**
```http
POST /v1/retrievers/ret_semantic/execute
{ "inputs": {"text": "dogs"}, "limit": 10 }

Response:
HTTP/1.1 200 OK
ETag: "a7f3b2c1e5d4..."
X-Cache: MISS
Cache-Control: public, max-age=3600

{ "results": [...] }
```

**Subsequent Request:**
```http
POST /v1/retrievers/ret_semantic/execute
If-None-Match: "a7f3b2c1e5d4..."
{ "inputs": {"text": "dogs"}, "limit": 10 }

Response:
HTTP/1.1 304 Not Modified
ETag: "a7f3b2c1e5d4..."
Cache-Control: public, max-age=3600

(empty body)
```

### Response Headers

| Header | Description | Example |
|--------|-------------|---------|
| `X-Cache` | Cache hit/miss status | `HIT` or `MISS` |
| `ETag` | Unique identifier for this result | `"a7f3b2c1..."` |
| `Cache-Control` | Browser/CDN caching instructions | `public, max-age=3600` |
| `Vary` | Vary cache by headers | `X-Retriever, X-Namespace` |

### Client Benefits

‚úÖ **No network transfer** - 304 responses have empty body  
‚úÖ **Sub-10ms responses** - Client validates ETag only  
‚úÖ **CDN compatible** - Standard HTTP caching headers  
‚úÖ **Browser caching** - Works with fetch/axios automatically  

## Performance

### Benchmarks

| Operation | Latency | Improvement |
|-----------|---------|-------------|
| Cache HIT | ~0.39ms | 4.4x faster than MISS |
| Cache MISS | ~1.72ms | (baseline) |
| Retriever (uncached) | ~1500ms | 3850x faster with cache |
| 304 Not Modified | ~10ms | 150x faster than uncached |

### Expected Production Impact

- ‚ö° **80%+ compute cost reduction** (at 80% cache hit rate)
- üöÄ **Sub-50ms cached responses** (target: 10-50ms)
- üí∞ **Significant infrastructure savings** (fewer Ray actor invocations)
- üìâ **Reduced database load** (fewer Qdrant/MongoDB queries)

## Security & Compliance

### PII Protection

Exclude sensitive fields from caching:

```json
{
  "cache_config": {
    "enabled": true,
    "exclude_fields": ["ssn", "email", "credit_card"]
  }
}
```

### Namespace Isolation

All cache keys include namespace ID for multi-tenancy security:

```
mixpeek:{namespace_id}:{collection}:{retriever}:{hash}
```

Each tenant's cache is completely isolated from other tenants.

### TLS Support

Use `rediss://` protocol for encrypted Redis connections:

```bash
export REDIS_URL="rediss://user:pass@prod-redis:6379"
```

### GDPR Compliance

Cache invalidation supports right-to-be-forgotten (RTBF):
- **Automatic expiration**: All cached data expires after TTL
- **Manual invalidation**: Delete specific user data via KEY-level invalidation
- **Data retention**: Configure TTL based on retention policies

## Best Practices

### Optimization Tips

1. **Increase TTL for stable content** - Archives: 24h, Docs: 1h, News: 5min
2. **Monitor hit rates** - Aim for 80%+ for frequently accessed content
3. **Use KEY-level invalidation** - More efficient than COLLECTION-level when possible
4. **Enable caching for all retrievers** - Unless content changes constantly
5. **Set appropriate memory limits** - Redis should have 2-3x cache size overhead

### When to Disable Caching

Consider disabling caching when:
- **Content changes constantly** (< 1 minute freshness required)
- **Queries are always unique** (no repeated patterns)
- **Results include time-sensitive data** (stock prices, live scores)
- **Privacy requirements prohibit caching** (sensitive PII)

### Monitoring

Check cache performance via response headers:

```bash
# Cache hit rate
curl -i /v1/retrievers/ret_semantic/execute | grep "X-Cache: HIT"

# ETag validation
curl -i -H "If-None-Match: <etag>" /v1/retrievers/ret_semantic/execute
```

Alert thresholds:
- ‚ö†Ô∏è Hit rate < 50% - Investigate cache configuration or TTL
- ‚ö†Ô∏è Evictions > 10% - Increase Redis memory
- ‚ö†Ô∏è Redis health != "ok" - Check Redis connection

## Implementation Details

### Request Flow

1. Client sends request to `/v1/retrievers/{id}/execute`
2. Controller checks `retriever.cache_config.enabled`
3. If enabled:
   - Build cache key from request components
   - Generate ETag (SHA-256 hash)
   - Check `If-None-Match` header ‚Üí return 304 if match
   - Check Redis cache ‚Üí return cached result if hit
4. If cache miss, execute retriever (SearchFlow)
5. Store result in cache with TTL
6. Return response with cache headers (`X-Cache`, `ETag`, `Cache-Control`)

### Cache Key Components

```python
{
  "namespace": "ns_acme",
  "collection": "col_articles",
  "retriever_id": "ret_semantic",
  "query_inputs": {"text": "machine learning"},
  "filters": {"category": "tech"},
  "sorts": [{"field": "date", "order": "desc"}],
  "limit": 10,
  "offset": 0,
  "index_signature": "sig_abc123",
  "model_version": "v2.0"
}
```

### Cache Stages

| Stage | Description | What's Cached |
|-------|-------------|---------------|
| `retrieval` | Cache search results only | Document matches, scores, metadata |
| `generation` | Cache LLM responses only | Generated text, completions |
| `full` | Cache entire pipeline | End-to-end results |

## Examples

### Enable Caching

```json
POST /v1/retrievers
{
  "retriever_name": "semantic_search",
  "collection_ids": ["col_articles"],
  "stages": [
    {
      "stage_name": "knn_search",
      "parameters": {
        "feature_field_name": "text_embedding",
        "top_k": 10
      }
    }
  ],
  "cache_config": {
    "enabled": true,
    "ttl_seconds": 3600
  }
}
```

### Execute with Caching

```bash
# First request (MISS)
curl -i https://api.mixpeek.com/v1/retrievers/ret_semantic/execute \
  -H "Authorization: Bearer $API_KEY" \
  -H "X-Namespace: ns_acme" \
  -d '{"inputs": {"text": "machine learning"}}'

# Response:
# X-Cache: MISS
# ETag: "a7f3b2c1e5d4..."
# (1500ms response time)

# Second request (HIT)
curl -i https://api.mixpeek.com/v1/retrievers/ret_semantic/execute \
  -H "Authorization: Bearer $API_KEY" \
  -H "X-Namespace: ns_acme" \
  -d '{"inputs": {"text": "machine learning"}}'

# Response:
# X-Cache: HIT
# ETag: "a7f3b2c1e5d4..."
# (0.39ms response time - 3850x faster!)
```

### Use ETag Validation

```bash
curl -i https://api.mixpeek.com/v1/retrievers/ret_semantic/execute \
  -H "Authorization: Bearer $API_KEY" \
  -H "X-Namespace: ns_acme" \
  -H "If-None-Match: a7f3b2c1e5d4..." \
  -d '{"inputs": {"text": "machine learning"}}'

# If unchanged:
# HTTP/1.1 304 Not Modified
# (10ms response time, empty body)
```