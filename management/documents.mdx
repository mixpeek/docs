---
title: "Documents"
description: "Work with structured documents created from processed objects"
---

<Note>
  Documents are the structured outputs from ingestion pipelines, representing processed data stored in collections with a consistent schema.
</Note>

## What are Documents?

In Mixpeek, documents are the structured outputs created when objects are processed by pipelines. They contain the extracted features, metadata, and content organized in a consistent schema, making them ready for efficient search and retrieval.

<CardGroup cols={2}>
  <Card title="Structured Data" icon="file-lines">
    Organized representation of processed content with a consistent schema defined by the pipeline
  </Card>
  
  <Card title="Collection Members" icon="layer-group">
    Documents belong to collections, inheriting their structure and index configuration
  </Card>
</CardGroup>

## Key Concepts

<AccordionGroup>
  <Accordion title="Object Lineage" icon="code-branch">
    Every document maintains a reference to its source object, providing complete data lineage back to the original raw files.
  </Accordion>

  <Accordion title="Feature References" icon="puzzle-piece">
    Documents contain or reference extracted features that enable sophisticated search and retrieval operations.
  </Accordion>

  <Accordion title="Schema Consistency" icon="table-columns">
    All documents in a collection share the same schema, determined by the pipeline that created them.
  </Accordion>

  <Accordion title="System Metadata" icon="tags">
    Documents include standard system metadata fields that track processing status and pipeline information.
  </Accordion>
</AccordionGroup>

## Document Structure

Documents have a consistent structure that includes system metadata and content specific to the document type:

<Frame>
  ```json
  {
    // System identifiers
    "document_id": "doc_stu901",
    "collection_id": "col_mno345",
    "source_object_id": "obj_ghi789",
    
    // System metadata
    "__fully_enriched": true,
    "__missing_features": [],
    "__pipeline_version": 2,
    
    // Content (varies by document type and pipeline configuration)
    "title": "Quarterly Financial Report Q1 2023",
    "content_type": "report",
    "summary": "This report outlines financial performance for Q1 2023...",
    "detected_topics": ["finance", "quarterly report", "earnings"],
    "sentiment": "neutral",
    "page_count": 15,
    "language": "en",
    
    // Extracted features may be referenced or included
    "extracted_text": "...",
    "embedding_id": "emb_vwx234",
    
    // Timestamps
    "created_at": "2023-06-12T09:45:00Z",
    "updated_at": "2023-06-12T09:45:00Z"
  }
  ```
</Frame>

### System Metadata Fields

All documents include these standard system metadata fields:

| Field | Type | Description |
|-------|------|-------------|
| `document_id` | string | Unique identifier for the document |
| `collection_id` | string | ID of the collection containing this document |
| `source_object_id` | string | Reference to the source object that was processed |
| `__fully_enriched` | boolean | Indicates if all expected features were successfully extracted |
| `__missing_features` | array | Lists any features that failed to extract during processing |
| `__pipeline_version` | integer | Version of the pipeline that processed this document |

## Creating Documents

Documents are created automatically when objects are processed by pipelines. You don't typically create documents directly, but instead define pipelines that output documents to collections.

<Steps>
  <Step title="Define a Pipeline">
    Create a pipeline that defines how objects should be processed and which collections should receive the output documents.
    
    ```python
    from mixpeek import Mixpeek
    
    mp = Mixpeek(api_key="YOUR_API_KEY")
    
    # Define a pipeline that creates documents
    pipeline = mp.pipelines.create(
        namespace_id="ns_abc123",
        name="document-processing",
        description="Extract features from document objects",
        input_bucket_id="bkt_def456",
        output_collection_ids=["col_mno345"],
        feature_extractors=[
            {
                "read": {"enabled": True},
                "embed": [
                    {
                        "type": "text",
                        "embedding_model": "text"
                    }
                ],
                "summarize": {"enabled": True},
                "classify": {
                    "topics": {"enabled": True},
                    "sentiment": {"enabled": True}
                }
            }
        ]
    )
    
    pipeline_id = pipeline["pipeline_id"]
    ```
  </Step>
  
  <Step title="Process Objects">
    Run the pipeline on objects to generate documents in the specified collection.
    
    ```python
    # Process an object to create documents
    task = mp.pipelines.run(
        pipeline_id=pipeline_id,
        object_id="obj_ghi789"
    )
    
    task_id = task["task_id"]
    print(f"Processing task started: {task_id}")
    ```
  </Step>
</Steps>

## Querying Documents

You can query and retrieve documents using several methods:

<CodeGroup>
  ```python Python
  # Get a specific document by ID
  document = mp.documents.get(document_id="doc_stu901")
  
  print(f"Document title: {document['title']}")
  print(f"Created from object: {document['source_object_id']}")
  
  # List documents in a collection with filtering
  documents = mp.documents.list(
      collection_id="col_mno345",
      filter={
          "content_type": "report",
          "language": "en",
          "page_count": {"$gt": 10}
      },
      limit=20
  )
  
  for doc in documents["documents"]:
      print(f"Document: {doc['title']} (ID: {doc['document_id']})")
  ```

  ```javascript JavaScript
  // Get a specific document by ID
  const document = await mp.documents.get({
    document_id: "doc_stu901"
  });
  
  console.log(`Document title: ${document.title}`);
  console.log(`Created from object: ${document.source_object_id}`);
  
  // List documents in a collection with filtering
  const documents = await mp.documents.list({
    collection_id: "col_mno345",
    filter: {
      content_type: "report",
      language: "en",
      page_count: {$gt: 10}
    },
    limit: 20
  });
  
  for (const doc of documents.documents) {
    console.log(`Document: ${doc.title} (ID: ${doc.document_id})`);
  }
  ```

  ```bash cURL
  # Get a specific document by ID
  curl -X GET "https://api.mixpeek.com/v1/documents/doc_stu901" \
    -H "Authorization: Bearer YOUR_API_KEY" \
    -H "Content-Type: application/json"
    
  # List documents in a collection with filtering
  curl -X POST "https://api.mixpeek.com/v1/documents/list" \
    -H "Authorization: Bearer YOUR_API_KEY" \
    -H "Content-Type: application/json" \
    -d '{
      "collection_id": "col_mno345",
      "filter": {
        "content_type": "report",
        "language": "en",
        "page_count": {"$gt": 10}
      },
      "limit": 20
    }'
  ```
</CodeGroup>

## Advanced Document Query Operators

Mixpeek supports a variety of query operators for filtering documents:

<AccordionGroup>
  <Accordion title="Comparison Operators" icon="greater-than">
    | Operator | Description | Example |
    |----------|-------------|---------|
    | `$eq` | Equals | `{"field": {"$eq": value}}` |
    | `$ne` | Not equals | `{"field": {"$ne": value}}` |
    | `$gt` | Greater than | `{"field": {"$gt": value}}` |
    | `$gte` | Greater than or equal | `{"field": {"$gte": value}}` |
    | `$lt` | Less than | `{"field": {"$lt": value}}` |
    | `$lte` | Less than or equal | `{"field": {"$lte": value}}` |
  </Accordion>

  <Accordion title="Logical Operators" icon="code-branch">
    | Operator | Description | Example |
    |----------|-------------|---------|
    | `$and` | Logical AND | `{"$and": [{...}, {...}]}` |
    | `$or` | Logical OR | `{"$or": [{...}, {...}]}` |
    | `$not` | Logical NOT | `{"$not": {...}}` |
  </Accordion>

  <Accordion title="Array Operators" icon="list">
    | Operator | Description | Example |
    |----------|-------------|---------|
    | `$in` | In array | `{"field": {"$in": [value1, value2]}}` |
    | `$nin` | Not in array | `{"field": {"$nin": [value1, value2]}}` |
    | `$all` | Contains all | `{"field": {"$all": [value1, value2]}}` |
    | `$contains` | Contains element | `{"field": {"$contains": value}}` |
  </Accordion>

  <Accordion title="Text Search Operators" icon="font">
    | Operator | Description | Example |
    |----------|-------------|---------|
    | `$text` | Full-text search | `{"field": {"$text": "search terms"}}` |
    | `$regex` | Regular expression | `{"field": {"$regex": "pattern"}}` |
  </Accordion>
</AccordionGroup>

### Example Complex Query

```python
# Complex query with multiple operators
documents = mp.documents.list(
    collection_id="col_mno345",
    filter={
        "$and": [
            {
                "content_type": "report"
            },
            {
                "$or": [
                    {"detected_topics": {"$contains": "finance"}},
                    {"detected_topics": {"$contains": "earnings"}}
                ]
            },
            {
                "created_at": {"$gte": "2023-01-01T00:00:00Z"}
            },
            {
                "sentiment": {"$ne": "negative"}
            }
        ]
    },
    limit=20
)
```

## Semantic Search with Documents

While direct document queries are useful for metadata filtering, Mixpeek's real power comes from semantic search using retrievers:

```python
# Create a retriever for semantic search
retriever = mp.retrievers.create(
    namespace_id="ns_abc123",
    name="report-search",
    description="Search across financial reports",
    stages=[
        {
            "name": "embedding_search",
            "type": "vector",
            "collection_id": "col_mno345",
            "index": "text",
            "limit": 50
        },
        {
            "name": "filters",
            "type": "filter",
            "input": "embedding_search.results",
            "filter": {
                "content_type": "report",
                "created_at": {"$gte": "2023-01-01T00:00:00Z"}
            },
            "limit": 20
        }
    ]
)

retriever_id = retriever["retriever_id"]

# Perform semantic search
results = mp.retrievers.search(
    retriever_id=retriever_id,
    query={
        "text": "quarterly revenue growth trends"
    }
)

for result in results["results"]:
    print(f"Document: {result['title']} (Score: {result['score']})")
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Optimize Document Schema" icon="table-columns">
    Design document schemas that efficiently support your retrieval needs, with fields that enable effective filtering and sorting
  </Card>
  
  <Card title="Use Appropriate Filters" icon="filter">
    Combine metadata filtering with vector search to narrow results and improve relevance
  </Card>

  <Card title="Consider Feature Storage" icon="database">
    For large features like full text or large embeddings, consider how they are stored and referenced
  </Card>
  
  <Card title="Monitor Enrichment Status" icon="gauge-high">
    Check the __fully_enriched flag to ensure all expected features were successfully extracted
  </Card>
</CardGroup>

<Warning>
  Direct document queries work well for metadata filtering, but for semantic understanding and similarity search, use retrievers that leverage the power of feature stores and vector search.
</Warning>

## API Reference

For complete details on working with documents, see our [Documents API Reference](/api-reference/documents/get-document). 