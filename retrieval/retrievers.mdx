---
title: "Retrievers"
description: "Compose stage-based search pipelines over your collections"
---

Retrievers combine feature-aware search stages, structured filters, enrichment joins, and optional LLM post-processing into a single executable pipeline. Each retriever has an input schema, a list of target collections, and a deterministic set of stages executed in order.

## Anatomy of a Retriever

```json
{
  "retriever_name": "product_search_v2",
  "description": "Semantic + hybrid search with reranking",
  "collection_ids": ["col_products"],
  "input_schema": {
    "properties": {
      "query_text": { "type": "text", "required": true },
      "max_price": { "type": "number" }
    }
  },
  "stages": [
    {
      "stage_name": "hybrid_search",
      "version": "v1",
      "parameters": {
        "dense_feature_address": "mixpeek://text_extractor@v1/text_embedding",
        "sparse_feature_address": "mixpeek://splade_extractor@v1/splade_vector",
        "input_mapping": { "text": "query_text" },
        "limit": 200,
        "dense_weight": 0.7,
        "sparse_weight": 0.3,
        "sort_by": [{ "field": "score", "direction": "desc" }]
      }
    },
    {
      "stage_name": "filter",
      "version": "v1",
      "parameters": {
        "strategy": "structured",
        "structured_filter": {
          "AND": [
            { "field": "metadata.in_stock", "operator": "eq", "value": true },
            { "field": "metadata.price", "operator": "lte", "value": "{{INPUT.max_price}}" }
          ]
        }
      }
    },
    {
      "stage_name": "rerank",
      "version": "v1",
      "parameters": {
        "strategy": "cross_encoder",
        "model": "bge-reranker-v2-m3",
        "top_k": 50
      }
    }
  ],
  "cache_config": {
    "enabled": true,
    "ttl_seconds": 300,
    "cache_stage_names": ["hybrid_search"]
  }
}
```

## Stage Catalog

Stages are the building blocks of retriever pipelines. Each stage belongs to a **category** that defines its behavior:

| Category | Behavior | Example Use Cases |
|----------|----------|-------------------|
| **filter** | Reduce the number of documents while preserving schema | Attribute filters, semantic search, hybrid search |
| **sort** | Reorder documents without changing the set | Attribute sort, score-based ordering, reranking |
| **reduce** | Aggregate to a smaller set of documents | Top-k selection, clustering reducers, deduplication |
| **apply** | Enrich or transform documents without dropping them | Taxonomy joins, API enrichment, LLM enrichers, JSON transforms |

<Note>
  Retrieve the live registry with `GET /v1/retrievers/stages`. Each entry includes `stage_id`, category, icon, and parameter schema so you can dynamically build configuration UIs or validations.

  **Live stages:** [https://api.mixpeek.com/v1/retrievers/stages](https://api.mixpeek.com/v1/retrievers/stages)
</Note>

<CodeGroup>
```bash
curl -s --request GET \
  --url "$MP_API_URL/v1/retrievers/stages" \
  --header "Authorization: Bearer $MP_API_KEY" \
  --header "X-Namespace: $MP_NAMESPACE"
```

```json
[
  {
    "stage_id": "feature_search",
    "description": "Vector similarity search using feature embeddings",
    "category": "filter",
    "icon": "search"
  },
  {
    "stage_id": "document_enrich",
    "description": "Join and enrich documents with data from another collection",
    "category": "apply",
    "icon": "link"
  }
]
```
</CodeGroup>

### Filter Stages

Filter stages reduce the document set while preserving the document schema. Use these at the start of your pipeline to narrow down candidates.

| Stage ID | Description |
|----------|-------------|
| `feature_search` | Vector similarity search using feature embeddings (dense retrieval) |
| `hybrid_search` | Combined dense + sparse retrieval with reciprocal-rank or weighted-score fusion |
| `attribute_filter` | Structured filtering with boolean logic (`AND`, `OR`, `NOT`) and comparison operators |
| `llm_filter` | LLM-powered screening that keeps or discards documents based on prompt-defined criteria |

### Sort Stages

Sort stages reorder documents without changing the result set. Place these after filters to control ranking.

| Stage ID | Description |
|----------|-------------|
| `sort_attribute` | Sort by any payload field with case-insensitive and null handling options |
| `sort_relevance` | Sort by relevance score or custom numeric field with fallbacks for missing scores |
| `rerank` | Cross-encoder reranking using models like `bge-reranker-v2-m3` for improved relevance |

### Reduce Stages

Reduce stages aggregate documents to a smaller set. Use these for deduplication or clustering.

| Stage ID | Description |
|----------|-------------|
| `top_k` | Select top K documents by score or attribute |
| `deduplicate` | Remove duplicate documents based on field values or similarity threshold |

### Apply Stages

Apply stages enrich or transform documents without dropping them (1-1 transformation). Use these to add context, join data, or reshape output.

| Stage ID | Description |
|----------|-------------|
| `document_enrich` | Join documents with data from another collection (SQL-like JOIN) |
| `taxonomy_enrich` | Attach taxonomy assignments via feature URIs and copy enrichment fields |
| `api_call` | Enrich documents with external API calls (supports auth, rate limiting, SSRF protection) |
| `json_transform` | Transform document structure using Jinja2 templates to reshape output schema |
| `external_web_search` | Search the web using Exa AI-native search to create new documents |
| `llm_enrich` | Generate new fields with an LLM, respecting per-document conditions and output schemas |

### Stage Configuration Example

Each stage requires a `stage_type`, `stage_id`, and `parameters`:

```json
{
  "stages": [
    {
      "stage_type": "filter",
      "stage_id": "feature_search",
      "parameters": {
        "feature_uri": "urn:embedding:text:multilingual_e5_large:1",
        "input": { "text": "{{INPUT.query_text}}" },
        "limit": 100
      }
    },
    {
      "stage_type": "apply",
      "stage_id": "document_enrich",
      "parameters": {
        "target_collection_id": "col_catalog",
        "source_field": "metadata.product_id",
        "target_field": "product_id",
        "fields_to_merge": ["price", "inventory"],
        "output_field": "catalog_data"
      }
    },
    {
      "stage_type": "apply",
      "stage_id": "api_call",
      "parameters": {
        "url": "https://api.stripe.com/v1/customers/{{DOC.metadata.customer_id}}",
        "method": "GET",
        "allowed_domains": ["api.stripe.com"],
        "auth": {
          "type": "bearer",
          "secret_ref": "stripe_api_key"
        },
        "output_field": "metadata.billing",
        "on_error": "skip"
      }
    },
    {
      "stage_type": "apply",
      "stage_id": "json_transform",
      "parameters": {
        "template": "{\"id\": \"{{DOC.document_id}}\", \"title\": \"{{DOC.metadata.title}}\", \"price\": {{DOC.catalog_data.price}}}",
        "fail_on_error": false
      }
    }
  ]
}
```

Call `GET /v1/retrievers/stages` whenever you need the latest metadata or parameter schemas.

## Execution Lifecycle

1. **Validate Inputs** – Mixpeek enforces the retriever’s `input_schema`.
2. **Walk Stages** – Each stage receives the current working set, runs, and outputs a new set.
3. **Apply Pagination** – `limit`, `offset`, `cursor`, or `keyset` pagination is handled after the final stage.
4. **Return Telemetry** – Responses include `stage_statistics`, `budget`, and optional presigned URLs.

Response headers include:

- `ETag` – cache validator; pair with `If-None-Match` for 304 responses.
- `Cache-Control` – TTL derived from `cache_config`.
- `X-Cache` – `HIT` or `MISS` for query-level caching.

## Filters & Templates

Structured filters support comparison operators (`eq`, `gt`, `lte`, `in`, etc.) and logical composition (`AND`, `OR`, `NOT`).

### Template Namespaces

Stages support dynamic configuration through template expressions using Jinja2 syntax. Both uppercase and lowercase namespace formats are supported and work identically:

| Namespace | Description | Examples |
|-----------|-------------|----------|
| `INPUT` / `inputs` | User-provided query parameters and inputs | `{{INPUT.query_text}}`, `{{inputs.max_price}}` |
| `DOC` / `doc` | Current document fields (for per-document logic) | `{{DOC.metadata.category}}`, `{{doc.content_type}}` |
| `CONTEXT` / `context` | Execution state (budget, timing, retriever metadata) | `{{CONTEXT.budget_remaining}}`, `{{context.time_elapsed_ms}}` |
| `STAGE` / `stage` | Previous stage outputs (for cascading logic) | `{{STAGE.hybrid_search.top_score}}`, `{{stage.filter.count}}` |

<Note>
  Mixed usage within the same stage is supported. For example, you can use `{{INPUT.query}}` alongside `{{context.budget_remaining}}` in the same configuration.
</Note>

**Conditional expressions:**

```json
{
  "batch_size": "{{CONTEXT.budget_remaining > 50 ? 200 : 50}}",
  "field": "{{DOC.media_type == 'image' ? 'image_url' : 'video_url'}}"
}
```

**Templated batch size:**

```json
{
  "batch_size": "{{20 * inputs.page_size}}"
}
```

## Retrievers & Caching

- **Query cache** – caches entire responses keyed by inputs, filters, pagination, and collection index signatures.
- **Stage cache** – reuse outputs of expensive stages by listing them under `cache_stage_names`.
- **Inference cache** – Engine deduplicates identical model calls.

Use `GET /v1/analytics/retrievers/{id}/cache-performance` to monitor hit rates and latency improvements.

## Pagination Options

| Method | Use Case |
|--------|----------|
| `offset` | Simple pagination, supports `limit` + `offset` |
| `cursor` | Stable iteration over large result sets |
| `scroll` | Deep pagination for analytics workloads |
| `keyset` | High-performance paginated browsing (requires sort key) |

Specify the method in `pagination.method` when executing a retriever.

## Execute a Retriever

```bash
curl -sS -X POST "$MP_API_URL/v1/retrievers/<retriever_id>/execute" \
  -H "Authorization: Bearer $MP_API_KEY" \
  -H "X-Namespace: $MP_NAMESPACE" \
  -H "Content-Type: application/json" \
  -d '{
    "inputs": {
      "query_text": "wireless earbuds",
      "max_price": 150
    },
    "filters": {
      "field": "metadata.category",
      "operator": "eq",
      "value": "audio"
    },
    "limit": 10,
    "return_urls": true,
    "return_vectors": false,
    "session_id": "sess_123"
  }'
```

Response snippet:

```json
{
  "execution_id": "exec_b8f31e0c",
  "documents": [...],
  "stage_statistics": {
    "hybrid_search": { "duration_ms": 180, "cache_hit": true },
    "filter": { "duration_ms": 8 },
    "rerank": { "duration_ms": 120 }
  },
  "budget": {
    "credits_used": 12.4,
    "credits_limit": 100,
    "time_elapsed_ms": 310
  }
}
```

## Maintenance & Versioning

- Use `PATCH /v1/retrievers/{id}` to rename retrievers or adjust cache settings (stages and schema are immutable; create a new retriever for breaking changes).
- List retrievers with filters, search, and sort: `POST /v1/retrievers/list`.
- Retrieve execution history: `GET /v1/retrievers/{id}/executions`.
- Diagnose pipelines without executing: `POST /v1/retrievers/{id}/explain`.

## Interaction Feedback

Capture user feedback with `/v1/retrievers/interactions` to power downstream analytics, learning-to-rank, or personalized retrieval:

```json
{
  "feature_id": "doc_abc123",
  "interaction_type": ["click", "long_view"],
  "position": 2,
  "metadata": { "duration_ms": 12000 },
  "user_id": "user_456",
  "session_id": "sess_xyz789"
}
```

## Best Practices

1. **Start narrow** – run a single search stage before adding rerankers or joins.
2. **Push filters early** – stage-level filters shrink the candidate set before expensive operations.
3. **Use JOIN strategies wisely** – `direct` for key-based joins, `retriever` for similarity joins; set `join_strategy` to control merge behavior.
4. **Enable caching** – stage caching plus query caching dramatically reduces latency for repeat queries.
5. **Monitor analytics** – use retriever analytics endpoints to optimize parameters, detect slow stages, and understand cache ROI.

Retrievers turn Mixpeek’s primitives—features, taxonomies, clusters, and models—into end-user search experiences. Configure once, execute anywhere, and evolve the pipeline with confidence.
