---
title: "Security & Tenancy"
description: "Authentication, authorization, isolation, and operational safeguards"
---

Mixpeek enforces organization-level authentication, namespace isolation, and stage-level validation across the entire stack. This page summarizes the security model and operational protections you should configure in production.

## Authentication

- **Header**: `Authorization: Bearer <api_key>`
- API keys belong to an organization; keys can be rotated, revoked, or scoped per environment.
- Sensitive operations (e.g., creating namespaces, rotating keys) require elevated permissions.

## Namespace Isolation

- **Header**: `X-Namespace: <namespace_id or namespace_name>`
- Every MongoDB query filters on `namespace_id`; indexes ensure isolation at scale.
- Qdrant uses one collection per namespace (`ns_<namespace_id>`); payload filters ensure cross-collection safety.
- Redis cache keys and Ray job metadata include namespace identifiers.

### Dual Identifier Model

| Identifier | Visible? | Purpose |
|------------|----------|---------|
| `organization_id` | Yes | User-facing identifier in API responses |
| `internal_id` | No | Primary key for service-to-service lookups |
| `namespace_id` | Yes | Isolation boundary for data and compute |

Keep `internal_id` secret; it is intentionally absent from public APIs.

## Authorization & Rate Limits

- Routes declare required permission levels (`read`, `write`, `delete`, `admin`).
- Rate limits enforced via Redis middleware; set per-plan and per-route to protect backends.
- Tasks and retriever executions consume credits; analytics endpoints expose usage metrics for billing reconciliation.

## Secrets & Credentials

Mixpeek provides an encrypted secrets vault for storing sensitive credentials like API keys. Secrets are encrypted at rest using Fernet symmetric encryption and are never exposed in API responses.

### Organization Secrets Vault

Store and manage secrets via the API:

<CodeGroup>
```bash Create a Secret
curl -X POST "https://api.mixpeek.com/v1/organizations/secrets" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "secret_name": "openai_api_key",
    "secret_value": "sk-proj-abc123..."
  }'
```

```bash List Secrets
# Returns secret names only - values are never exposed
curl "https://api.mixpeek.com/v1/organizations/secrets" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

```bash Update a Secret
curl -X PUT "https://api.mixpeek.com/v1/organizations/secrets/openai_api_key" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "secret_value": "sk-proj-new-key..."
  }'
```

```bash Delete a Secret
curl -X DELETE "https://api.mixpeek.com/v1/organizations/secrets/openai_api_key" \
  -H "Authorization: Bearer YOUR_API_KEY"
```
</CodeGroup>

### Bring Your Own Key (BYOK)

Use your own LLM API keys in retriever stages instead of Mixpeek's default keys. This gives you:

| Benefit | Description |
|---------|-------------|
| **Cost Control** | Use your own API credits and billing |
| **Rate Limits** | Use your own rate limits instead of shared |
| **Compliance** | Keep API calls under your own account |
| **Key Rotation** | Rotate keys without modifying retrievers |

#### Supported Providers

| Provider | Secret Name Example | Models |
|----------|---------------------|--------|
| OpenAI | `openai_api_key` | gpt-4o, gpt-4o-mini |
| Anthropic | `anthropic_api_key` | claude-3-haiku, claude-3-sonnet, claude-3-opus |
| Google | `google_api_key` | gemini-2.0-flash, gemini-1.5-pro |

#### Using BYOK in Retrievers

Reference secrets in LLM stages using template syntax:

```json
{
  "stages": [
    {
      "stage_type": "enrich",
      "stage_id": "llm_enrich",
      "parameters": {
        "provider": "openai",
        "model": "gpt-4o-mini",
        "prompt": "Summarize this document.",
        "output_field": "summary",
        "api_key": "{{secrets.openai_api_key}}"
      }
    }
  ]
}
```

The `{{secrets.secret_name}}` syntax automatically resolves the secret from your organization's vault at runtime.

<Note>
  When `api_key` is omitted, stages use Mixpeek's default API keys and usage is charged to your Mixpeek account.
</Note>

### Security Best Practices

- **Rotate credentials regularly** – Update secrets via the API without changing retriever configurations
- **Use IAM roles** – For S3/GCS access, prefer IAM roles over long-lived access keys
- **Audit access logs** – Monitor secret access patterns for anomalies
- **Scope API keys** – Issue environment-specific Mixpeek API keys (dev, staging, prod)

## Data Protection

- **Storage**: rely on encryption at rest provided by MongoDB Atlas, Qdrant Cloud, or your infrastructure.
- **Transit**: require TLS for API endpoints and Ray Serve; use mTLS or network policies for cross-service traffic when available.
- **Backups**: configure automated backups for MongoDB and Qdrant; version S3 buckets with lifecycle policies.

## Operational Safeguards

- Enable `/v1/health` probes in load balancers to route around unhealthy instances.
- Use webhooks to detect ingestion completion; failed webhook deliveries remain retriable in MongoDB.
- Monitor rate-limit counters and task failure rates to spot abusive or buggy clients.
- Log request IDs and namespace IDs to correlate incidents quickly.

## Hardening Checklist

1. **Network** – restrict API access to trusted origins, configure CORS, and use private networking for backend services.
2. **Auth** – issue scoped API keys, expire unused keys, enable audit logging.
3. **Secrets** – manage via Vault, AWS Secrets Manager, GCP Secret Manager, or Kubernetes secrets with rotation.
4. **Tenancy** – adopt one namespace per environment/tenant; enforce `X-Namespace` always.
5. **Monitoring** – alert on health endpoint status, rate-limit breaches, or repeated 401/403 responses.

## References

- [Namespaces](/ingestion/namespaces)
- [Observability](/operations/observability)
- [Webhooks](/operations/webhooks)
- [Tasks](/processing/tasks)
- [Health Check](/api-reference/health/healthcheck)
